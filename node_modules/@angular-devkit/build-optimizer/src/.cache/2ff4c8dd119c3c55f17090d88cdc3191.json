{"remainingRequest":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\tabs.es5.js","dependencies":[{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\tabs.es5.js","mtime":1554924123973},{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1554924186691},{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1554924110461}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright (c) 2018 Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\n/** PURE_IMPORTS_START _angular_core,rxjs,rxjs_operators,_angular_mdc_web_common,_angular_mdc_web_ripple,_angular_mdc_web_icon PURE_IMPORTS_END */\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, HostBinding, Input, Output, Renderer2, ViewEncapsulation, ContentChildren, NgZone, ViewChild, NgModule } from '@angular/core';\nimport { Subject, defer, merge } from 'rxjs';\nimport { takeUntil, startWith, switchMap, take } from 'rxjs/operators';\nimport { MdcRouter, toBoolean, EventRegistry, isBrowser, toNumber, MdcRouterModule } from '@angular-mdc/web/common';\nimport { MdcRipple } from '@angular-mdc/web/ripple';\nimport { MdcIcon } from '@angular-mdc/web/icon';\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _get(object, property, receiver) {\n    if (object === null)\n        object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);\n        if (parent === null) {\n            return undefined;\n        }\n        else {\n            return _get(parent, property, receiver);\n        }\n    }\n    else if (\"value\" in desc) {\n        return desc.value;\n    }\n    else {\n        var getter = desc.get;\n        if (getter === undefined) {\n            return undefined;\n        }\n        return getter.call(receiver);\n    }\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass)\n        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @template A\n */\nvar MDCFoundation = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    _createClass(MDCFoundation, null, [{\n            key: \"cssClasses\",\n            /** @return enum{cssClasses} */\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports every\n                // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}\n                return {};\n            }\n            /** @return enum{strings} */\n        }, {\n            key: \"strings\",\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports all\n                // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}\n                return {};\n            }\n            /** @return enum{numbers} */\n        }, {\n            key: \"numbers\",\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports all\n                // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n                return {};\n            }\n            /** @return {!Object} */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n                // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n                // validation.\n                return {};\n            }\n            /**\n             * @param {A=} adapter\n             */\n        }]);\n    function MDCFoundation() {\n        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, MDCFoundation);\n        /** @protected {!A} */\n        this.adapter_ = adapter;\n    }\n    _createClass(MDCFoundation, [{\n            key: \"init\",\n            value: function init() {\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n            }\n        }]);\n    return MDCFoundation;\n}();\n/**\n * @template F\n */\nvar MDCComponent = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    _createClass(MDCComponent, null, [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCComponent}\n             */\n            value: function attachTo(root) {\n                // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and\n                // returns an instantiated component with its root set to that element. Also note that in the cases of\n                // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized\n                // from getDefaultFoundation().\n                return new MDCComponent(root, new MDCFoundation());\n            }\n            /**\n             * @param {!Element} root\n             * @param {F=} foundation\n             * @param {...?} args\n             */\n        }]);\n    function MDCComponent(root) {\n        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        _classCallCheck(this, MDCComponent);\n        /** @protected {!Element} */\n        this.root_ = root;\n        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n            args[_key - 2] = arguments[_key];\n        }\n        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that\n        // this.root_ is defined and can be used within the foundation class.\n        /** @protected {!F} */\n        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;\n        this.foundation_.init();\n        this.initialSyncWithDOM();\n    }\n    _createClass(MDCComponent, [{\n            key: \"initialize\",\n            value: function initialize() { } // Subclasses can override this to do any additional setup work that would be considered part of a\n            // \"constructor\". Essentially, it is a hook into the parent constructor before the foundation is\n            // initialized. Any additional arguments besides root and foundation will be passed in here.\n            /**\n             * @return {!F} foundation\n             */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                // Subclasses must override this method to return a properly configured foundation class for the\n                // component.\n                throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');\n            }\n        }, {\n            key: \"initialSyncWithDOM\",\n            value: function initialSyncWithDOM() {\n                // object. An example of this would be a form control wrapper that needs to synchronize its internal state\n                // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM\n                // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                // Subclasses may implement this method to release any resources / deregister any listeners they have\n                // attached. An example of this might be deregistering a resize event from the window object.\n                this.foundation_.destroy();\n            }\n            /**\n             * Wrapper method to add an event listener to the component's root element. This is most useful when\n             * listening for custom events.\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"listen\",\n            value: function listen(evtType, handler) {\n                this.root_.addEventListener(evtType, handler);\n            }\n            /**\n             * Wrapper method to remove an event listener to the component's root element. This is most useful when\n             * unlistening for custom events.\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"unlisten\",\n            value: function unlisten(evtType, handler) {\n                this.root_.removeEventListener(evtType, handler);\n            }\n            /**\n             * Fires a cross-browser-compatible custom event from the component root of the given type,\n             * with the given data.\n             * @param {string} evtType\n             * @param {!Object} evtData\n             * @param {boolean=} shouldBubble\n             */\n        }, {\n            key: \"emit\",\n            value: function emit(evtType, evtData) {\n                var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var evt;\n                if (typeof CustomEvent === 'function') {\n                    evt = new CustomEvent(evtType, {\n                        detail: evtData,\n                        bubbles: shouldBubble\n                    });\n                }\n                else {\n                    evt = document.createEvent('CustomEvent');\n                    evt.initCustomEvent(evtType, shouldBubble, false, evtData);\n                }\n                this.root_.dispatchEvent(evt);\n            }\n        }]);\n    return MDCComponent;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n/**\n * Adapter for MDC Ripple. Provides an interface for managing\n * - classes\n * - dom\n * - CSS variables\n * - position\n * - dimensions\n * - scroll position\n * - event handlers\n * - unbounded, active and disabled states\n *\n * Additionally, provides type information for the adapter to the Closure\n * compiler.\n *\n * Implement this adapter for your framework of choice to delegate updates to\n * the component in your framework of choice. See architecture documentation\n * for more details.\n * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md\n *\n * @record\n */\nvar MDCRippleAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCRippleAdapter() {\n        _classCallCheck(this, MDCRippleAdapter);\n    }\n    _createClass(MDCRippleAdapter, [{\n            key: \"browserSupportsCssVars\",\n            /** @return {boolean} */\n            value: function browserSupportsCssVars() { }\n            /** @return {boolean} */\n        }, {\n            key: \"isUnbounded\",\n            value: function isUnbounded() { }\n            /** @return {boolean} */\n        }, {\n            key: \"isSurfaceActive\",\n            value: function isSurfaceActive() { }\n            /** @return {boolean} */\n        }, {\n            key: \"isSurfaceDisabled\",\n            value: function isSurfaceDisabled() { }\n            /** @param {string} className */\n        }, {\n            key: \"addClass\",\n            value: function addClass(className) { }\n            /** @param {string} className */\n        }, {\n            key: \"removeClass\",\n            value: function removeClass(className) { }\n            /** @param {!EventTarget} target */\n        }, {\n            key: \"containsEventTarget\",\n            value: function containsEventTarget(target) { }\n            /**\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"registerInteractionHandler\",\n            value: function registerInteractionHandler(evtType, handler) { }\n            /**\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"deregisterInteractionHandler\",\n            value: function deregisterInteractionHandler(evtType, handler) { }\n            /**\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"registerDocumentInteractionHandler\",\n            value: function registerDocumentInteractionHandler(evtType, handler) { }\n            /**\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"deregisterDocumentInteractionHandler\",\n            value: function deregisterDocumentInteractionHandler(evtType, handler) { }\n            /**\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"registerResizeHandler\",\n            value: function registerResizeHandler(handler) { }\n            /**\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"deregisterResizeHandler\",\n            value: function deregisterResizeHandler(handler) { }\n            /**\n             * @param {string} varName\n             * @param {?number|string} value\n             */\n        }, {\n            key: \"updateCssVariable\",\n            value: function updateCssVariable(varName, value) { }\n            /** @return {!ClientRect} */\n        }, {\n            key: \"computeBoundingRect\",\n            value: function computeBoundingRect() { }\n            /** @return {{x: number, y: number}} */\n        }, {\n            key: \"getWindowPageOffset\",\n            value: function getWindowPageOffset() { }\n        }]);\n    return MDCRippleAdapter;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar cssClasses = {\n    // Ripple is a special case where the \"root\" component is really a \"mixin\" of sorts,\n    // given that it's an 'upgrade' to an existing component. That being said it is the root\n    // CSS class that all other CSS classes derive from.\n    ROOT: 'mdc-ripple-upgraded',\n    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',\n    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',\n    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',\n    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'\n};\nvar strings = {\n    VAR_LEFT: '--mdc-ripple-left',\n    VAR_TOP: '--mdc-ripple-top',\n    VAR_FG_SIZE: '--mdc-ripple-fg-size',\n    VAR_FG_SCALE: '--mdc-ripple-fg-scale',\n    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',\n    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'\n};\nvar numbers = {\n    PADDING: 10,\n    INITIAL_ORIGIN_SCALE: 0.6,\n    DEACTIVATION_TIMEOUT_MS: 225,\n    // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)\n    FG_DEACTIVATION_MS: 150,\n    // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)\n    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices\n};\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.\n * @private {boolean|undefined}\n */\nvar supportsCssVariables_;\n/**\n * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.\n * @private {boolean|undefined}\n */\nvar supportsPassive_;\n/**\n * @param {!Window} windowObj\n * @return {boolean}\n */\nfunction detectEdgePseudoVarBug(windowObj) {\n    // Detect versions of Edge with buggy var() support\n    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/\n    var document = windowObj.document;\n    var node = document.createElement('div');\n    node.className = 'mdc-ripple-surface--test-edge-var-bug';\n    document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.\n    // Additionally, getComputedStyle returns null in iframes with display: \"none\" in Firefox,\n    // but Firefox is known to support CSS custom properties correctly.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    var computedStyle = windowObj.getComputedStyle(node);\n    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';\n    node.remove();\n    return hasPseudoVarBug;\n}\n/**\n * @param {!Window} windowObj\n * @param {boolean=} forceRefresh\n * @return {boolean|undefined}\n */\nfunction supportsCssVariables(windowObj) {\n    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var supportsCssVariables = supportsCssVariables_;\n    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {\n        return supportsCssVariables;\n    }\n    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';\n    if (!supportsFunctionPresent) {\n        return;\n    }\n    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669\n    // See: README section on Safari\n    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');\n    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {\n        supportsCssVariables = !detectEdgePseudoVarBug(windowObj);\n    }\n    else {\n        supportsCssVariables = false;\n    }\n    if (!forceRefresh) {\n        supportsCssVariables_ = supportsCssVariables;\n    }\n    return supportsCssVariables;\n} //\n/**\n * Determine whether the current browser supports passive event listeners, and if so, use them.\n * @param {!Window=} globalObj\n * @param {boolean=} forceRefresh\n * @return {boolean|{passive: boolean}}\n */\nfunction applyPassive() {\n    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (supportsPassive_ === undefined || forceRefresh) {\n        var isSupported = false;\n        try {\n            globalObj.document.addEventListener('test', null, {\n                get passive() {\n                    isSupported = true;\n                }\n            });\n        }\n        catch (e) { }\n        supportsPassive_ = isSupported;\n    }\n    return supportsPassive_ ? {\n        passive: true\n    } : false;\n}\n/**\n * @param {!Object} HTMLElementPrototype\n * @return {!Array<string>}\n */\nfunction getMatchesProperty(HTMLElementPrototype) {\n    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {\n        return p in HTMLElementPrototype;\n    }).pop();\n}\n/**\n * @param {!Event} ev\n * @param {{x: number, y: number}} pageOffset\n * @param {!ClientRect} clientRect\n * @return {{x: number, y: number}}\n */\nfunction getNormalizedEventCoords(ev, pageOffset, clientRect) {\n    var x = pageOffset.x, y = pageOffset.y;\n    var documentX = x + clientRect.left;\n    var documentY = y + clientRect.top;\n    var normalizedX;\n    var normalizedY; // Determine touch point relative to the ripple container.\n    if (ev.type === 'touchstart') {\n        normalizedX = ev.changedTouches[0].pageX - documentX;\n        normalizedY = ev.changedTouches[0].pageY - documentY;\n    }\n    else {\n        normalizedX = ev.pageX - documentX;\n        normalizedY = ev.pageY - documentY;\n    }\n    return {\n        x: normalizedX,\n        y: normalizedY\n    };\n}\nvar ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs\nvar POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations\n/** @type {!Array<!EventTarget>} */\nvar activatedTargets = [];\n/**\n * @extends {MDCFoundation<!MDCRippleAdapter>}\n */\nvar MDCRippleFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCRippleFoundation, _MDCFoundation);\n    _createClass(MDCRippleFoundation, null, [{\n            key: \"cssClasses\",\n            get: function get() {\n                return cssClasses;\n            }\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings;\n            }\n        }, {\n            key: \"numbers\",\n            get: function get() {\n                return numbers;\n            }\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return {\n                    browserSupportsCssVars: function browserSupportsCssVars() { },\n                    isUnbounded: function isUnbounded() { },\n                    isSurfaceActive: function isSurfaceActive() { },\n                    isSurfaceDisabled: function isSurfaceDisabled() { },\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    containsEventTarget: function containsEventTarget() { },\n                    registerInteractionHandler: function registerInteractionHandler() { },\n                    deregisterInteractionHandler: function deregisterInteractionHandler() { },\n                    registerDocumentInteractionHandler: function registerDocumentInteractionHandler() { },\n                    deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() { },\n                    registerResizeHandler: function registerResizeHandler() { },\n                    deregisterResizeHandler: function deregisterResizeHandler() { },\n                    updateCssVariable: function updateCssVariable() { },\n                    computeBoundingRect: function computeBoundingRect() { },\n                    getWindowPageOffset: function getWindowPageOffset() { }\n                };\n            }\n        }]);\n    function MDCRippleFoundation(adapter) {\n        var _this;\n        _classCallCheck(this, MDCRippleFoundation);\n        _this = _possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));\n        /** @private {number} */\n        _this.layoutFrame_ = 0;\n        /** @private {!ClientRect} */\n        _this.frame_ =\n            /** @type {!ClientRect} */\n            {\n                width: 0,\n                height: 0\n            };\n        /** @private {!ActivationStateType} */\n        _this.activationState_ = _this.defaultActivationState_();\n        /** @private {number} */\n        _this.initialSize_ = 0;\n        /** @private {number} */\n        _this.maxRadius_ = 0;\n        /** @private {function(!Event)} */\n        _this.activateHandler_ = function (e) {\n            return _this.activate_(e);\n        };\n        /** @private {function(!Event)} */\n        _this.deactivateHandler_ = function (e) {\n            return _this.deactivate_(e);\n        };\n        /** @private {function(?Event=)} */\n        _this.focusHandler_ = function () {\n            return requestAnimationFrame(function () {\n                return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);\n            });\n        };\n        /** @private {function(?Event=)} */\n        _this.blurHandler_ = function () {\n            return requestAnimationFrame(function () {\n                return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);\n            });\n        };\n        /** @private {!Function} */\n        _this.resizeHandler_ = function () {\n            return _this.layout();\n        };\n        /** @private {{left: number, top:number}} */\n        _this.unboundedCoords_ = {\n            left: 0,\n            top: 0\n        };\n        /** @private {number} */\n        _this.fgScale_ = 0;\n        /** @private {number} */\n        _this.activationTimer_ = 0;\n        /** @private {number} */\n        _this.fgDeactivationRemovalTimer_ = 0;\n        /** @private {boolean} */\n        _this.activationAnimationHasEnded_ = false;\n        /** @private {!Function} */\n        _this.activationTimerCallback_ = function () {\n            _this.activationAnimationHasEnded_ = true;\n            _this.runDeactivationUXLogicIfReady_();\n        };\n        /** @private {?Event} */\n        _this.previousActivationEvent_ = null;\n        return _this;\n    }\n    /**\n     * We compute this property so that we are not querying information about the client\n     * until the point in time where the foundation requests it. This prevents scenarios where\n     * client-side feature-detection may happen too early, such as when components are rendered on the server\n     * and then initialized at mount time on the client.\n     * @return {boolean}\n     * @private\n     */\n    _createClass(MDCRippleFoundation, [{\n            key: \"isSupported_\",\n            value: function isSupported_() {\n                return this.adapter_.browserSupportsCssVars();\n            }\n            /**\n             * @return {!ActivationStateType}\n             */\n        }, {\n            key: \"defaultActivationState_\",\n            value: function defaultActivationState_() {\n                return {\n                    isActivated: false,\n                    hasDeactivationUXRun: false,\n                    wasActivatedByPointer: false,\n                    wasElementMadeActive: false,\n                    activationEvent: null,\n                    isProgrammatic: false\n                };\n            }\n        }, {\n            key: \"init\",\n            value: function init() {\n                var _this2 = this;\n                if (!this.isSupported_()) {\n                    return;\n                }\n                this.registerRootHandlers_();\n                var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses, ROOT = _MDCRippleFoundation$.ROOT, UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;\n                requestAnimationFrame(function () {\n                    _this2.adapter_.addClass(ROOT);\n                    if (_this2.adapter_.isUnbounded()) {\n                        _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple\n                        _this2.layoutInternal_();\n                    }\n                });\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                var _this3 = this;\n                if (!this.isSupported_()) {\n                    return;\n                }\n                if (this.activationTimer_) {\n                    clearTimeout(this.activationTimer_);\n                    this.activationTimer_ = 0;\n                    var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;\n                    this.adapter_.removeClass(FG_ACTIVATION);\n                }\n                this.deregisterRootHandlers_();\n                this.deregisterDeactivationHandlers_();\n                var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses, ROOT = _MDCRippleFoundation$2.ROOT, UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;\n                requestAnimationFrame(function () {\n                    _this3.adapter_.removeClass(ROOT);\n                    _this3.adapter_.removeClass(UNBOUNDED);\n                    _this3.removeCssVars_();\n                });\n            }\n            /** @private */\n        }, {\n            key: \"registerRootHandlers_\",\n            value: function registerRootHandlers_() {\n                var _this4 = this;\n                ACTIVATION_EVENT_TYPES.forEach(function (type) {\n                    _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);\n                });\n                this.adapter_.registerInteractionHandler('focus', this.focusHandler_);\n                this.adapter_.registerInteractionHandler('blur', this.blurHandler_);\n                if (this.adapter_.isUnbounded()) {\n                    this.adapter_.registerResizeHandler(this.resizeHandler_);\n                }\n            }\n            /**\n             * @param {!Event} e\n             * @private\n             */\n        }, {\n            key: \"registerDeactivationHandlers_\",\n            value: function registerDeactivationHandlers_(e) {\n                var _this5 = this;\n                if (e.type === 'keydown') {\n                    this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);\n                }\n                else {\n                    POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {\n                        _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);\n                    });\n                }\n            }\n            /** @private */\n        }, {\n            key: \"deregisterRootHandlers_\",\n            value: function deregisterRootHandlers_() {\n                var _this6 = this;\n                ACTIVATION_EVENT_TYPES.forEach(function (type) {\n                    _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);\n                });\n                this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);\n                this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);\n                if (this.adapter_.isUnbounded()) {\n                    this.adapter_.deregisterResizeHandler(this.resizeHandler_);\n                }\n            }\n            /** @private */\n        }, {\n            key: \"deregisterDeactivationHandlers_\",\n            value: function deregisterDeactivationHandlers_() {\n                var _this7 = this;\n                this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);\n                POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {\n                    _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);\n                });\n            }\n            /** @private */\n        }, {\n            key: \"removeCssVars_\",\n            value: function removeCssVars_() {\n                var _this8 = this;\n                var strings$$1 = MDCRippleFoundation.strings;\n                Object.keys(strings$$1).forEach(function (k) {\n                    if (k.indexOf('VAR_') === 0) {\n                        _this8.adapter_.updateCssVariable(strings$$1[k], null);\n                    }\n                });\n            }\n            /**\n             * @param {?Event} e\n             * @private\n             */\n        }, {\n            key: \"activate_\",\n            value: function activate_(e) {\n                var _this9 = this;\n                if (this.adapter_.isSurfaceDisabled()) {\n                    return;\n                }\n                var activationState = this.activationState_;\n                if (activationState.isActivated) {\n                    return;\n                } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction\n                var previousActivationEvent = this.previousActivationEvent_;\n                var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;\n                if (isSameInteraction) {\n                    return;\n                }\n                activationState.isActivated = true;\n                activationState.isProgrammatic = e === null;\n                activationState.activationEvent = e;\n                activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';\n                var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {\n                    return _this9.adapter_.containsEventTarget(target);\n                });\n                if (hasActivatedChild) {\n                    // Immediately reset activation state, while preserving logic that prevents touch follow-on events\n                    this.resetActivationState_();\n                    return;\n                }\n                if (e) {\n                    activatedTargets.push(\n                    /** @type {!EventTarget} */\n                    e.target);\n                    this.registerDeactivationHandlers_(e);\n                }\n                activationState.wasElementMadeActive = this.checkElementMadeActive_(e);\n                if (activationState.wasElementMadeActive) {\n                    this.animateActivation_();\n                }\n                requestAnimationFrame(function () {\n                    // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples\n                    activatedTargets = [];\n                    if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {\n                        // If space was pressed, try again within an rAF call to detect :active, because different UAs report\n                        // active states inconsistently when they're called within event handling code:\n                        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971\n                        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741\n                        // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS\n                        // variable is set within a rAF callback for a submit button interaction (#2241).\n                        activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);\n                        if (activationState.wasElementMadeActive) {\n                            _this9.animateActivation_();\n                        }\n                    }\n                    if (!activationState.wasElementMadeActive) {\n                        // Reset activation state immediately if element was not made active.\n                        _this9.activationState_ = _this9.defaultActivationState_();\n                    }\n                });\n            }\n            /**\n             * @param {?Event} e\n             * @private\n             */\n        }, {\n            key: \"checkElementMadeActive_\",\n            value: function checkElementMadeActive_(e) {\n                return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;\n            }\n            /**\n             * @param {?Event=} event Optional event containing position information.\n             */\n        }, {\n            key: \"activate\",\n            value: function activate() {\n                var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n                this.activate_(event);\n            }\n            /** @private */\n        }, {\n            key: \"animateActivation_\",\n            value: function animateActivation_() {\n                var _this10 = this;\n                var _MDCRippleFoundation$3 = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;\n                var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION, FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;\n                var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;\n                this.layoutInternal_();\n                var translateStart = '';\n                var translateEnd = '';\n                if (!this.adapter_.isUnbounded()) {\n                    var _getFgTranslationCoor = this.getFgTranslationCoordinates_(), startPoint = _getFgTranslationCoor.startPoint, endPoint = _getFgTranslationCoor.endPoint;\n                    translateStart = \"\".concat(startPoint.x, \"px, \").concat(startPoint.y, \"px\");\n                    translateEnd = \"\".concat(endPoint.x, \"px, \").concat(endPoint.y, \"px\");\n                }\n                this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);\n                this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations\n                clearTimeout(this.activationTimer_);\n                clearTimeout(this.fgDeactivationRemovalTimer_);\n                this.rmBoundedActivationClasses_();\n                this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.\n                this.adapter_.computeBoundingRect();\n                this.adapter_.addClass(FG_ACTIVATION);\n                this.activationTimer_ = setTimeout(function () {\n                    return _this10.activationTimerCallback_();\n                }, DEACTIVATION_TIMEOUT_MS);\n            }\n            /**\n             * @private\n             * @return {{startPoint: PointType, endPoint: PointType}}\n             */\n        }, {\n            key: \"getFgTranslationCoordinates_\",\n            value: function getFgTranslationCoordinates_() {\n                var _activationState_ = this.activationState_, activationEvent = _activationState_.activationEvent, wasActivatedByPointer = _activationState_.wasActivatedByPointer;\n                var startPoint;\n                if (wasActivatedByPointer) {\n                    startPoint = getNormalizedEventCoords(\n                    /** @type {!Event} */\n                    activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());\n                }\n                else {\n                    startPoint = {\n                        x: this.frame_.width / 2,\n                        y: this.frame_.height / 2\n                    };\n                } // Center the element around the start point.\n                startPoint = {\n                    x: startPoint.x - this.initialSize_ / 2,\n                    y: startPoint.y - this.initialSize_ / 2\n                };\n                var endPoint = {\n                    x: this.frame_.width / 2 - this.initialSize_ / 2,\n                    y: this.frame_.height / 2 - this.initialSize_ / 2\n                };\n                return {\n                    startPoint: startPoint,\n                    endPoint: endPoint\n                };\n            }\n            /** @private */\n        }, {\n            key: \"runDeactivationUXLogicIfReady_\",\n            value: function runDeactivationUXLogicIfReady_() {\n                var _this11 = this;\n                // This method is called both when a pointing device is released, and when the activation animation ends.\n                // The deactivation animation should only run after both of those occur.\n                var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;\n                var _activationState_2 = this.activationState_, hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun, isActivated = _activationState_2.isActivated;\n                var activationHasEnded = hasDeactivationUXRun || !isActivated;\n                if (activationHasEnded && this.activationAnimationHasEnded_) {\n                    this.rmBoundedActivationClasses_();\n                    this.adapter_.addClass(FG_DEACTIVATION);\n                    this.fgDeactivationRemovalTimer_ = setTimeout(function () {\n                        _this11.adapter_.removeClass(FG_DEACTIVATION);\n                    }, numbers.FG_DEACTIVATION_MS);\n                }\n            }\n            /** @private */\n        }, {\n            key: \"rmBoundedActivationClasses_\",\n            value: function rmBoundedActivationClasses_() {\n                var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;\n                this.adapter_.removeClass(FG_ACTIVATION);\n                this.activationAnimationHasEnded_ = false;\n                this.adapter_.computeBoundingRect();\n            }\n        }, {\n            key: \"resetActivationState_\",\n            value: function resetActivationState_() {\n                var _this12 = this;\n                this.previousActivationEvent_ = this.activationState_.activationEvent;\n                this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.\n                // Store the previous event until it's safe to assume that subsequent events are for new interactions.\n                setTimeout(function () {\n                    return _this12.previousActivationEvent_ = null;\n                }, MDCRippleFoundation.numbers.TAP_DELAY_MS);\n            }\n            /**\n             * @param {?Event} e\n             * @private\n             */\n        }, {\n            key: \"deactivate_\",\n            value: function deactivate_(e) {\n                var _this13 = this;\n                var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.\n                if (!activationState.isActivated) {\n                    return;\n                }\n                var state = \n                /** @type {!ActivationStateType} */\n                Object.assign({}, activationState);\n                if (activationState.isProgrammatic) {\n                    var evtObject = null;\n                    requestAnimationFrame(function () {\n                        return _this13.animateDeactivation_(evtObject, state);\n                    });\n                    this.resetActivationState_();\n                }\n                else {\n                    this.deregisterDeactivationHandlers_();\n                    requestAnimationFrame(function () {\n                        _this13.activationState_.hasDeactivationUXRun = true;\n                        _this13.animateDeactivation_(e, state);\n                        _this13.resetActivationState_();\n                    });\n                }\n            }\n            /**\n             * @param {?Event=} event Optional event containing position information.\n             */\n        }, {\n            key: \"deactivate\",\n            value: function deactivate() {\n                var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n                this.deactivate_(event);\n            }\n            /**\n             * @param {Event} e\n             * @param {!ActivationStateType} options\n             * @private\n             */\n        }, {\n            key: \"animateDeactivation_\",\n            value: function animateDeactivation_(e, _ref) {\n                var wasActivatedByPointer = _ref.wasActivatedByPointer, wasElementMadeActive = _ref.wasElementMadeActive;\n                if (wasActivatedByPointer || wasElementMadeActive) {\n                    this.runDeactivationUXLogicIfReady_();\n                }\n            }\n        }, {\n            key: \"layout\",\n            value: function layout() {\n                var _this14 = this;\n                if (this.layoutFrame_) {\n                    cancelAnimationFrame(this.layoutFrame_);\n                }\n                this.layoutFrame_ = requestAnimationFrame(function () {\n                    _this14.layoutInternal_();\n                    _this14.layoutFrame_ = 0;\n                });\n            }\n            /** @private */\n        }, {\n            key: \"layoutInternal_\",\n            value: function layoutInternal_() {\n                var _this15 = this;\n                this.frame_ = this.adapter_.computeBoundingRect();\n                var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.\n                // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately\n                // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically\n                // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter\n                // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via\n                // `overflow: hidden`.\n                var getBoundedRadius = function getBoundedRadius() {\n                    var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));\n                    return hypotenuse + MDCRippleFoundation.numbers.PADDING;\n                };\n                this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform\n                this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;\n                this.fgScale_ = this.maxRadius_ / this.initialSize_;\n                this.updateLayoutCssVars_();\n            }\n            /** @private */\n        }, {\n            key: \"updateLayoutCssVars_\",\n            value: function updateLayoutCssVars_() {\n                var _MDCRippleFoundation$5 = MDCRippleFoundation.strings, VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE, VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT, VAR_TOP = _MDCRippleFoundation$5.VAR_TOP, VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;\n                this.adapter_.updateCssVariable(VAR_FG_SIZE, \"\".concat(this.initialSize_, \"px\"));\n                this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);\n                if (this.adapter_.isUnbounded()) {\n                    this.unboundedCoords_ = {\n                        left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),\n                        top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)\n                    };\n                    this.adapter_.updateCssVariable(VAR_LEFT, \"\".concat(this.unboundedCoords_.left, \"px\"));\n                    this.adapter_.updateCssVariable(VAR_TOP, \"\".concat(this.unboundedCoords_.top, \"px\"));\n                }\n            }\n            /** @param {boolean} unbounded */\n        }, {\n            key: \"setUnbounded\",\n            value: function setUnbounded(unbounded) {\n                var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;\n                if (unbounded) {\n                    this.adapter_.addClass(UNBOUNDED);\n                }\n                else {\n                    this.adapter_.removeClass(UNBOUNDED);\n                }\n            }\n        }]);\n    return MDCRippleFoundation;\n}(MDCFoundation);\n/**\n * @extends MDCComponent<!MDCRippleFoundation>\n */\nvar MDCRipple = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCRipple, _MDCComponent);\n    /** @param {...?} args */\n    function MDCRipple() {\n        var _ref;\n        var _this;\n        _classCallCheck(this, MDCRipple);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));\n        /** @type {boolean} */\n        _this.disabled = false;\n        /** @private {boolean} */\n        _this.unbounded_;\n        return _this;\n    }\n    /**\n     * @param {!Element} root\n     * @param {{isUnbounded: (boolean|undefined)}=} options\n     * @return {!MDCRipple}\n     */\n    _createClass(MDCRipple, [{\n            key: \"setUnbounded_\",\n            /**\n             * Closure Compiler throws an access control error when directly accessing a\n             * protected or private property inside a getter/setter, like unbounded above.\n             * By accessing the protected property inside a method, we solve that problem.\n             * That's why this function exists.\n             * @private\n             */\n            value: function setUnbounded_() {\n                this.foundation_.setUnbounded(this.unbounded_);\n            }\n        }, {\n            key: \"activate\",\n            value: function activate() {\n                this.foundation_.activate();\n            }\n        }, {\n            key: \"deactivate\",\n            value: function deactivate() {\n                this.foundation_.deactivate();\n            }\n        }, {\n            key: \"layout\",\n            value: function layout() {\n                this.foundation_.layout();\n            }\n            /** @return {!MDCRippleFoundation} */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                return new MDCRippleFoundation(MDCRipple.createAdapter(this));\n            }\n        }, {\n            key: \"initialSyncWithDOM\",\n            value: function initialSyncWithDOM() {\n                this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;\n            }\n        }, {\n            key: \"unbounded\",\n            /** @return {boolean} */\n            get: function get() {\n                return this.unbounded_;\n            }\n            /** @param {boolean} unbounded */\n            ,\n            set: function set(unbounded) {\n                this.unbounded_ = Boolean(unbounded);\n                this.setUnbounded_();\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref2$isUnbounded = _ref2.isUnbounded, isUnbounded = _ref2$isUnbounded === void 0 ? undefined : _ref2$isUnbounded;\n                var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified\n                if (isUnbounded !== undefined) {\n                    ripple.unbounded =\n                        /** @type {boolean} */\n                        isUnbounded;\n                }\n                return ripple;\n            }\n            /**\n             * @param {!RippleCapableSurface} instance\n             * @return {!MDCRippleAdapter}\n             */\n        }, {\n            key: \"createAdapter\",\n            value: function createAdapter(instance) {\n                var MATCHES = getMatchesProperty(HTMLElement.prototype);\n                return {\n                    browserSupportsCssVars: function browserSupportsCssVars() {\n                        return supportsCssVariables(window);\n                    },\n                    isUnbounded: function isUnbounded() {\n                        return instance.unbounded;\n                    },\n                    isSurfaceActive: function isSurfaceActive() {\n                        return instance.root_[MATCHES](':active');\n                    },\n                    isSurfaceDisabled: function isSurfaceDisabled() {\n                        return instance.disabled;\n                    },\n                    addClass: function addClass(className) {\n                        return instance.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return instance.root_.classList.remove(className);\n                    },\n                    containsEventTarget: function containsEventTarget(target) {\n                        return instance.root_.contains(target);\n                    },\n                    registerInteractionHandler: function registerInteractionHandler(evtType, handler) {\n                        return instance.root_.addEventListener(evtType, handler, applyPassive());\n                    },\n                    deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {\n                        return instance.root_.removeEventListener(evtType, handler, applyPassive());\n                    },\n                    registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {\n                        return document.documentElement.addEventListener(evtType, handler, applyPassive());\n                    },\n                    deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {\n                        return document.documentElement.removeEventListener(evtType, handler, applyPassive());\n                    },\n                    registerResizeHandler: function registerResizeHandler(handler) {\n                        return window.addEventListener('resize', handler);\n                    },\n                    deregisterResizeHandler: function deregisterResizeHandler(handler) {\n                        return window.removeEventListener('resize', handler);\n                    },\n                    updateCssVariable: function updateCssVariable(varName, value) {\n                        return instance.root_.style.setProperty(varName, value);\n                    },\n                    computeBoundingRect: function computeBoundingRect() {\n                        return instance.root_.getBoundingClientRect();\n                    },\n                    getWindowPageOffset: function getWindowPageOffset() {\n                        return {\n                            x: window.pageXOffset,\n                            y: window.pageYOffset\n                        };\n                    }\n                };\n            }\n        }]);\n    return MDCRipple;\n}(MDCComponent);\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar cssClasses$1 = {\n    ACTIVE: 'mdc-tab--active'\n};\nvar strings$1 = {\n    SELECTED_EVENT: 'MDCTab:selected'\n};\nvar MDCTabFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCTabFoundation, _MDCFoundation);\n    _createClass(MDCTabFoundation, null, [{\n            key: \"cssClasses\",\n            get: function get() {\n                return cssClasses$1;\n            }\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings$1;\n            }\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    registerInteractionHandler: function registerInteractionHandler() { },\n                    deregisterInteractionHandler: function deregisterInteractionHandler() { },\n                    getOffsetWidth: function getOffsetWidth() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    getOffsetLeft: function getOffsetLeft() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    notifySelected: function notifySelected() { }\n                };\n            }\n        }]);\n    function MDCTabFoundation() {\n        var _this;\n        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, MDCTabFoundation);\n        _this = _possibleConstructorReturn(this, (MDCTabFoundation.__proto__ || Object.getPrototypeOf(MDCTabFoundation)).call(this, Object.assign(MDCTabFoundation.defaultAdapter, adapter)));\n        _this.computedWidth_ = 0;\n        _this.computedLeft_ = 0;\n        _this.isActive_ = false;\n        _this.preventDefaultOnClick_ = false;\n        _this.clickHandler_ = function (evt) {\n            if (_this.preventDefaultOnClick_) {\n                evt.preventDefault();\n            }\n            _this.adapter_.notifySelected();\n        };\n        _this.keydownHandler_ = function (evt) {\n            if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {\n                _this.adapter_.notifySelected();\n            }\n        };\n        return _this;\n    }\n    _createClass(MDCTabFoundation, [{\n            key: \"init\",\n            value: function init() {\n                this.adapter_.registerInteractionHandler('click', this.clickHandler_);\n                this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);\n                this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);\n            }\n        }, {\n            key: \"getComputedWidth\",\n            value: function getComputedWidth() {\n                return this.computedWidth_;\n            }\n        }, {\n            key: \"getComputedLeft\",\n            value: function getComputedLeft() {\n                return this.computedLeft_;\n            }\n        }, {\n            key: \"isActive\",\n            value: function isActive() {\n                return this.isActive_;\n            }\n        }, {\n            key: \"setActive\",\n            value: function setActive(isActive) {\n                this.isActive_ = isActive;\n                if (this.isActive_) {\n                    this.adapter_.addClass(cssClasses$1.ACTIVE);\n                }\n                else {\n                    this.adapter_.removeClass(cssClasses$1.ACTIVE);\n                }\n            }\n        }, {\n            key: \"preventsDefaultOnClick\",\n            value: function preventsDefaultOnClick() {\n                return this.preventDefaultOnClick_;\n            }\n        }, {\n            key: \"setPreventDefaultOnClick\",\n            value: function setPreventDefaultOnClick(preventDefaultOnClick) {\n                this.preventDefaultOnClick_ = preventDefaultOnClick;\n            }\n        }, {\n            key: \"measureSelf\",\n            value: function measureSelf() {\n                this.computedWidth_ = this.adapter_.getOffsetWidth();\n                this.computedLeft_ = this.adapter_.getOffsetLeft();\n            }\n        }]);\n    return MDCTabFoundation;\n}(MDCFoundation);\nvar MDCTab = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCTab, _MDCComponent);\n    _createClass(MDCTab, [{\n            key: \"computedWidth\",\n            get: function get$$1() {\n                return this.foundation_.getComputedWidth();\n            }\n        }, {\n            key: \"computedLeft\",\n            get: function get$$1() {\n                return this.foundation_.getComputedLeft();\n            }\n        }, {\n            key: \"isActive\",\n            get: function get$$1() {\n                return this.foundation_.isActive();\n            },\n            set: function set(isActive) {\n                this.foundation_.setActive(isActive);\n            }\n        }, {\n            key: \"preventDefaultOnClick\",\n            get: function get$$1() {\n                return this.foundation_.preventsDefaultOnClick();\n            },\n            set: function set(preventDefaultOnClick) {\n                this.foundation_.setPreventDefaultOnClick(preventDefaultOnClick);\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                return new MDCTab(root);\n            }\n        }]);\n    function MDCTab() {\n        var _ref;\n        var _this;\n        _classCallCheck(this, MDCTab);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _possibleConstructorReturn(this, (_ref = MDCTab.__proto__ || Object.getPrototypeOf(MDCTab)).call.apply(_ref, [this].concat(args)));\n        _this.ripple_ = MDCRipple.attachTo(_this.root_);\n        return _this;\n    }\n    _createClass(MDCTab, [{\n            key: \"destroy\",\n            value: function destroy() {\n                this.ripple_.destroy();\n                _get(MDCTab.prototype.__proto__ || Object.getPrototypeOf(MDCTab.prototype), \"destroy\", this).call(this);\n            }\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this2 = this;\n                return new MDCTabFoundation({\n                    addClass: function addClass(className) {\n                        return _this2.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this2.root_.classList.remove(className);\n                    },\n                    registerInteractionHandler: function registerInteractionHandler(type, handler) {\n                        return _this2.root_.addEventListener(type, handler);\n                    },\n                    deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {\n                        return _this2.root_.removeEventListener(type, handler);\n                    },\n                    getOffsetWidth: function getOffsetWidth() {\n                        return _this2.root_.offsetWidth;\n                    },\n                    getOffsetLeft: function getOffsetLeft() {\n                        return _this2.root_.offsetLeft;\n                    },\n                    notifySelected: function notifySelected() {\n                        return _this2.emit(MDCTabFoundation.strings.SELECTED_EVENT, {\n                            tab: _this2\n                        }, true);\n                    }\n                });\n            }\n        }, {\n            key: \"initialSyncWithDOM\",\n            value: function initialSyncWithDOM() {\n                this.isActive = this.root_.classList.contains(cssClasses$1.ACTIVE);\n            }\n        }, {\n            key: \"measureSelf\",\n            value: function measureSelf() {\n                this.foundation_.measureSelf();\n            }\n        }]);\n    return MDCTab;\n}(MDCComponent);\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @const {Object<string, !VendorPropertyMapType>} */\nvar eventTypeMap = {\n    'animationstart': {\n        noPrefix: 'animationstart',\n        webkitPrefix: 'webkitAnimationStart',\n        styleProperty: 'animation'\n    },\n    'animationend': {\n        noPrefix: 'animationend',\n        webkitPrefix: 'webkitAnimationEnd',\n        styleProperty: 'animation'\n    },\n    'animationiteration': {\n        noPrefix: 'animationiteration',\n        webkitPrefix: 'webkitAnimationIteration',\n        styleProperty: 'animation'\n    },\n    'transitionend': {\n        noPrefix: 'transitionend',\n        webkitPrefix: 'webkitTransitionEnd',\n        styleProperty: 'transition'\n    }\n};\n/** @const {Object<string, !VendorPropertyMapType>} */\nvar cssPropertyMap = {\n    'animation': {\n        noPrefix: 'animation',\n        webkitPrefix: '-webkit-animation'\n    },\n    'transform': {\n        noPrefix: 'transform',\n        webkitPrefix: '-webkit-transform'\n    },\n    'transition': {\n        noPrefix: 'transition',\n        webkitPrefix: '-webkit-transition'\n    }\n};\n/**\n * @param {!Object} windowObj\n * @return {boolean}\n */\nfunction hasProperShape(windowObj) {\n    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';\n}\n/**\n * @param {string} eventType\n * @return {boolean}\n */\nfunction eventFoundInMaps(eventType) {\n    return eventType in eventTypeMap || eventType in cssPropertyMap;\n}\n/**\n * @param {string} eventType\n * @param {!Object<string, !VendorPropertyMapType>} map\n * @param {!Element} el\n * @return {string}\n */\nfunction getJavaScriptEventName(eventType, map, el) {\n    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;\n}\n/**\n * Helper function to determine browser prefix for CSS3 animation events\n * and property names.\n * @param {!Object} windowObj\n * @param {string} eventType\n * @return {string}\n */\nfunction getAnimationName(windowObj, eventType) {\n    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {\n        return eventType;\n    }\n    var map = \n    /** @type {!Object<string, !VendorPropertyMapType>} */\n    eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;\n    var el = windowObj['document']['createElement']('div');\n    var eventName = '';\n    if (map === eventTypeMap) {\n        eventName = getJavaScriptEventName(eventType, map, el);\n    }\n    else {\n        eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;\n    }\n    return eventName;\n} // Public functions to access getAnimationName() for JavaScript events or CSS\n/**\n * @param {!Object} windowObj\n * @param {string} eventType\n * @return {string}\n */\nfunction getCorrectPropertyName(windowObj, eventType) {\n    return getAnimationName(windowObj, eventType);\n}\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar cssClasses$2 = {\n    UPGRADED: 'mdc-tab-bar-upgraded'\n};\nvar strings$2 = {\n    TAB_SELECTOR: '.mdc-tab',\n    INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',\n    CHANGE_EVENT: 'MDCTabBar:change'\n};\nvar MDCTabBarFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCTabBarFoundation, _MDCFoundation);\n    _createClass(MDCTabBarFoundation, null, [{\n            key: \"cssClasses\",\n            get: function get() {\n                return cssClasses$2;\n            }\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings$2;\n            }\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() { },\n                    unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() { },\n                    registerResizeHandler: function registerResizeHandler() { },\n                    deregisterResizeHandler: function deregisterResizeHandler() { },\n                    getOffsetWidth: function getOffsetWidth() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    setStyleForIndicator: function setStyleForIndicator() { },\n                    getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    notifyChange: function notifyChange() { },\n                    getNumberOfTabs: function getNumberOfTabs() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    isTabActiveAtIndex: function isTabActiveAtIndex() {\n                        return (\n                        /* index: number */\n                        /* boolean */\n                        false);\n                    },\n                    setTabActiveAtIndex: function setTabActiveAtIndex() { },\n                    isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {\n                        return (\n                        /* index: number */\n                        /* boolean */\n                        false);\n                    },\n                    setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex() { },\n                    measureTabAtIndex: function measureTabAtIndex() { },\n                    getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {\n                        return (\n                        /* index: number */\n                        /* number */\n                        0);\n                    },\n                    getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {\n                        return (\n                        /* index: number */\n                        /* number */\n                        0);\n                    }\n                };\n            }\n        }]);\n    function MDCTabBarFoundation(adapter) {\n        var _this;\n        _classCallCheck(this, MDCTabBarFoundation);\n        _this = _possibleConstructorReturn(this, (MDCTabBarFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarFoundation)).call(this, Object.assign(MDCTabBarFoundation.defaultAdapter, adapter)));\n        _this.isIndicatorShown_ = false;\n        _this.computedWidth_ = 0;\n        _this.computedLeft_ = 0;\n        _this.activeTabIndex_ = 0;\n        _this.layoutFrame_ = 0;\n        _this.resizeHandler_ = function () {\n            return _this.layout();\n        };\n        return _this;\n    }\n    _createClass(MDCTabBarFoundation, [{\n            key: \"init\",\n            value: function init() {\n                this.adapter_.addClass(cssClasses$2.UPGRADED);\n                this.adapter_.bindOnMDCTabSelectedEvent();\n                this.adapter_.registerResizeHandler(this.resizeHandler_);\n                var activeTabIndex = this.findActiveTabIndex_();\n                if (activeTabIndex >= 0) {\n                    this.activeTabIndex_ = activeTabIndex;\n                }\n                this.layout();\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                this.adapter_.removeClass(cssClasses$2.UPGRADED);\n                this.adapter_.unbindOnMDCTabSelectedEvent();\n                this.adapter_.deregisterResizeHandler(this.resizeHandler_);\n            }\n        }, {\n            key: \"layoutInternal_\",\n            value: function layoutInternal_() {\n                var _this2 = this;\n                this.forEachTabIndex_(function (index) {\n                    return _this2.adapter_.measureTabAtIndex(index);\n                });\n                this.computedWidth_ = this.adapter_.getOffsetWidth();\n                this.layoutIndicator_();\n            }\n        }, {\n            key: \"layoutIndicator_\",\n            value: function layoutIndicator_() {\n                var isIndicatorFirstRender = !this.isIndicatorShown_; // Ensure that indicator appears in the right position immediately for correct first render.\n                if (isIndicatorFirstRender) {\n                    this.adapter_.setStyleForIndicator('transition', 'none');\n                }\n                var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);\n                var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();\n                var transformValue = \"translateX(\".concat(translateAmtForActiveTabLeft, \"px) scale(\").concat(scaleAmtForActiveTabWidth, \", 1)\");\n                this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);\n                if (isIndicatorFirstRender) {\n                    // Force layout so that transform styles to take effect.\n                    this.adapter_.getOffsetWidthForIndicator();\n                    this.adapter_.setStyleForIndicator('transition', '');\n                    this.adapter_.setStyleForIndicator('visibility', 'visible');\n                    this.isIndicatorShown_ = true;\n                }\n            }\n        }, {\n            key: \"findActiveTabIndex_\",\n            value: function findActiveTabIndex_() {\n                var _this3 = this;\n                var activeTabIndex = -1;\n                this.forEachTabIndex_(function (index) {\n                    if (_this3.adapter_.isTabActiveAtIndex(index)) {\n                        activeTabIndex = index;\n                        return true;\n                    }\n                });\n                return activeTabIndex;\n            }\n        }, {\n            key: \"forEachTabIndex_\",\n            value: function forEachTabIndex_(iterator) {\n                var numTabs = this.adapter_.getNumberOfTabs();\n                for (var index = 0; index < numTabs; index++) {\n                    var shouldBreak = iterator(index);\n                    if (shouldBreak) {\n                        break;\n                    }\n                }\n            }\n        }, {\n            key: \"layout\",\n            value: function layout() {\n                var _this4 = this;\n                if (this.layoutFrame_) {\n                    cancelAnimationFrame(this.layoutFrame_);\n                }\n                this.layoutFrame_ = requestAnimationFrame(function () {\n                    _this4.layoutInternal_();\n                    _this4.layoutFrame_ = 0;\n                });\n            }\n        }, {\n            key: \"switchToTabAtIndex\",\n            value: function switchToTabAtIndex(index, shouldNotify) {\n                var _this5 = this;\n                if (index === this.activeTabIndex_) {\n                    return;\n                }\n                if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {\n                    throw new Error(\"Out of bounds index specified for tab: \".concat(index));\n                }\n                var prevActiveTabIndex = this.activeTabIndex_;\n                this.activeTabIndex_ = index;\n                requestAnimationFrame(function () {\n                    if (prevActiveTabIndex >= 0) {\n                        _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);\n                    }\n                    _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);\n                    _this5.layoutIndicator_();\n                    if (shouldNotify) {\n                        _this5.adapter_.notifyChange({\n                            activeTabIndex: _this5.activeTabIndex_\n                        });\n                    }\n                });\n            }\n        }, {\n            key: \"getActiveTabIndex\",\n            value: function getActiveTabIndex() {\n                return this.findActiveTabIndex_();\n            }\n        }]);\n    return MDCTabBarFoundation;\n}(MDCFoundation);\nvar MDCTabBar = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCTabBar, _MDCComponent);\n    function MDCTabBar() {\n        _classCallCheck(this, MDCTabBar);\n        return _possibleConstructorReturn(this, (MDCTabBar.__proto__ || Object.getPrototypeOf(MDCTabBar)).apply(this, arguments));\n    }\n    _createClass(MDCTabBar, [{\n            key: \"initialize\",\n            value: function initialize() {\n                var _this = this;\n                var tabFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {\n                    return new MDCTab(el);\n                };\n                this.indicator_ = this.root_.querySelector(MDCTabBarFoundation.strings.INDICATOR_SELECTOR);\n                this.tabs_ = this.gatherTabs_(tabFactory);\n                this.tabSelectedHandler_ = function (_ref) {\n                    var detail = _ref.detail;\n                    var tab = detail.tab;\n                    _this.setActiveTab_(tab, true);\n                };\n            }\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this2 = this;\n                return new MDCTabBarFoundation({\n                    addClass: function addClass(className) {\n                        return _this2.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this2.root_.classList.remove(className);\n                    },\n                    bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {\n                        return _this2.listen(MDCTabFoundation.strings.SELECTED_EVENT, _this2.tabSelectedHandler_);\n                    },\n                    unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {\n                        return _this2.unlisten(MDCTabFoundation.strings.SELECTED_EVENT, _this2.tabSelectedHandler_);\n                    },\n                    registerResizeHandler: function registerResizeHandler(handler) {\n                        return window.addEventListener('resize', handler);\n                    },\n                    deregisterResizeHandler: function deregisterResizeHandler(handler) {\n                        return window.removeEventListener('resize', handler);\n                    },\n                    getOffsetWidth: function getOffsetWidth() {\n                        return _this2.root_.offsetWidth;\n                    },\n                    setStyleForIndicator: function setStyleForIndicator(propertyName, value) {\n                        return _this2.indicator_.style.setProperty(propertyName, value);\n                    },\n                    getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {\n                        return _this2.indicator_.offsetWidth;\n                    },\n                    notifyChange: function notifyChange(evtData) {\n                        return _this2.emit(MDCTabBarFoundation.strings.CHANGE_EVENT, evtData);\n                    },\n                    getNumberOfTabs: function getNumberOfTabs() {\n                        return _this2.tabs.length;\n                    },\n                    isTabActiveAtIndex: function isTabActiveAtIndex(index) {\n                        return _this2.tabs[index].isActive;\n                    },\n                    setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {\n                        _this2.tabs[index].isActive = isActive;\n                    },\n                    isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {\n                        return _this2.tabs[index].preventDefaultOnClick;\n                    },\n                    setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {\n                        _this2.tabs[index].preventDefaultOnClick = preventDefaultOnClick;\n                    },\n                    measureTabAtIndex: function measureTabAtIndex(index) {\n                        return _this2.tabs[index].measureSelf();\n                    },\n                    getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {\n                        return _this2.tabs[index].computedWidth;\n                    },\n                    getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {\n                        return _this2.tabs[index].computedLeft;\n                    }\n                });\n            }\n        }, {\n            key: \"gatherTabs_\",\n            value: function gatherTabs_(tabFactory) {\n                var tabElements = [].slice.call(this.root_.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));\n                return tabElements.map(function (el) {\n                    return tabFactory(el);\n                });\n            }\n        }, {\n            key: \"setActiveTabIndex_\",\n            value: function setActiveTabIndex_(activeTabIndex, notifyChange) {\n                this.foundation_.switchToTabAtIndex(activeTabIndex, notifyChange);\n            }\n        }, {\n            key: \"layout\",\n            value: function layout() {\n                this.foundation_.layout();\n            }\n        }, {\n            key: \"setActiveTab_\",\n            value: function setActiveTab_(activeTab, notifyChange) {\n                var indexOfTab = this.tabs.indexOf(activeTab);\n                if (indexOfTab < 0) {\n                    throw new Error('Invalid tab component given as activeTab: Tab not found within this component\\'s tab list');\n                }\n                this.setActiveTabIndex_(indexOfTab, notifyChange);\n            }\n        }, {\n            key: \"tabs\",\n            get: function get() {\n                return this.tabs_;\n            }\n        }, {\n            key: \"activeTab\",\n            get: function get() {\n                var activeIndex = this.foundation_.getActiveTabIndex();\n                return this.tabs[activeIndex];\n            },\n            set: function set(tab) {\n                this.setActiveTab_(tab, false);\n            }\n        }, {\n            key: \"activeTabIndex\",\n            get: function get() {\n                return this.foundation_.getActiveTabIndex();\n            },\n            set: function set(index) {\n                this.setActiveTabIndex_(index, false);\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                return new MDCTabBar(root);\n            }\n        }]);\n    return MDCTabBar;\n}(MDCComponent);\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar cssClasses$3 = {\n    INDICATOR_FORWARD: 'mdc-tab-bar-scroller__indicator--forward',\n    INDICATOR_BACK: 'mdc-tab-bar-scroller__indicator--back',\n    INDICATOR_ENABLED: 'mdc-tab-bar-scroller__indicator--enabled',\n    TAB: 'mdc-tab'\n};\nvar strings$3 = {\n    FRAME_SELECTOR: '.mdc-tab-bar-scroller__scroll-frame',\n    TABS_SELECTOR: '.mdc-tab-bar-scroller__scroll-frame__tabs',\n    TAB_SELECTOR: '.mdc-tab',\n    INDICATOR_FORWARD_SELECTOR: '.mdc-tab-bar-scroller__indicator--forward',\n    INDICATOR_BACK_SELECTOR: '.mdc-tab-bar-scroller__indicator--back'\n};\nvar MDCTabBarScrollerFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCTabBarScrollerFoundation, _MDCFoundation);\n    _createClass(MDCTabBarScrollerFoundation, null, [{\n            key: \"cssClasses\",\n            get: function get() {\n                return cssClasses$3;\n            }\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings$3;\n            }\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    eventTargetHasClass: function eventTargetHasClass() {\n                        return (\n                        /* target: EventTarget, className: string */\n                        /* boolean */\n                        false);\n                    },\n                    addClassToForwardIndicator: function addClassToForwardIndicator() { },\n                    removeClassFromForwardIndicator: function removeClassFromForwardIndicator() { },\n                    addClassToBackIndicator: function addClassToBackIndicator() { },\n                    removeClassFromBackIndicator: function removeClassFromBackIndicator() { },\n                    isRTL: function isRTL() {\n                        return (\n                        /* boolean */\n                        false);\n                    },\n                    registerBackIndicatorClickHandler: function registerBackIndicatorClickHandler() { },\n                    deregisterBackIndicatorClickHandler: function deregisterBackIndicatorClickHandler() { },\n                    registerForwardIndicatorClickHandler: function registerForwardIndicatorClickHandler() { },\n                    deregisterForwardIndicatorClickHandler: function deregisterForwardIndicatorClickHandler() { },\n                    registerCapturedInteractionHandler: function registerCapturedInteractionHandler() { },\n                    deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler() { },\n                    registerWindowResizeHandler: function registerWindowResizeHandler() { },\n                    deregisterWindowResizeHandler: function deregisterWindowResizeHandler() { },\n                    getNumberOfTabs: function getNumberOfTabs() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    getOffsetWidthForScrollFrame: function getOffsetWidthForScrollFrame() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    getScrollLeftForScrollFrame: function getScrollLeftForScrollFrame() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    setScrollLeftForScrollFrame: function setScrollLeftForScrollFrame() { },\n                    getOffsetWidthForTabBar: function getOffsetWidthForTabBar() {\n                        return (\n                        /* number */\n                        0);\n                    },\n                    setTransformStyleForTabBar: function setTransformStyleForTabBar() { },\n                    getOffsetLeftForEventTarget: function getOffsetLeftForEventTarget() {\n                        return (\n                        /* target: EventTarget */\n                        /* number */\n                        0);\n                    },\n                    getOffsetWidthForEventTarget: function getOffsetWidthForEventTarget() {\n                        return (\n                        /* target: EventTarget */\n                        /* number */\n                        0);\n                    }\n                };\n            }\n        }]);\n    function MDCTabBarScrollerFoundation(adapter) {\n        var _this;\n        _classCallCheck(this, MDCTabBarScrollerFoundation);\n        _this = _possibleConstructorReturn(this, (MDCTabBarScrollerFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarScrollerFoundation)).call(this, Object.assign(MDCTabBarScrollerFoundation.defaultAdapter, adapter)));\n        _this.pointerDownRecognized_ = false;\n        _this.currentTranslateOffset_ = 0;\n        _this.focusedTarget_ = null;\n        _this.layoutFrame_ = 0;\n        _this.scrollFrameScrollLeft_ = 0;\n        _this.forwardIndicatorClickHandler_ = function (evt) {\n            return _this.scrollForward(evt);\n        };\n        _this.backIndicatorClickHandler_ = function (evt) {\n            return _this.scrollBack(evt);\n        };\n        _this.resizeHandler_ = function () {\n            return _this.layout();\n        };\n        _this.interactionHandler_ = function (evt) {\n            if (evt.type == 'touchstart' || evt.type == 'mousedown') {\n                _this.pointerDownRecognized_ = true;\n            }\n            _this.handlePossibleTabKeyboardFocus_(evt);\n            if (evt.type == 'focus') {\n                _this.pointerDownRecognized_ = false;\n            }\n        };\n        return _this;\n    }\n    _createClass(MDCTabBarScrollerFoundation, [{\n            key: \"init\",\n            value: function init() {\n                var _this2 = this;\n                this.adapter_.registerBackIndicatorClickHandler(this.backIndicatorClickHandler_);\n                this.adapter_.registerForwardIndicatorClickHandler(this.forwardIndicatorClickHandler_);\n                this.adapter_.registerWindowResizeHandler(this.resizeHandler_);\n                ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {\n                    _this2.adapter_.registerCapturedInteractionHandler(evtType, _this2.interactionHandler_);\n                });\n                this.layout();\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                var _this3 = this;\n                this.adapter_.deregisterBackIndicatorClickHandler(this.backIndicatorClickHandler_);\n                this.adapter_.deregisterForwardIndicatorClickHandler(this.forwardIndicatorClickHandler_);\n                this.adapter_.deregisterWindowResizeHandler(this.resizeHandler_);\n                ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {\n                    _this3.adapter_.deregisterCapturedInteractionHandler(evtType, _this3.interactionHandler_);\n                });\n            }\n        }, {\n            key: \"scrollBack\",\n            value: function scrollBack() {\n                var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n                if (evt) {\n                    evt.preventDefault();\n                }\n                var tabWidthAccumulator = 0;\n                var scrollTargetIndex = 0;\n                for (var i = this.adapter_.getNumberOfTabs() - 1; i > 0; i--) {\n                    var tabOffsetLeft = this.adapter_.getComputedLeftForTabAtIndex(i);\n                    var tabBarWidthLessTabOffsetLeft = this.adapter_.getOffsetWidthForTabBar() - tabOffsetLeft;\n                    var tabIsNotOccluded = tabOffsetLeft > this.currentTranslateOffset_;\n                    if (this.isRTL_()) {\n                        tabIsNotOccluded = tabBarWidthLessTabOffsetLeft > this.currentTranslateOffset_;\n                    }\n                    if (tabIsNotOccluded) {\n                        continue;\n                    }\n                    tabWidthAccumulator += this.adapter_.getComputedWidthForTabAtIndex(i);\n                    var scrollTargetDetermined = tabWidthAccumulator > this.adapter_.getOffsetWidthForScrollFrame();\n                    if (scrollTargetDetermined) {\n                        scrollTargetIndex = this.isRTL_() ? i + 1 : i;\n                        break;\n                    }\n                }\n                this.scrollToTabAtIndex(scrollTargetIndex);\n            }\n        }, {\n            key: \"scrollForward\",\n            value: function scrollForward() {\n                var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n                if (evt) {\n                    evt.preventDefault();\n                }\n                var scrollFrameOffsetWidth = this.adapter_.getOffsetWidthForScrollFrame() + this.currentTranslateOffset_;\n                var scrollTargetIndex = 0;\n                for (var i = 0; i < this.adapter_.getNumberOfTabs(); i++) {\n                    var tabOffsetLeftAndWidth = this.adapter_.getComputedLeftForTabAtIndex(i) + this.adapter_.getComputedWidthForTabAtIndex(i);\n                    var scrollTargetDetermined = tabOffsetLeftAndWidth > scrollFrameOffsetWidth;\n                    if (this.isRTL_()) {\n                        var frameOffsetAndTabWidth = scrollFrameOffsetWidth - this.adapter_.getComputedWidthForTabAtIndex(i);\n                        var _tabOffsetLeftAndWidth = this.adapter_.getComputedLeftForTabAtIndex(i) + this.adapter_.getComputedWidthForTabAtIndex(i);\n                        var tabRightOffset = this.adapter_.getOffsetWidthForTabBar() - _tabOffsetLeftAndWidth;\n                        scrollTargetDetermined = tabRightOffset > frameOffsetAndTabWidth;\n                    }\n                    if (scrollTargetDetermined) {\n                        scrollTargetIndex = i;\n                        break;\n                    }\n                }\n                this.scrollToTabAtIndex(scrollTargetIndex);\n            }\n        }, {\n            key: \"layout\",\n            value: function layout() {\n                var _this4 = this;\n                cancelAnimationFrame(this.layoutFrame_);\n                this.scrollFrameScrollLeft_ = this.adapter_.getScrollLeftForScrollFrame();\n                this.layoutFrame_ = requestAnimationFrame(function () {\n                    return _this4.layout_();\n                });\n            }\n        }, {\n            key: \"isRTL_\",\n            value: function isRTL_() {\n                return this.adapter_.isRTL();\n            }\n        }, {\n            key: \"handlePossibleTabKeyboardFocus_\",\n            value: function handlePossibleTabKeyboardFocus_(evt) {\n                if (!this.adapter_.eventTargetHasClass(evt.target, cssClasses$3.TAB) || this.pointerDownRecognized_) {\n                    return;\n                }\n                var resetAmt = this.isRTL_() ? this.scrollFrameScrollLeft_ : 0;\n                this.adapter_.setScrollLeftForScrollFrame(resetAmt);\n                this.focusedTarget_ = evt.target;\n                var scrollFrameWidth = this.adapter_.getOffsetWidthForScrollFrame();\n                var tabBarWidth = this.adapter_.getOffsetWidthForTabBar();\n                var leftEdge = this.adapter_.getOffsetLeftForEventTarget(this.focusedTarget_);\n                var rightEdge = leftEdge + this.adapter_.getOffsetWidthForEventTarget(this.focusedTarget_);\n                var shouldScrollBack = rightEdge <= this.currentTranslateOffset_;\n                var shouldScrollForward = rightEdge > this.currentTranslateOffset_ + scrollFrameWidth;\n                if (this.isRTL_()) {\n                    var normalizedLeftOffset = tabBarWidth - leftEdge;\n                    shouldScrollBack = leftEdge >= tabBarWidth - this.currentTranslateOffset_;\n                    shouldScrollForward = normalizedLeftOffset > scrollFrameWidth + this.currentTranslateOffset_;\n                }\n                if (shouldScrollForward) {\n                    this.scrollForward();\n                }\n                else if (shouldScrollBack) {\n                    this.scrollBack();\n                }\n                this.pointerDownRecognized_ = false;\n            }\n        }, {\n            key: \"layout_\",\n            value: function layout_() {\n                var frameWidth = this.adapter_.getOffsetWidthForScrollFrame();\n                var isOverflowing = this.adapter_.getOffsetWidthForTabBar() > frameWidth;\n                if (!isOverflowing) {\n                    this.currentTranslateOffset_ = 0;\n                }\n                this.shiftFrame_();\n                this.updateIndicatorEnabledStates_();\n            }\n        }, {\n            key: \"scrollToTabAtIndex\",\n            value: function scrollToTabAtIndex(index) {\n                var _this5 = this;\n                var scrollTargetOffsetLeft = this.adapter_.getComputedLeftForTabAtIndex(index);\n                var scrollTargetOffsetWidth = this.adapter_.getComputedWidthForTabAtIndex(index);\n                this.currentTranslateOffset_ = this.normalizeForRTL_(scrollTargetOffsetLeft, scrollTargetOffsetWidth);\n                requestAnimationFrame(function () {\n                    return _this5.shiftFrame_();\n                });\n            }\n        }, {\n            key: \"normalizeForRTL_\",\n            value: function normalizeForRTL_(left, width) {\n                return this.isRTL_() ? this.adapter_.getOffsetWidthForTabBar() - (left + width) : left;\n            }\n        }, {\n            key: \"shiftFrame_\",\n            value: function shiftFrame_() {\n                var shiftAmount = this.isRTL_() ? this.currentTranslateOffset_ : -this.currentTranslateOffset_;\n                this.adapter_.setTransformStyleForTabBar(\"translateX(\".concat(shiftAmount, \"px)\"));\n                this.updateIndicatorEnabledStates_();\n            }\n        }, {\n            key: \"updateIndicatorEnabledStates_\",\n            value: function updateIndicatorEnabledStates_() {\n                var INDICATOR_ENABLED = cssClasses$3.INDICATOR_ENABLED;\n                if (this.currentTranslateOffset_ === 0) {\n                    this.adapter_.removeClassFromBackIndicator(INDICATOR_ENABLED);\n                }\n                else {\n                    this.adapter_.addClassToBackIndicator(INDICATOR_ENABLED);\n                }\n                var remainingTabBarWidth = this.adapter_.getOffsetWidthForTabBar() - this.currentTranslateOffset_;\n                if (remainingTabBarWidth > this.adapter_.getOffsetWidthForScrollFrame()) {\n                    this.adapter_.addClassToForwardIndicator(INDICATOR_ENABLED);\n                }\n                else {\n                    this.adapter_.removeClassFromForwardIndicator(INDICATOR_ENABLED);\n                }\n            }\n        }]);\n    return MDCTabBarScrollerFoundation;\n}(MDCFoundation);\nvar MDCTabBarScroller = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCTabBarScroller, _MDCComponent);\n    function MDCTabBarScroller() {\n        _classCallCheck(this, MDCTabBarScroller);\n        return _possibleConstructorReturn(this, (MDCTabBarScroller.__proto__ || Object.getPrototypeOf(MDCTabBarScroller)).apply(this, arguments));\n    }\n    _createClass(MDCTabBarScroller, [{\n            key: \"initialize\",\n            value: function initialize() {\n                var tabBarFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (root) {\n                    return new MDCTabBar(root);\n                };\n                this.scrollFrame_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.FRAME_SELECTOR);\n                this.tabBarEl_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.TABS_SELECTOR);\n                this.forwardIndicator_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.INDICATOR_FORWARD_SELECTOR);\n                this.backIndicator_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.INDICATOR_BACK_SELECTOR);\n                this.tabBar_ = tabBarFactory(this.tabBarEl_);\n            }\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this = this;\n                return new MDCTabBarScrollerFoundation({\n                    addClass: function addClass(className) {\n                        return _this.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this.root_.classList.remove(className);\n                    },\n                    eventTargetHasClass: function eventTargetHasClass(target, className) {\n                        return target.classList.contains(className);\n                    },\n                    addClassToForwardIndicator: function addClassToForwardIndicator(className) {\n                        return _this.forwardIndicator_.classList.add(className);\n                    },\n                    removeClassFromForwardIndicator: function removeClassFromForwardIndicator(className) {\n                        return _this.forwardIndicator_.classList.remove(className);\n                    },\n                    addClassToBackIndicator: function addClassToBackIndicator(className) {\n                        return _this.backIndicator_.classList.add(className);\n                    },\n                    removeClassFromBackIndicator: function removeClassFromBackIndicator(className) {\n                        return _this.backIndicator_.classList.remove(className);\n                    },\n                    isRTL: function isRTL() {\n                        return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';\n                    },\n                    registerBackIndicatorClickHandler: function registerBackIndicatorClickHandler(handler) {\n                        return _this.backIndicator_.addEventListener('click', handler);\n                    },\n                    deregisterBackIndicatorClickHandler: function deregisterBackIndicatorClickHandler(handler) {\n                        return _this.backIndicator_.removeEventListener('click', handler);\n                    },\n                    registerForwardIndicatorClickHandler: function registerForwardIndicatorClickHandler(handler) {\n                        return _this.forwardIndicator_.addEventListener('click', handler);\n                    },\n                    deregisterForwardIndicatorClickHandler: function deregisterForwardIndicatorClickHandler(handler) {\n                        return _this.forwardIndicator_.removeEventListener('click', handler);\n                    },\n                    registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {\n                        return _this.root_.addEventListener(evt, handler, true);\n                    },\n                    deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {\n                        return _this.root_.removeEventListener(evt, handler, true);\n                    },\n                    registerWindowResizeHandler: function registerWindowResizeHandler(handler) {\n                        return window.addEventListener('resize', handler);\n                    },\n                    deregisterWindowResizeHandler: function deregisterWindowResizeHandler(handler) {\n                        return window.removeEventListener('resize', handler);\n                    },\n                    getNumberOfTabs: function getNumberOfTabs() {\n                        return _this.tabBar.tabs.length;\n                    },\n                    getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {\n                        return _this.tabBar.tabs[index].computedWidth;\n                    },\n                    getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {\n                        return _this.tabBar.tabs[index].computedLeft;\n                    },\n                    getOffsetWidthForScrollFrame: function getOffsetWidthForScrollFrame() {\n                        return _this.scrollFrame_.offsetWidth;\n                    },\n                    getScrollLeftForScrollFrame: function getScrollLeftForScrollFrame() {\n                        return _this.scrollFrame_.scrollLeft;\n                    },\n                    setScrollLeftForScrollFrame: function setScrollLeftForScrollFrame(scrollLeftAmount) {\n                        return _this.scrollFrame_.scrollLeft = scrollLeftAmount;\n                    },\n                    getOffsetWidthForTabBar: function getOffsetWidthForTabBar() {\n                        return _this.tabBarEl_.offsetWidth;\n                    },\n                    setTransformStyleForTabBar: function setTransformStyleForTabBar(value) {\n                        _this.tabBarEl_.style.setProperty(getCorrectPropertyName(window, 'transform'), value);\n                    },\n                    getOffsetLeftForEventTarget: function getOffsetLeftForEventTarget(target) {\n                        return target.offsetLeft;\n                    },\n                    getOffsetWidthForEventTarget: function getOffsetWidthForEventTarget(target) {\n                        return target.offsetWidth;\n                    }\n                });\n            }\n        }, {\n            key: \"layout\",\n            value: function layout() {\n                this.foundation_.layout();\n            }\n        }, {\n            key: \"tabBar\",\n            get: function get() {\n                return this.tabBar_;\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                return new MDCTabBarScroller(root);\n            }\n        }]);\n    return MDCTabBarScroller;\n}(MDCComponent);\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MdcTabIconText = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabIconText(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n    }\n    return MdcTabIconText;\n}());\nvar MdcTab = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTab(_changeDetectorRef, _renderer, elementRef, _registry, ripple) {\n        var _this = this;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this._registry = _registry;\n        this.ripple = ripple;\n        /**\n         * Emits whenever the component is destroyed.\n         */\n        this._destroy = new Subject();\n        this._active = false;\n        this._disabled = false;\n        /**\n         * Event emitted when the option is selected.\n         */\n        this.selected = new EventEmitter();\n        this.isHostClass = true;\n        this.role = 'tab';\n        this._mdcAdapter = {\n            addClass: function (className) {\n                _this._renderer.addClass(_this._getHostElement(), className);\n            },\n            removeClass: function (className) {\n                _this._renderer.removeClass(_this._getHostElement(), className);\n            },\n            registerInteractionHandler: function (type, handler) {\n                _this._registry.listen(type, handler, _this._getHostElement());\n            },\n            deregisterInteractionHandler: function (type, handler) {\n                _this._registry.unlisten(type, handler);\n            },\n            getOffsetWidth: function () { return _this._getHostElement().offsetWidth; },\n            getOffsetLeft: function () { return _this._getHostElement().offsetLeft; },\n            notifySelected: function () { return _this._emitSelectedEvent(); }\n        };\n        this._foundation = new MDCTabFoundation(this._mdcAdapter);\n    }\n    Object.defineProperty(MdcTab.prototype, \"active\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._active; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setActive(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTab.prototype, \"disabled\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setDisabled(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTab.prototype, \"classIconText\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.tabIcon != null && this.tabIconText != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTab.prototype, \"classActive\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._active ? 'mdc-tab--active' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTab.prototype, \"classDisabled\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._disabled ? 'ng-mdc-tab--disabled' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdcTab.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._foundation.init();\n            this.setPreventDefaultOnClick(true);\n            if (this.tabRouter) {\n                this._routerChangeSubscription = this.tabRouter.routeChange\n                    .pipe(takeUntil(this._destroy))\n                    .subscribe(function (_) {\n                    _this.setActive(_.active);\n                    _this._emitSelectedEvent();\n                });\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdcTab.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._destroy.next();\n            this._destroy.complete();\n            this._foundation.destroy();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTab.prototype.isActive = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation.isActive();\n        };\n    /**\n     * @param {?} active\n     * @return {?}\n     */\n    MdcTab.prototype.setActive = /**\n     * @param {?} active\n     * @return {?}\n     */\n        function (active) {\n            this._active = toBoolean(active);\n            this._foundation.setActive(active);\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n    MdcTab.prototype.setDisabled = /**\n     * @param {?} disabled\n     * @return {?}\n     */\n        function (disabled) {\n            this._disabled = disabled;\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTab.prototype.getComputedWidth = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation.getComputedWidth();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTab.prototype.getComputedLeft = /**\n     * @return {?}\n     */\n        function () {\n            return this._mdcAdapter.getOffsetLeft();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTab.prototype.getPreventDefaultOnClick = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation.preventsDefaultOnClick();\n        };\n    /**\n     * @param {?} preventDefaultOnClick\n     * @return {?}\n     */\n    MdcTab.prototype.setPreventDefaultOnClick = /**\n     * @param {?} preventDefaultOnClick\n     * @return {?}\n     */\n        function (preventDefaultOnClick) {\n            this._foundation.setPreventDefaultOnClick(preventDefaultOnClick);\n        };\n    /**\n     * @return {?}\n     */\n    MdcTab.prototype.measureSelf = /**\n     * @return {?}\n     */\n        function () {\n            this._foundation.measureSelf();\n        };\n    /**\n     * Emits the tab selected event.\n     * @return {?}\n     */\n    MdcTab.prototype._emitSelectedEvent = /**\n     * Emits the tab selected event.\n     * @return {?}\n     */\n        function () {\n            this.selected.emit({ tab: this });\n        };\n    /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n    MdcTab.prototype._getHostElement = /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n        function () {\n            return this.elementRef.nativeElement;\n        };\n    return MdcTab;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A simple change event emitted selection changes.\n */\nvar /**\n * A simple change event emitted selection changes.\n */ MdcTabChangeEvent = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabChangeEvent(index, tab) {\n        this.index = index;\n        this.tab = tab;\n    }\n    return MdcTabChangeEvent;\n}());\nvar MdcTabBarIndicator = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabBarIndicator(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n    }\n    return MdcTabBarIndicator;\n}());\nvar MdcTabBar = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabBar(_ngZone, _changeDetectorRef, _renderer, elementRef, _registry) {\n        var _this = this;\n        this._ngZone = _ngZone;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this._registry = _registry;\n        /**\n         * Emits whenever the component is destroyed.\n         */\n        this._destroy = new Subject();\n        this._disableRipple = false;\n        this._primary = false;\n        this._secondary = false;\n        /**\n         * The tab index that should be selected after the content has been checked.\n         */\n        this._indexToSelect = 0;\n        this._selectedIndex = null;\n        /**\n         * Event emitted when the tab selection has changed.\n         */\n        this.selectedTabChange = new EventEmitter(true);\n        /**\n         * Event emitted when tabs are added or removed.\n         */\n        this.tabsChangeEvent = new EventEmitter();\n        this.isHostClass = true;\n        this.scrollFrameContent = false;\n        this.role = 'tablist';\n        /**\n         * Combined stream of all of the tab change events.\n         */\n        this.optionSelectionChanges = defer(function () {\n            if (_this.tabs) {\n                return merge.apply(void 0, _this.tabs.map(function (option) { return option.selected; }));\n            }\n            return _this._ngZone.onStable\n                .asObservable()\n                .pipe(take(1), switchMap(function () { return _this.optionSelectionChanges; }));\n        });\n        this._mdcAdapter = {\n            addClass: function (className) {\n                _this._renderer.addClass(_this.elementRef.nativeElement, className);\n            },\n            removeClass: function (className) {\n                _this._renderer.removeClass(_this.elementRef.nativeElement, className);\n            },\n            bindOnMDCTabSelectedEvent: function () {\n                var /** @type {?} */ changedOrDestroyed = merge(_this.tabs.changes, _this._destroy);\n                _this.optionSelectionChanges\n                    .pipe(takeUntil(changedOrDestroyed)).subscribe(function (event) {\n                    if (event.tab.disabled) {\n                        return;\n                    }\n                    _this.setActiveTab(event.tab, true);\n                    _this._foundation.switchToTabAtIndex(_this.getActiveTabIndex(), true);\n                    _this.selectedTabChange.emit(new MdcTabChangeEvent(_this.getActiveTabIndex(), event.tab));\n                });\n            },\n            unbindOnMDCTabSelectedEvent: function () {\n                /* not needed */\n            },\n            registerResizeHandler: function (handler) {\n                if (isBrowser()) {\n                    _this._registry.listen('resize', handler, window);\n                }\n            },\n            deregisterResizeHandler: function (handler) {\n                if (isBrowser()) {\n                    _this._registry.unlisten('resize', handler);\n                }\n            },\n            getOffsetWidth: function () { return _this.elementRef.nativeElement.offsetWidth; },\n            setStyleForIndicator: function (propertyName, value) {\n                return _this._renderer.setStyle(_this.indicator.elementRef.nativeElement, propertyName, value);\n            },\n            getOffsetWidthForIndicator: function () { return _this.indicator.elementRef.nativeElement.offsetWidth; },\n            notifyChange: function (evtData) {\n                _this.selectedTabChange.emit(new MdcTabChangeEvent(evtData.activeTabIndex, _this.getActiveTab()));\n            },\n            getNumberOfTabs: function () { return _this.tabs.length; },\n            isTabActiveAtIndex: function (index) { return _this.tabs.toArray()[index].isActive(); },\n            setTabActiveAtIndex: function (index, isActive) { return _this.tabs.toArray()[index].setActive(isActive); },\n            isDefaultPreventedOnClickForTabAtIndex: function (index) { return !!_this.tabs.toArray()[index].getPreventDefaultOnClick(); },\n            setPreventDefaultOnClickForTabAtIndex: function (index, preventDefaultOnClick) {\n                return _this.tabs.toArray()[index].setPreventDefaultOnClick(preventDefaultOnClick);\n            },\n            measureTabAtIndex: function (index) { return _this.tabs.toArray()[index].measureSelf(); },\n            getComputedWidthForTabAtIndex: function (index) {\n                return _this.tabs.length ? _this.tabs.toArray()[index].getComputedWidth() : -1;\n            },\n            getComputedLeftForTabAtIndex: function (index) {\n                return _this.tabs.length ? _this.tabs.toArray()[index].getComputedLeft() : -1;\n            }\n        };\n        this._foundation = new MDCTabBarFoundation(this._mdcAdapter);\n    }\n    Object.defineProperty(MdcTabBar.prototype, \"selectedIndex\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._selectedIndex; },\n        /** The index of the active tab. */\n        set: /**\n         * The index of the active tab.\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._indexToSelect = toNumber(value, null);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTabBar.prototype, \"primary\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._primary; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._primary = toBoolean(value);\n            this._changeDetectorRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTabBar.prototype, \"secondary\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._secondary; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._secondary = toBoolean(value);\n            this._changeDetectorRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTabBar.prototype, \"disableRipple\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._disableRipple; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setDisableRipple(value);\n            this._changeDetectorRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTabBar.prototype, \"classTabIcon\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.tabs.length > 0\n                && this.tabs.first.tabIcon != null\n                && this.tabs.first.tabIconText == null ? 'mdc-tab-bar--icon-tab-bar' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTabBar.prototype, \"classTabIconText\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.tabs.length > 0\n                && this.tabs.first.tabIcon != null\n                && this.tabs.first.tabIconText != null ? 'mdc-tab-bar--icons-with-text' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTabBar.prototype, \"classPrimary\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.primary ? 'ng-mdc-tab--primary' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTabBar.prototype, \"classSecondary\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.secondary ? 'ng-mdc-tab--secondary' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdcTabBar.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // Subscribe to changes in the amount of tabs, in order to be\n            // able to re-render the content as new tabs are added or removed.\n            this.tabs.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(function () {\n                _this._foundation.init();\n                _this._initializeSelection();\n                _this.setDisableRipple(_this.disableRipple);\n                _this._foundation.layout();\n                _this.tabsChangeEvent.emit();\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBar.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._destroy.next();\n            this._destroy.complete();\n            this._foundation.destroy();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBar.prototype._initializeSelection = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // Defer setting the value in order to avoid the \"Expression\n            // has changed after it was checked\" errors from Angular.\n            Promise.resolve().then(function () {\n                if (_this.getActiveTabIndex() < 0 && _this.tabs.first) {\n                    _this.tabs.first.setActive(true);\n                }\n            });\n        };\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n    MdcTabBar.prototype.setDisableRipple = /**\n     * @param {?} disabled\n     * @return {?}\n     */\n        function (disabled) {\n            if (!this.tabs) {\n                return;\n            }\n            if (this._disableRipple !== disabled) {\n                this._disableRipple = disabled;\n            }\n            this.tabs.forEach(function (tab) {\n                disabled ? tab.ripple.destroy() : tab.ripple.attachTo(tab.elementRef.nativeElement);\n            });\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MdcTabBar.prototype.setTabActiveAtIndex = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            if (this.tabs.toArray()[index].disabled) {\n                return;\n            }\n            this._foundation.switchToTabAtIndex(index, true);\n            this._mdcAdapter.setTabActiveAtIndex(index, true);\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBar.prototype.getActiveTabIndex = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation.getActiveTabIndex();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBar.prototype.getActiveTab = /**\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ tab = this.tabs.find(function (_) { return _.isActive(); });\n            return tab ? tab[0] : null;\n        };\n    /**\n     * @param {?} tab\n     * @param {?} active\n     * @return {?}\n     */\n    MdcTabBar.prototype.setActiveTab = /**\n     * @param {?} tab\n     * @param {?} active\n     * @return {?}\n     */\n        function (tab, active) {\n            this.tabs.forEach(function (_) {\n                _.setActive(false);\n            }); /** @type {?} */\n            ((this.tabs.find(function (_) { return _ === tab; }))).setActive(active);\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBar.prototype.layout = /**\n     * @return {?}\n     */\n        function () {\n            this._foundation.layout();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBar.prototype.getNumberOfTabs = /**\n     * @return {?}\n     */\n        function () {\n            return this._mdcAdapter.getNumberOfTabs();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBar.prototype.getComputedWidth = /**\n     * @return {?}\n     */\n        function () {\n            return this._mdcAdapter.getOffsetWidth();\n        };\n    /**\n     * @param {?} index\n     * @param {?} preventDefaultOnClick\n     * @return {?}\n     */\n    MdcTabBar.prototype.setPreventDefaultOnClickForTabAtIndex = /**\n     * @param {?} index\n     * @param {?} preventDefaultOnClick\n     * @return {?}\n     */\n        function (index, preventDefaultOnClick) {\n            this._mdcAdapter.setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick);\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MdcTabBar.prototype.isDefaultPreventedOnClickForTabAtIndex = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            return this._mdcAdapter.isDefaultPreventedOnClickForTabAtIndex(index);\n        };\n    return MdcTabBar;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MdcTabBarScrollBack = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabBarScrollBack(_renderer, elementRef) {\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n        this.isBackClass = true;\n    }\n    /**\n     * @return {?}\n     */\n    MdcTabBarScrollBack.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.icon) {\n                this._renderer.addClass(this.icon.elementRef.nativeElement, 'mdc-tab-bar-scroller__indicator__inner');\n            }\n        };\n    return MdcTabBarScrollBack;\n}());\nvar MdcTabBarScrollForward = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabBarScrollForward(_renderer, elementRef) {\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n        this.isForwardClass = true;\n    }\n    /**\n     * @return {?}\n     */\n    MdcTabBarScrollForward.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.icon) {\n                this._renderer.addClass(this.icon.elementRef.nativeElement, 'mdc-tab-bar-scroller__indicator__inner');\n            }\n        };\n    return MdcTabBarScrollForward;\n}());\nvar MdcTabBarScrollFrame = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabBarScrollFrame(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n    }\n    /**\n     * @return {?}\n     */\n    MdcTabBarScrollFrame.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.tabBar) {\n                this.tabBar.scrollFrameContent = true;\n            }\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MdcTabBarScrollFrame.prototype.findTab = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            return this.tabBar.tabs.toArray()[index];\n        };\n    return MdcTabBarScrollFrame;\n}());\nvar MdcTabBarScroller = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabBarScroller(_renderer, elementRef, _registry) {\n        var _this = this;\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this._registry = _registry;\n        this.direction = 'ltr';\n        this.isHostClass = true;\n        this._mdcAdapter = {\n            addClass: function (className) {\n                _this._renderer.addClass(_this.elementRef.nativeElement, className);\n            },\n            removeClass: function (className) {\n                _this._renderer.removeClass(_this.elementRef.nativeElement, className);\n            },\n            eventTargetHasClass: function (target, className) { return target.classList.contains(className); },\n            addClassToForwardIndicator: function (className) {\n                if (_this.scrollForward) {\n                    _this._renderer.addClass(_this.forward.elementRef.nativeElement, className);\n                }\n            },\n            removeClassFromForwardIndicator: function (className) {\n                if (_this.scrollForward) {\n                    _this._renderer.removeClass(_this.forward.elementRef.nativeElement, className);\n                }\n            },\n            addClassToBackIndicator: function (className) {\n                if (_this.scrollBack) {\n                    _this._renderer.addClass(_this.back.elementRef.nativeElement, className);\n                }\n            },\n            removeClassFromBackIndicator: function (className) {\n                if (_this.scrollBack) {\n                    _this._renderer.removeClass(_this.back.elementRef.nativeElement, className);\n                }\n            },\n            isRTL: function () { return _this.direction === 'rtl'; },\n            registerBackIndicatorClickHandler: function (handler) {\n                if (_this.scrollBack) {\n                    _this._registry.listen('click', handler, _this.back.elementRef.nativeElement);\n                }\n            },\n            deregisterBackIndicatorClickHandler: function (handler) {\n                if (_this.scrollBack) {\n                    _this._registry.unlisten('click', handler);\n                }\n            },\n            registerForwardIndicatorClickHandler: function (handler) {\n                if (_this.scrollForward) {\n                    _this._registry.listen('click', handler, _this.forward.elementRef.nativeElement);\n                }\n            },\n            deregisterForwardIndicatorClickHandler: function (handler) {\n                if (_this.scrollForward) {\n                    _this._registry.unlisten('click', handler);\n                }\n            },\n            registerCapturedInteractionHandler: function (evt, handler) {\n                _this._registry.listen(evt, handler, _this.elementRef.nativeElement);\n            },\n            deregisterCapturedInteractionHandler: function (evt, handler) {\n                _this._registry.unlisten(evt, handler);\n            },\n            registerWindowResizeHandler: function (handler) {\n                if (isBrowser()) {\n                    _this._registry.listen('resize', handler, window);\n                }\n            },\n            deregisterWindowResizeHandler: function (handler) {\n                if (isBrowser()) {\n                    _this._registry.unlisten('resize', handler);\n                }\n            },\n            getNumberOfTabs: function () {\n                return (_this.scrollFrame && _this.scrollFrame.tabBar) ? _this.scrollFrame.tabBar.tabs.length : 0;\n            },\n            getComputedWidthForTabAtIndex: function (index) { return _this.scrollFrame.findTab(index).getComputedWidth(); },\n            getComputedLeftForTabAtIndex: function (index) { return _this.scrollFrame.findTab(index).getComputedLeft(); },\n            getOffsetWidthForScrollFrame: function () {\n                return _this.scrollFrame ? _this.scrollFrame.elementRef.nativeElement.offsetWidth : 0;\n            },\n            getScrollLeftForScrollFrame: function () {\n                return _this.scrollFrame ? _this.scrollFrame.elementRef.nativeElement.scrollLeft : 0;\n            },\n            setScrollLeftForScrollFrame: function (scrollLeftAmount) {\n                if (_this.scrollFrame) {\n                    _this._renderer.setProperty(_this.scrollFrame.elementRef.nativeElement, 'scrollLeft', scrollLeftAmount);\n                }\n            },\n            getOffsetWidthForTabBar: function () {\n                return (_this.scrollFrame && _this.scrollFrame.tabBar) ? _this.scrollFrame.tabBar.elementRef.nativeElement.offsetWidth : 0;\n            },\n            setTransformStyleForTabBar: function (value) {\n                if (_this.scrollFrame && _this.scrollFrame.tabBar) {\n                    _this._renderer.setStyle(_this.scrollFrame.tabBar.elementRef.nativeElement, getCorrectPropertyName(window, 'transform'), value);\n                }\n            },\n            getOffsetLeftForEventTarget: function (target) { return target.offsetLeft; },\n            getOffsetWidthForEventTarget: function (target) { return target.offsetWidth; }\n        };\n        this._foundation = new MDCTabBarScrollerFoundation(this._mdcAdapter);\n    }\n    /**\n     * @return {?}\n     */\n    MdcTabBarScroller.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            this._foundation.init();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBarScroller.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._tabBarChangeSubscription = this.scrollFrame.tabBar.tabsChangeEvent.subscribe(function () {\n                _this.layout();\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBarScroller.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._tabBarChangeSubscription) {\n                this._tabBarChangeSubscription.unsubscribe();\n                this._tabBarChangeSubscription = null;\n            }\n            this._foundation.destroy();\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MdcTabBarScroller.prototype.scrollToTabAtIndex = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            this._foundation.scrollToTabAtIndex(index);\n        };\n    /**\n     * @return {?}\n     */\n    MdcTabBarScroller.prototype.layout = /**\n     * @return {?}\n     */\n        function () {\n            this._foundation.layout();\n        };\n    /**\n     * @param {?=} event\n     * @return {?}\n     */\n    MdcTabBarScroller.prototype.scrollBack = /**\n     * @param {?=} event\n     * @return {?}\n     */\n        function (event) {\n            this._foundation.scrollBack(event);\n        };\n    /**\n     * @param {?=} event\n     * @return {?}\n     */\n    MdcTabBarScroller.prototype.scrollForward = /**\n     * @param {?=} event\n     * @return {?}\n     */\n        function (event) {\n            this._foundation.scrollForward(event);\n        };\n    return MdcTabBarScroller;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ TAB_DECLARATIONS = [\n    MdcTab,\n    MdcTabIconText,\n    MdcTabBar,\n    MdcTabBarIndicator,\n    MdcTabBarScroller,\n    MdcTabBarScrollBack,\n    MdcTabBarScrollForward,\n    MdcTabBarScrollFrame,\n];\nvar MdcTabModule = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTabModule() {\n    }\n    return MdcTabModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MdcTabModule, MdcTabIconText, MdcTab, MdcTabChangeEvent, MdcTabBarIndicator, MdcTabBar, MdcTabBarScrollBack, MdcTabBarScrollForward, MdcTabBarScrollFrame, MdcTabBarScroller };\n",null]}