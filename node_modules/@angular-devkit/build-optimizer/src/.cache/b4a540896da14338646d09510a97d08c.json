{"remainingRequest":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\ngx-toastr\\fesm5\\ngx-toastr.js","dependencies":[{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\ngx-toastr\\fesm5\\ngx-toastr.js","mtime":1556004132635},{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1556004112812},{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1556004088045}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _angular_animations,_angular_platform_browser,rxjs,tslib,_angular_common,_angular_core PURE_IMPORTS_END */\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { Subject } from 'rxjs';\nimport { __assign, __values, __extends } from 'tslib';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Directive, ElementRef, NgModule, InjectionToken, Inject, Injectable, defineInjectable, inject, ComponentFactoryResolver, ApplicationRef, Component, HostBinding, HostListener, NgZone, SecurityContext, Injector, INJECTOR } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ToastContainerDirective = /** @class */ /*@__PURE__*/ (function () {\n    function ToastContainerDirective(el) {\n        this.el = el;\n    }\n    /**\n     * @return {?}\n     */\n    ToastContainerDirective.prototype.getContainerElement = /**\n     * @return {?}\n     */\n        function () {\n            return this.el.nativeElement;\n        };\n    return ToastContainerDirective;\n}());\nvar ToastContainerModule = /** @class */ /*@__PURE__*/ (function () {\n    function ToastContainerModule() {\n    }\n    return ToastContainerModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Everything a toast needs to launch\n */\nvar /**\n * Everything a toast needs to launch\n */ ToastPackage = /** @class */ /*@__PURE__*/ (function () {\n    function ToastPackage(toastId, config, message, title, toastType, toastRef) {\n        var _this = this;\n        this.toastId = toastId;\n        this.config = config;\n        this.message = message;\n        this.title = title;\n        this.toastType = toastType;\n        this.toastRef = toastRef;\n        this._onTap = new Subject();\n        this._onAction = new Subject();\n        this.toastRef.afterClosed().subscribe(( /**\n         * @return {?}\n         */function () {\n            _this._onAction.complete();\n            _this._onTap.complete();\n        }));\n    }\n    /** Fired on click */\n    /**\n     * Fired on click\n     * @return {?}\n     */\n    ToastPackage.prototype.triggerTap = /**\n     * Fired on click\n     * @return {?}\n     */\n        function () {\n            this._onTap.next();\n            if (this.config.tapToDismiss) {\n                this._onTap.complete();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ToastPackage.prototype.onTap = /**\n     * @return {?}\n     */\n        function () {\n            return this._onTap.asObservable();\n        };\n    /** available for use in custom toast */\n    /**\n     * available for use in custom toast\n     * @param {?=} action\n     * @return {?}\n     */\n    ToastPackage.prototype.triggerAction = /**\n     * available for use in custom toast\n     * @param {?=} action\n     * @return {?}\n     */\n        function (action) {\n            this._onAction.next(action);\n        };\n    /**\n     * @return {?}\n     */\n    ToastPackage.prototype.onAction = /**\n     * @return {?}\n     */\n        function () {\n            return this._onAction.asObservable();\n        };\n    return ToastPackage;\n}());\n/** @type {?} */\nvar DefaultNoComponentGlobalConfig = {\n    maxOpened: 0,\n    autoDismiss: false,\n    newestOnTop: true,\n    preventDuplicates: false,\n    countDuplicates: false,\n    resetTimeoutOnDuplicate: false,\n    iconClasses: {\n        error: 'toast-error',\n        info: 'toast-info',\n        success: 'toast-success',\n        warning: 'toast-warning',\n    },\n    // Individual\n    closeButton: false,\n    disableTimeOut: false,\n    timeOut: 5000,\n    extendedTimeOut: 1000,\n    enableHtml: false,\n    progressBar: false,\n    toastClass: 'ngx-toastr',\n    positionClass: 'toast-top-right',\n    titleClass: 'toast-title',\n    messageClass: 'toast-message',\n    easing: 'ease-in',\n    easeTime: 300,\n    tapToDismiss: true,\n    onActivateTick: false,\n    progressAnimation: 'decreasing',\n};\n/** @type {?} */\nvar TOAST_CONFIG = /*@__PURE__*/ new InjectionToken('ToastConfig');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n * @template T\n */\nvar /**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n * @template T\n */ ComponentPortal = /** @class */ /*@__PURE__*/ (function () {\n    function ComponentPortal(component, injector) {\n        this.component = component;\n        this.injector = injector;\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n    ComponentPortal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n        function (host, newestOnTop) {\n            this._attachedHost = host;\n            return host.attach(this, newestOnTop);\n        };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    ComponentPortal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var host = this._attachedHost;\n            if (host) {\n                this._attachedHost = undefined;\n                return host.detach();\n            }\n        };\n    Object.defineProperty(ComponentPortal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */ function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\n     * the PortalHost when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\n     * the PortalHost when it is performing an `attach()` or `detach()`.\n     * @param {?=} host\n     * @return {?}\n     */\n    ComponentPortal.prototype.setAttachedHost = /**\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\n     * the PortalHost when it is performing an `attach()` or `detach()`.\n     * @param {?=} host\n     * @return {?}\n     */\n        function (host) {\n            this._attachedHost = host;\n        };\n    return ComponentPortal;\n}());\n/**\n * Partial implementation of PortalHost that only deals with attaching a\n * ComponentPortal\n * @abstract\n */\nvar /**\n * Partial implementation of PortalHost that only deals with attaching a\n * ComponentPortal\n * @abstract\n */ BasePortalHost = /** @class */ /*@__PURE__*/ (function () {\n    function BasePortalHost() {\n    }\n    /**\n     * @param {?} portal\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n    BasePortalHost.prototype.attach = /**\n     * @param {?} portal\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n        function (portal, newestOnTop) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal, newestOnTop);\n        };\n    /**\n     * @return {?}\n     */\n    BasePortalHost.prototype.detach = /**\n     * @return {?}\n     */\n        function () {\n            if (this._attachedPortal) {\n                this._attachedPortal.setAttachedHost();\n            }\n            this._attachedPortal = undefined;\n            if (this._disposeFn) {\n                this._disposeFn();\n                this._disposeFn = undefined;\n            }\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalHost.prototype.setDisposeFn = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._disposeFn = fn;\n        };\n    return BasePortalHost;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n *\n * This is the only part of the portal core that directly touches the DOM.\n */\nvar /**\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n *\n * This is the only part of the portal core that directly touches the DOM.\n */ DomPortalHost = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(DomPortalHost, _super);\n    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n    DomPortalHost.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @param {?} newestOnTop\n     * @return {?}\n     */\n        function (portal, newestOnTop) {\n            var _this = this;\n            /** @type {?} */\n            var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n            /** @type {?} */\n            var componentRef;\n            // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n            // for the component (in terms of Angular's component tree, not rendering).\n            // When the ViewContainerRef is missing, we use the factory to create the component directly\n            // and then manually attach the ChangeDetector for that component to the application (which\n            // happens automatically when using a ViewContainer).\n            componentRef = componentFactory.create(portal.injector);\n            // When creating a component outside of a ViewContainer, we need to manually register\n            // its ChangeDetector with the application. This API is unfortunately not yet published\n            // in Angular core. The change detector must also be deregistered when the component\n            // is destroyed to prevent memory leaks.\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(( /**\n             * @return {?}\n             */function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            }));\n            // At this point the component has been instantiated, so we move it to the location in the DOM\n            // where we want it to be rendered.\n            if (newestOnTop) {\n                this._hostDomElement.insertBefore(this._getComponentRootNode(componentRef), this._hostDomElement.firstChild);\n            }\n            else {\n                this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n            }\n            return componentRef;\n        };\n    /** Gets the root HTMLElement for an instantiated component. */\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @private\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalHost.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @private\n     * @param {?} componentRef\n     * @return {?}\n     */\n        function (componentRef) {\n            return ( /** @type {?} */((( /** @type {?} */(componentRef.hostView))).rootNodes[0]));\n        };\n    return DomPortalHost;\n}(BasePortalHost));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Container inside which all toasts will render.\n */\nvar OverlayContainer = /** @class */ /*@__PURE__*/ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._containerElement && this._containerElement.parentNode) {\n                this._containerElement.parentNode.removeChild(this._containerElement);\n            }\n        };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n        function () {\n            if (!this._containerElement) {\n                this._createContainer();\n            }\n            return this._containerElement;\n        };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @protected\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @protected\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var container = this._document.createElement('div');\n            container.classList.add('overlay-container');\n            this._document.body.appendChild(container);\n            this._containerElement = container;\n        };\n    /** @nocollapse */ OverlayContainer.ngInjectableDef = defineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(inject(DOCUMENT)); }, token: OverlayContainer, providedIn: \"root\" });\n    return OverlayContainer;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar /**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */ OverlayRef = /** @class */ /*@__PURE__*/ (function () {\n    function OverlayRef(_portalHost) {\n        this._portalHost = _portalHost;\n    }\n    /**\n     * @param {?} portal\n     * @param {?=} newestOnTop\n     * @return {?}\n     */\n    OverlayRef.prototype.attach = /**\n     * @param {?} portal\n     * @param {?=} newestOnTop\n     * @return {?}\n     */\n        function (portal, newestOnTop) {\n            if (newestOnTop === void 0) {\n                newestOnTop = true;\n            }\n            return this._portalHost.attach(portal, newestOnTop);\n        };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns Resolves when the overlay has been detached.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} Resolves when the overlay has been detached.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} Resolves when the overlay has been detached.\n     */\n        function () {\n            return this._portalHost.detach();\n        };\n    return OverlayRef;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\n */\nvar Overlay = /** @class */ /*@__PURE__*/ (function () {\n    function Overlay(_overlayContainer, _componentFactoryResolver, _appRef, _document) {\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._document = _document;\n        // Namespace panes by overlay container\n        this._paneElements = new Map();\n    }\n    /**\n     * Creates an overlay.\n     * @returns A reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} positionClass\n     * @param {?=} overlayContainer\n     * @return {?} A reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} positionClass\n     * @param {?=} overlayContainer\n     * @return {?} A reference to the created overlay.\n     */\n        function (positionClass, overlayContainer) {\n            // get existing pane if possible\n            return this._createOverlayRef(this.getPaneElement(positionClass, overlayContainer));\n        };\n    /**\n     * @param {?=} positionClass\n     * @param {?=} overlayContainer\n     * @return {?}\n     */\n    Overlay.prototype.getPaneElement = /**\n     * @param {?=} positionClass\n     * @param {?=} overlayContainer\n     * @return {?}\n     */\n        function (positionClass, overlayContainer) {\n            if (positionClass === void 0) {\n                positionClass = '';\n            }\n            if (!this._paneElements.get(overlayContainer)) {\n                this._paneElements.set(overlayContainer, {});\n            }\n            if (!this._paneElements.get(overlayContainer)[positionClass]) {\n                this._paneElements.get(overlayContainer)[positionClass] = this._createPaneElement(positionClass, overlayContainer);\n            }\n            return this._paneElements.get(overlayContainer)[positionClass];\n        };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @returns Newly-created pane element\n     */\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @private\n     * @param {?} positionClass\n     * @param {?=} overlayContainer\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @private\n     * @param {?} positionClass\n     * @param {?=} overlayContainer\n     * @return {?} Newly-created pane element\n     */\n        function (positionClass, overlayContainer) {\n            /** @type {?} */\n            var pane = this._document.createElement('div');\n            pane.id = 'toast-container';\n            pane.classList.add(positionClass);\n            pane.classList.add('toast-container');\n            if (!overlayContainer) {\n                this._overlayContainer.getContainerElement().appendChild(pane);\n            }\n            else {\n                overlayContainer.getContainerElement().appendChild(pane);\n            }\n            return pane;\n        };\n    /**\n     * Create a DomPortalHost into which the overlay content can be loaded.\n     * @param pane The DOM element to turn into a portal host.\n     * @returns A portal host for the given DOM element.\n     */\n    /**\n     * Create a DomPortalHost into which the overlay content can be loaded.\n     * @private\n     * @param {?} pane The DOM element to turn into a portal host.\n     * @return {?} A portal host for the given DOM element.\n     */\n    Overlay.prototype._createPortalHost = /**\n     * Create a DomPortalHost into which the overlay content can be loaded.\n     * @private\n     * @param {?} pane The DOM element to turn into a portal host.\n     * @return {?} A portal host for the given DOM element.\n     */\n        function (pane) {\n            return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef);\n        };\n    /**\n     * Creates an OverlayRef for an overlay in the given DOM element.\n     * @param pane DOM element for the overlay\n     */\n    /**\n     * Creates an OverlayRef for an overlay in the given DOM element.\n     * @private\n     * @param {?} pane DOM element for the overlay\n     * @return {?}\n     */\n    Overlay.prototype._createOverlayRef = /**\n     * Creates an OverlayRef for an overlay in the given DOM element.\n     * @private\n     * @param {?} pane DOM element for the overlay\n     * @return {?}\n     */\n        function (pane) {\n            return new OverlayRef(this._createPortalHost(pane));\n        };\n    /** @nocollapse */ Overlay.ngInjectableDef = defineInjectable({ factory: function Overlay_Factory() { return new Overlay(inject(OverlayContainer), inject(ComponentFactoryResolver), inject(ApplicationRef), inject(DOCUMENT)); }, token: Overlay, providedIn: \"root\" });\n    return Overlay;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Reference to a toast opened via the Toastr service.\n * @template T\n */\nvar /**\n * Reference to a toast opened via the Toastr service.\n * @template T\n */ ToastRef = /** @class */ /*@__PURE__*/ (function () {\n    function ToastRef(_overlayRef) {\n        this._overlayRef = _overlayRef;\n        /**\n         * Count of duplicates of this toast\n         */\n        this.duplicatesCount = 0;\n        /**\n         * Subject for notifying the user that the toast has finished closing.\n         */\n        this._afterClosed = new Subject();\n        /**\n         * triggered when toast is activated\n         */\n        this._activate = new Subject();\n        /**\n         * notifies the toast that it should close before the timeout\n         */\n        this._manualClose = new Subject();\n        /**\n         * notifies the toast that it should reset the timeouts\n         */\n        this._resetTimeout = new Subject();\n        /**\n         * notifies the toast that it should count a duplicate toast\n         */\n        this._countDuplicate = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.manualClose = /**\n     * @return {?}\n     */\n        function () {\n            this._manualClose.next();\n            this._manualClose.complete();\n        };\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.manualClosed = /**\n     * @return {?}\n     */\n        function () {\n            return this._manualClose.asObservable();\n        };\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.timeoutReset = /**\n     * @return {?}\n     */\n        function () {\n            return this._resetTimeout.asObservable();\n        };\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.countDuplicate = /**\n     * @return {?}\n     */\n        function () {\n            return this._countDuplicate.asObservable();\n        };\n    /**\n     * Close the toast.\n     */\n    /**\n     * Close the toast.\n     * @return {?}\n     */\n    ToastRef.prototype.close = /**\n     * Close the toast.\n     * @return {?}\n     */\n        function () {\n            this._overlayRef.detach();\n            this._afterClosed.next();\n            this._manualClose.next();\n            this._afterClosed.complete();\n            this._manualClose.complete();\n            this._activate.complete();\n            this._resetTimeout.complete();\n            this._countDuplicate.complete();\n        };\n    /** Gets an observable that is notified when the toast is finished closing. */\n    /**\n     * Gets an observable that is notified when the toast is finished closing.\n     * @return {?}\n     */\n    ToastRef.prototype.afterClosed = /**\n     * Gets an observable that is notified when the toast is finished closing.\n     * @return {?}\n     */\n        function () {\n            return this._afterClosed.asObservable();\n        };\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.isInactive = /**\n     * @return {?}\n     */\n        function () {\n            return this._activate.isStopped;\n        };\n    /**\n     * @return {?}\n     */\n    ToastRef.prototype.activate = /**\n     * @return {?}\n     */\n        function () {\n            this._activate.next();\n            this._activate.complete();\n        };\n    /** Gets an observable that is notified when the toast has started opening. */\n    /**\n     * Gets an observable that is notified when the toast has started opening.\n     * @return {?}\n     */\n    ToastRef.prototype.afterActivate = /**\n     * Gets an observable that is notified when the toast has started opening.\n     * @return {?}\n     */\n        function () {\n            return this._activate.asObservable();\n        };\n    /** Reset the toast timouts and count duplicates */\n    /**\n     * Reset the toast timouts and count duplicates\n     * @param {?} resetTimeout\n     * @param {?} countDuplicate\n     * @return {?}\n     */\n    ToastRef.prototype.onDuplicate = /**\n     * Reset the toast timouts and count duplicates\n     * @param {?} resetTimeout\n     * @param {?} countDuplicate\n     * @return {?}\n     */\n        function (resetTimeout, countDuplicate) {\n            if (resetTimeout) {\n                this._resetTimeout.next();\n            }\n            if (countDuplicate) {\n                this._countDuplicate.next(++this.duplicatesCount);\n            }\n        };\n    return ToastRef;\n}());\n/**\n * Custom injector type specifically for instantiating components with a toast.\n */\nvar /**\n * Custom injector type specifically for instantiating components with a toast.\n */ ToastInjector = /** @class */ /*@__PURE__*/ (function () {\n    function ToastInjector(_toastPackage, _parentInjector) {\n        this._toastPackage = _toastPackage;\n        this._parentInjector = _parentInjector;\n    }\n    /**\n     * @template T\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n    ToastInjector.prototype.get = /**\n     * @template T\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @param {?=} flags\n     * @return {?}\n     */\n        function (token, notFoundValue, flags) {\n            if (token === ToastPackage) {\n                return this._toastPackage;\n            }\n            return this._parentInjector.get(token, notFoundValue, flags);\n        };\n    return ToastInjector;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ToastrService = /** @class */ /*@__PURE__*/ (function () {\n    function ToastrService(token, overlay, _injector, sanitizer, ngZone) {\n        this.overlay = overlay;\n        this._injector = _injector;\n        this.sanitizer = sanitizer;\n        this.ngZone = ngZone;\n        this.currentlyActive = 0;\n        this.toasts = [];\n        this.index = 0;\n        this.toastrConfig = __assign({}, token.default, token.config);\n        if (token.config.iconClasses) {\n            this.toastrConfig.iconClasses = __assign({}, token.default.iconClasses, token.config.iconClasses);\n        }\n    }\n    /** show toast */\n    /**\n     * show toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @param {?=} type\n     * @return {?}\n     */\n    ToastrService.prototype.show = /**\n     * show toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @param {?=} type\n     * @return {?}\n     */\n        function (message, title, override, type) {\n            if (override === void 0) {\n                override = {};\n            }\n            if (type === void 0) {\n                type = '';\n            }\n            return this._preBuildNotification(type, message, title, this.applyConfig(override));\n        };\n    /** show successful toast */\n    /**\n     * show successful toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.success = /**\n     * show successful toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n        function (message, title, override) {\n            if (override === void 0) {\n                override = {};\n            }\n            /** @type {?} */\n            var type = this.toastrConfig.iconClasses.success || '';\n            return this._preBuildNotification(type, message, title, this.applyConfig(override));\n        };\n    /** show error toast */\n    /**\n     * show error toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.error = /**\n     * show error toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n        function (message, title, override) {\n            if (override === void 0) {\n                override = {};\n            }\n            /** @type {?} */\n            var type = this.toastrConfig.iconClasses.error || '';\n            return this._preBuildNotification(type, message, title, this.applyConfig(override));\n        };\n    /** show info toast */\n    /**\n     * show info toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.info = /**\n     * show info toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n        function (message, title, override) {\n            if (override === void 0) {\n                override = {};\n            }\n            /** @type {?} */\n            var type = this.toastrConfig.iconClasses.info || '';\n            return this._preBuildNotification(type, message, title, this.applyConfig(override));\n        };\n    /** show warning toast */\n    /**\n     * show warning toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.warning = /**\n     * show warning toast\n     * @param {?=} message\n     * @param {?=} title\n     * @param {?=} override\n     * @return {?}\n     */\n        function (message, title, override) {\n            if (override === void 0) {\n                override = {};\n            }\n            /** @type {?} */\n            var type = this.toastrConfig.iconClasses.warning || '';\n            return this._preBuildNotification(type, message, title, this.applyConfig(override));\n        };\n    /**\n     * Remove all or a single toast by id\n     */\n    /**\n     * Remove all or a single toast by id\n     * @param {?=} toastId\n     * @return {?}\n     */\n    ToastrService.prototype.clear = /**\n     * Remove all or a single toast by id\n     * @param {?=} toastId\n     * @return {?}\n     */\n        function (toastId) {\n            var e_1, _a;\n            try {\n                // Call every toastRef manualClose function\n                for (var _b = __values(this.toasts), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var toast = _c.value;\n                    if (toastId !== undefined) {\n                        if (toast.toastId === toastId) {\n                            toast.toastRef.manualClose();\n                            return;\n                        }\n                    }\n                    else {\n                        toast.toastRef.manualClose();\n                    }\n                }\n            }\n            catch (e_1_1) {\n                e_1 = { error: e_1_1 };\n            }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return))\n                        _a.call(_b);\n                }\n                finally {\n                    if (e_1)\n                        throw e_1.error;\n                }\n            }\n        };\n    /**\n     * Remove and destroy a single toast by id\n     */\n    /**\n     * Remove and destroy a single toast by id\n     * @param {?} toastId\n     * @return {?}\n     */\n    ToastrService.prototype.remove = /**\n     * Remove and destroy a single toast by id\n     * @param {?} toastId\n     * @return {?}\n     */\n        function (toastId) {\n            /** @type {?} */\n            var found = this._findToast(toastId);\n            if (!found) {\n                return false;\n            }\n            found.activeToast.toastRef.close();\n            this.toasts.splice(found.index, 1);\n            this.currentlyActive = this.currentlyActive - 1;\n            if (!this.toastrConfig.maxOpened || !this.toasts.length) {\n                return false;\n            }\n            if (this.currentlyActive < this.toastrConfig.maxOpened &&\n                this.toasts[this.currentlyActive]) {\n                /** @type {?} */\n                var p = this.toasts[this.currentlyActive].toastRef;\n                if (!p.isInactive()) {\n                    this.currentlyActive = this.currentlyActive + 1;\n                    p.activate();\n                }\n            }\n            return true;\n        };\n    /**\n     * Determines if toast message is already shown\n     */\n    /**\n     * Determines if toast message is already shown\n     * @param {?} message\n     * @param {?} resetOnDuplicate\n     * @param {?} countDuplicates\n     * @return {?}\n     */\n    ToastrService.prototype.findDuplicate = /**\n     * Determines if toast message is already shown\n     * @param {?} message\n     * @param {?} resetOnDuplicate\n     * @param {?} countDuplicates\n     * @return {?}\n     */\n        function (message, resetOnDuplicate, countDuplicates) {\n            for (var i = 0; i < this.toasts.length; i++) {\n                /** @type {?} */\n                var toast = this.toasts[i];\n                if (toast.message === message) {\n                    toast.toastRef.onDuplicate(resetOnDuplicate, countDuplicates);\n                    return toast;\n                }\n            }\n            return null;\n        };\n    /** create a clone of global config and apply individual settings */\n    /**\n     * create a clone of global config and apply individual settings\n     * @private\n     * @param {?=} override\n     * @return {?}\n     */\n    ToastrService.prototype.applyConfig = /**\n     * create a clone of global config and apply individual settings\n     * @private\n     * @param {?=} override\n     * @return {?}\n     */\n        function (override) {\n            if (override === void 0) {\n                override = {};\n            }\n            return __assign({}, this.toastrConfig, override);\n        };\n    /**\n     * Find toast object by id\n     */\n    /**\n     * Find toast object by id\n     * @private\n     * @param {?} toastId\n     * @return {?}\n     */\n    ToastrService.prototype._findToast = /**\n     * Find toast object by id\n     * @private\n     * @param {?} toastId\n     * @return {?}\n     */\n        function (toastId) {\n            for (var i = 0; i < this.toasts.length; i++) {\n                if (this.toasts[i].toastId === toastId) {\n                    return { index: i, activeToast: this.toasts[i] };\n                }\n            }\n            return null;\n        };\n    /**\n     * Determines the need to run inside angular's zone then builds the toast\n     */\n    /**\n     * Determines the need to run inside angular's zone then builds the toast\n     * @private\n     * @param {?} toastType\n     * @param {?} message\n     * @param {?} title\n     * @param {?} config\n     * @return {?}\n     */\n    ToastrService.prototype._preBuildNotification = /**\n     * Determines the need to run inside angular's zone then builds the toast\n     * @private\n     * @param {?} toastType\n     * @param {?} message\n     * @param {?} title\n     * @param {?} config\n     * @return {?}\n     */\n        function (toastType, message, title, config) {\n            var _this = this;\n            if (config.onActivateTick) {\n                return this.ngZone.run(( /**\n                 * @return {?}\n                 */function () {\n                    return _this._buildNotification(toastType, message, title, config);\n                }));\n            }\n            return this._buildNotification(toastType, message, title, config);\n        };\n    /**\n     * Creates and attaches toast data to component\n     * returns the active toast, or in case preventDuplicates is enabled the original/non-duplicate active toast.\n     */\n    /**\n     * Creates and attaches toast data to component\n     * returns the active toast, or in case preventDuplicates is enabled the original/non-duplicate active toast.\n     * @private\n     * @param {?} toastType\n     * @param {?} message\n     * @param {?} title\n     * @param {?} config\n     * @return {?}\n     */\n    ToastrService.prototype._buildNotification = /**\n     * Creates and attaches toast data to component\n     * returns the active toast, or in case preventDuplicates is enabled the original/non-duplicate active toast.\n     * @private\n     * @param {?} toastType\n     * @param {?} message\n     * @param {?} title\n     * @param {?} config\n     * @return {?}\n     */\n        function (toastType, message, title, config) {\n            var _this = this;\n            if (!config.toastComponent) {\n                throw new Error('toastComponent required');\n            }\n            // max opened and auto dismiss = true\n            /** @type {?} */\n            var duplicate = this.findDuplicate(message, this.toastrConfig.resetTimeoutOnDuplicate, this.toastrConfig.countDuplicates);\n            if (message && this.toastrConfig.preventDuplicates && duplicate !== null) {\n                return duplicate;\n            }\n            this.previousToastMessage = message;\n            /** @type {?} */\n            var keepInactive = false;\n            if (this.toastrConfig.maxOpened &&\n                this.currentlyActive >= this.toastrConfig.maxOpened) {\n                keepInactive = true;\n                if (this.toastrConfig.autoDismiss) {\n                    this.clear(this.toasts[0].toastId);\n                }\n            }\n            /** @type {?} */\n            var overlayRef = this.overlay.create(config.positionClass, this.overlayContainer);\n            this.index = this.index + 1;\n            /** @type {?} */\n            var sanitizedMessage = message;\n            if (message && config.enableHtml) {\n                sanitizedMessage = this.sanitizer.sanitize(SecurityContext.HTML, message);\n            }\n            /** @type {?} */\n            var toastRef = new ToastRef(overlayRef);\n            /** @type {?} */\n            var toastPackage = new ToastPackage(this.index, config, sanitizedMessage, title, toastType, toastRef);\n            /** @type {?} */\n            var toastInjector = new ToastInjector(toastPackage, this._injector);\n            /** @type {?} */\n            var component = new ComponentPortal(config.toastComponent, toastInjector);\n            /** @type {?} */\n            var portal = overlayRef.attach(component, this.toastrConfig.newestOnTop);\n            toastRef.componentInstance = (( /** @type {?} */(portal)))._component;\n            /** @type {?} */\n            var ins = {\n                toastId: this.index,\n                message: message || '',\n                toastRef: toastRef,\n                onShown: toastRef.afterActivate(),\n                onHidden: toastRef.afterClosed(),\n                onTap: toastPackage.onTap(),\n                onAction: toastPackage.onAction(),\n                portal: portal\n            };\n            if (!keepInactive) {\n                setTimeout(( /**\n                 * @return {?}\n                 */function () {\n                    ins.toastRef.activate();\n                    _this.currentlyActive = _this.currentlyActive + 1;\n                }));\n            }\n            this.toasts.push(ins);\n            return ins;\n        };\n    /** @nocollapse */ ToastrService.ngInjectableDef = defineInjectable({ factory: function ToastrService_Factory() { return new ToastrService(inject(TOAST_CONFIG), inject(Overlay), inject(INJECTOR), inject(DomSanitizer), inject(NgZone)); }, token: ToastrService, providedIn: \"root\" });\n    return ToastrService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Toast = /** @class */ /*@__PURE__*/ (function () {\n    function Toast(toastrService, toastPackage, ngZone) {\n        var _this = this;\n        this.toastrService = toastrService;\n        this.toastPackage = toastPackage;\n        this.ngZone = ngZone;\n        /**\n         * width of progress bar\n         */\n        this.width = -1;\n        /**\n         * a combination of toast type and options.toastClass\n         */\n        this.toastClasses = '';\n        /**\n         * controls animation\n         */\n        this.state = {\n            value: 'inactive',\n            params: {\n                easeTime: this.toastPackage.config.easeTime,\n                easing: 'ease-in'\n            }\n        };\n        this.message = toastPackage.message;\n        this.title = toastPackage.title;\n        this.options = toastPackage.config;\n        this.originalTimeout = toastPackage.config.timeOut;\n        this.toastClasses = toastPackage.toastType + \" \" + toastPackage.config.toastClass;\n        this.sub = toastPackage.toastRef.afterActivate().subscribe(( /**\n         * @return {?}\n         */function () {\n            _this.activateToast();\n        }));\n        this.sub1 = toastPackage.toastRef.manualClosed().subscribe(( /**\n         * @return {?}\n         */function () {\n            _this.remove();\n        }));\n        this.sub2 = toastPackage.toastRef.timeoutReset().subscribe(( /**\n         * @return {?}\n         */function () {\n            _this.resetTimeout();\n        }));\n        this.sub3 = toastPackage.toastRef.countDuplicate().subscribe(( /**\n         * @param {?} count\n         * @return {?}\n         */function (count) {\n            _this.duplicatesCount = count;\n        }));\n    }\n    Object.defineProperty(Toast.prototype, \"displayStyle\", {\n        /** hides component when waiting to be displayed */\n        get: /**\n         * hides component when waiting to be displayed\n         * @return {?}\n         */ function () {\n            if (this.state.value === 'inactive') {\n                return 'none';\n            }\n            return 'inherit';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    Toast.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.sub.unsubscribe();\n            this.sub1.unsubscribe();\n            this.sub2.unsubscribe();\n            this.sub3.unsubscribe();\n            clearInterval(this.intervalId);\n            clearTimeout(this.timeout);\n        };\n    /**\n     * activates toast and sets timeout\n     */\n    /**\n     * activates toast and sets timeout\n     * @return {?}\n     */\n    Toast.prototype.activateToast = /**\n     * activates toast and sets timeout\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.state = __assign({}, this.state, { value: 'active' });\n            if (!this.options.disableTimeOut && this.options.timeOut) {\n                this.outsideTimeout(( /**\n                 * @return {?}\n                 */function () { return _this.remove(); }), this.options.timeOut);\n                this.hideTime = new Date().getTime() + this.options.timeOut;\n                if (this.options.progressBar) {\n                    this.outsideInterval(( /**\n                     * @return {?}\n                     */function () { return _this.updateProgress(); }), 10);\n                }\n            }\n        };\n    /**\n     * updates progress bar width\n     */\n    /**\n     * updates progress bar width\n     * @return {?}\n     */\n    Toast.prototype.updateProgress = /**\n     * updates progress bar width\n     * @return {?}\n     */\n        function () {\n            if (this.width === 0 || this.width === 100 || !this.options.timeOut) {\n                return;\n            }\n            /** @type {?} */\n            var now = new Date().getTime();\n            /** @type {?} */\n            var remaining = this.hideTime - now;\n            this.width = (remaining / this.options.timeOut) * 100;\n            if (this.options.progressAnimation === 'increasing') {\n                this.width = 100 - this.width;\n            }\n            if (this.width <= 0) {\n                this.width = 0;\n            }\n            if (this.width >= 100) {\n                this.width = 100;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    Toast.prototype.resetTimeout = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            clearTimeout(this.timeout);\n            clearInterval(this.intervalId);\n            this.state = __assign({}, this.state, { value: 'active' });\n            this.outsideTimeout(( /**\n             * @return {?}\n             */function () { return _this.remove(); }), this.originalTimeout);\n            this.options.timeOut = this.originalTimeout;\n            this.hideTime = new Date().getTime() + (this.options.timeOut || 0);\n            this.width = -1;\n            if (this.options.progressBar) {\n                this.outsideInterval(( /**\n                 * @return {?}\n                 */function () { return _this.updateProgress(); }), 10);\n            }\n        };\n    /**\n     * tells toastrService to remove this toast after animation time\n     */\n    /**\n     * tells toastrService to remove this toast after animation time\n     * @return {?}\n     */\n    Toast.prototype.remove = /**\n     * tells toastrService to remove this toast after animation time\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.state.value === 'removed') {\n                return;\n            }\n            clearTimeout(this.timeout);\n            this.state = __assign({}, this.state, { value: 'removed' });\n            this.outsideTimeout(( /**\n             * @return {?}\n             */function () { return _this.toastrService.remove(_this.toastPackage.toastId); }), +this.toastPackage.config.easeTime);\n        };\n    /**\n     * @return {?}\n     */\n    Toast.prototype.tapToast = /**\n     * @return {?}\n     */\n        function () {\n            if (this.state.value === 'removed') {\n                return;\n            }\n            this.toastPackage.triggerTap();\n            if (this.options.tapToDismiss) {\n                this.remove();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    Toast.prototype.stickAround = /**\n     * @return {?}\n     */\n        function () {\n            if (this.state.value === 'removed') {\n                return;\n            }\n            clearTimeout(this.timeout);\n            this.options.timeOut = 0;\n            this.hideTime = 0;\n            // disable progressBar\n            clearInterval(this.intervalId);\n            this.width = 0;\n        };\n    /**\n     * @return {?}\n     */\n    Toast.prototype.delayedHideToast = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.options.disableTimeOut ||\n                this.options.extendedTimeOut === 0 ||\n                this.state.value === 'removed') {\n                return;\n            }\n            this.outsideTimeout(( /**\n             * @return {?}\n             */function () { return _this.remove(); }), this.options.extendedTimeOut);\n            this.options.timeOut = this.options.extendedTimeOut;\n            this.hideTime = new Date().getTime() + (this.options.timeOut || 0);\n            this.width = -1;\n            if (this.options.progressBar) {\n                this.outsideInterval(( /**\n                 * @return {?}\n                 */function () { return _this.updateProgress(); }), 10);\n            }\n        };\n    /**\n     * @param {?} func\n     * @param {?} timeout\n     * @return {?}\n     */\n    Toast.prototype.outsideTimeout = /**\n     * @param {?} func\n     * @param {?} timeout\n     * @return {?}\n     */\n        function (func, timeout) {\n            var _this = this;\n            if (this.ngZone) {\n                this.ngZone.runOutsideAngular(( /**\n                 * @return {?}\n                 */function () {\n                    return (_this.timeout = setTimeout(( /**\n                     * @return {?}\n                     */function () { return _this.runInsideAngular(func); }), timeout));\n                }));\n            }\n            else {\n                this.timeout = setTimeout(( /**\n                 * @return {?}\n                 */function () { return func(); }), timeout);\n            }\n        };\n    /**\n     * @param {?} func\n     * @param {?} timeout\n     * @return {?}\n     */\n    Toast.prototype.outsideInterval = /**\n     * @param {?} func\n     * @param {?} timeout\n     * @return {?}\n     */\n        function (func, timeout) {\n            var _this = this;\n            if (this.ngZone) {\n                this.ngZone.runOutsideAngular(( /**\n                 * @return {?}\n                 */function () {\n                    return (_this.intervalId = setInterval(( /**\n                     * @return {?}\n                     */function () { return _this.runInsideAngular(func); }), timeout));\n                }));\n            }\n            else {\n                this.intervalId = setInterval(( /**\n                 * @return {?}\n                 */function () { return func(); }), timeout);\n            }\n        };\n    /**\n     * @private\n     * @param {?} func\n     * @return {?}\n     */\n    Toast.prototype.runInsideAngular = /**\n     * @private\n     * @param {?} func\n     * @return {?}\n     */\n        function (func) {\n            if (this.ngZone) {\n                this.ngZone.run(( /**\n                 * @return {?}\n                 */function () { return func(); }));\n            }\n            else {\n                func();\n            }\n        };\n    return Toast;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar DefaultGlobalConfig = /*@__PURE__*/ __assign({}, DefaultNoComponentGlobalConfig, { toastComponent: Toast });\nvar ToastrModule = /** @class */ /*@__PURE__*/ (function () {\n    function ToastrModule() {\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    ToastrModule.forRoot = /**\n     * @param {?=} config\n     * @return {?}\n     */\n        function (config) {\n            if (config === void 0) {\n                config = {};\n            }\n            return {\n                ngModule: ToastrModule,\n                providers: [\n                    {\n                        provide: TOAST_CONFIG,\n                        useValue: {\n                            default: DefaultGlobalConfig,\n                            config: config,\n                        },\n                    },\n                ],\n            };\n        };\n    return ToastrModule;\n}());\nvar ToastrComponentlessModule = /** @class */ /*@__PURE__*/ (function () {\n    function ToastrComponentlessModule() {\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    ToastrComponentlessModule.forRoot = /**\n     * @param {?=} config\n     * @return {?}\n     */\n        function (config) {\n            if (config === void 0) {\n                config = {};\n            }\n            return {\n                ngModule: ToastrModule,\n                providers: [\n                    {\n                        provide: TOAST_CONFIG,\n                        useValue: {\n                            default: DefaultNoComponentGlobalConfig,\n                            config: config,\n                        },\n                    },\n                ],\n            };\n        };\n    return ToastrComponentlessModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ToastNoAnimation = /** @class */ /*@__PURE__*/ (function () {\n    function ToastNoAnimation(toastrService, toastPackage, appRef) {\n        var _this = this;\n        this.toastrService = toastrService;\n        this.toastPackage = toastPackage;\n        this.appRef = appRef;\n        /**\n         * width of progress bar\n         */\n        this.width = -1;\n        /**\n         * a combination of toast type and options.toastClass\n         */\n        this.toastClasses = '';\n        /**\n         * controls animation\n         */\n        this.state = 'inactive';\n        this.message = toastPackage.message;\n        this.title = toastPackage.title;\n        this.options = toastPackage.config;\n        this.originalTimeout = toastPackage.config.timeOut;\n        this.toastClasses = toastPackage.toastType + \" \" + toastPackage.config.toastClass;\n        this.sub = toastPackage.toastRef.afterActivate().subscribe(( /**\n         * @return {?}\n         */function () {\n            _this.activateToast();\n        }));\n        this.sub1 = toastPackage.toastRef.manualClosed().subscribe(( /**\n         * @return {?}\n         */function () {\n            _this.remove();\n        }));\n        this.sub2 = toastPackage.toastRef.timeoutReset().subscribe(( /**\n         * @return {?}\n         */function () {\n            _this.resetTimeout();\n        }));\n        this.sub3 = toastPackage.toastRef.countDuplicate().subscribe(( /**\n         * @param {?} count\n         * @return {?}\n         */function (count) {\n            _this.duplicatesCount = count;\n        }));\n    }\n    Object.defineProperty(ToastNoAnimation.prototype, \"displayStyle\", {\n        /** hides component when waiting to be displayed */\n        get: /**\n         * hides component when waiting to be displayed\n         * @return {?}\n         */ function () {\n            if (this.state === 'inactive') {\n                return 'none';\n            }\n            return 'inherit';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.sub.unsubscribe();\n            this.sub1.unsubscribe();\n            this.sub2.unsubscribe();\n            this.sub3.unsubscribe();\n            clearInterval(this.intervalId);\n            clearTimeout(this.timeout);\n        };\n    /**\n     * activates toast and sets timeout\n     */\n    /**\n     * activates toast and sets timeout\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.activateToast = /**\n     * activates toast and sets timeout\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.state = 'active';\n            if (!this.options.disableTimeOut && this.options.timeOut) {\n                this.timeout = setTimeout(( /**\n                 * @return {?}\n                 */function () {\n                    _this.remove();\n                }), this.options.timeOut);\n                this.hideTime = new Date().getTime() + this.options.timeOut;\n                if (this.options.progressBar) {\n                    this.intervalId = setInterval(( /**\n                     * @return {?}\n                     */function () { return _this.updateProgress(); }), 10);\n                }\n            }\n            if (this.options.onActivateTick) {\n                this.appRef.tick();\n            }\n        };\n    /**\n     * updates progress bar width\n     */\n    /**\n     * updates progress bar width\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.updateProgress = /**\n     * updates progress bar width\n     * @return {?}\n     */\n        function () {\n            if (this.width === 0 || this.width === 100 || !this.options.timeOut) {\n                return;\n            }\n            /** @type {?} */\n            var now = new Date().getTime();\n            /** @type {?} */\n            var remaining = this.hideTime - now;\n            this.width = (remaining / this.options.timeOut) * 100;\n            if (this.options.progressAnimation === 'increasing') {\n                this.width = 100 - this.width;\n            }\n            if (this.width <= 0) {\n                this.width = 0;\n            }\n            if (this.width >= 100) {\n                this.width = 100;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.resetTimeout = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            clearTimeout(this.timeout);\n            clearInterval(this.intervalId);\n            this.state = 'active';\n            this.options.timeOut = this.originalTimeout;\n            this.timeout = setTimeout(( /**\n             * @return {?}\n             */function () { return _this.remove(); }), this.originalTimeout);\n            this.hideTime = new Date().getTime() + (this.originalTimeout || 0);\n            this.width = -1;\n            if (this.options.progressBar) {\n                this.intervalId = setInterval(( /**\n                 * @return {?}\n                 */function () { return _this.updateProgress(); }), 10);\n            }\n        };\n    /**\n     * tells toastrService to remove this toast after animation time\n     */\n    /**\n     * tells toastrService to remove this toast after animation time\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.remove = /**\n     * tells toastrService to remove this toast after animation time\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.state === 'removed') {\n                return;\n            }\n            clearTimeout(this.timeout);\n            this.state = 'removed';\n            this.timeout = setTimeout(( /**\n             * @return {?}\n             */function () {\n                return _this.toastrService.remove(_this.toastPackage.toastId);\n            }));\n        };\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.tapToast = /**\n     * @return {?}\n     */\n        function () {\n            if (this.state === 'removed') {\n                return;\n            }\n            this.toastPackage.triggerTap();\n            if (this.options.tapToDismiss) {\n                this.remove();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.stickAround = /**\n     * @return {?}\n     */\n        function () {\n            if (this.state === 'removed') {\n                return;\n            }\n            clearTimeout(this.timeout);\n            this.options.timeOut = 0;\n            this.hideTime = 0;\n            // disable progressBar\n            clearInterval(this.intervalId);\n            this.width = 0;\n        };\n    /**\n     * @return {?}\n     */\n    ToastNoAnimation.prototype.delayedHideToast = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.options.disableTimeOut ||\n                this.options.extendedTimeOut === 0 ||\n                this.state === 'removed') {\n                return;\n            }\n            this.timeout = setTimeout(( /**\n             * @return {?}\n             */function () { return _this.remove(); }), this.options.extendedTimeOut);\n            this.options.timeOut = this.options.extendedTimeOut;\n            this.hideTime = new Date().getTime() + (this.options.timeOut || 0);\n            this.width = -1;\n            if (this.options.progressBar) {\n                this.intervalId = setInterval(( /**\n                 * @return {?}\n                 */function () { return _this.updateProgress(); }), 10);\n            }\n        };\n    return ToastNoAnimation;\n}());\n/** @type {?} */\nvar DefaultNoAnimationsGlobalConfig = /*@__PURE__*/ __assign({}, DefaultNoComponentGlobalConfig, { toastComponent: ToastNoAnimation });\nvar ToastNoAnimationModule = /** @class */ /*@__PURE__*/ (function () {\n    function ToastNoAnimationModule() {\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    ToastNoAnimationModule.forRoot = /**\n     * @param {?=} config\n     * @return {?}\n     */\n        function (config) {\n            if (config === void 0) {\n                config = {};\n            }\n            return {\n                ngModule: ToastNoAnimationModule,\n                providers: [\n                    {\n                        provide: TOAST_CONFIG,\n                        useValue: {\n                            default: DefaultNoAnimationsGlobalConfig,\n                            config: config,\n                        },\n                    },\n                ],\n            };\n        };\n    return ToastNoAnimationModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nexport { ToastContainerDirective, ToastContainerModule, Toast, ToastrService, ToastPackage, DefaultNoComponentGlobalConfig, TOAST_CONFIG, DefaultGlobalConfig, ToastrModule, ToastrComponentlessModule, ToastRef, ToastInjector, ToastNoAnimation, DefaultNoAnimationsGlobalConfig, ToastNoAnimationModule, ComponentPortal, BasePortalHost, Overlay, OverlayContainer, OverlayRef };\n//# sourceMappingURL=ngx-toastr.js.map\n",null]}