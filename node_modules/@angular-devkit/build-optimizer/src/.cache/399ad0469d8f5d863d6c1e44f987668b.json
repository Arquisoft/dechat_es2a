{"remainingRequest":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\drawer.es5.js","dependencies":[{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\drawer.es5.js","mtime":1556004096876},{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1556004112812},{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1556004088045}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright (c) 2018 Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\n/** PURE_IMPORTS_START _angular_core,_angular_mdc_web_common PURE_IMPORTS_END */\nimport { Directive, ElementRef, HostBinding, Input, ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Output, Renderer2, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { isBrowser, EventRegistry } from '@angular-mdc/web/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MdcDrawerSpacer = /** @class */ /*@__PURE__*/ (function () {\n    function MdcDrawerSpacer(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n    }\n    return MdcDrawerSpacer;\n}());\nvar MdcDrawerHeader = /** @class */ /*@__PURE__*/ (function () {\n    function MdcDrawerHeader(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n    }\n    return MdcDrawerHeader;\n}());\nvar MdcDrawerHeaderContent = /** @class */ /*@__PURE__*/ (function () {\n    function MdcDrawerHeaderContent(elementRef) {\n        this.elementRef = elementRef;\n        this.primary = true;\n        this.isHostClass = true;\n    }\n    Object.defineProperty(MdcDrawerHeaderContent.prototype, \"classPrimaryBackground\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.primary ? 'mdc-theme--primary-bg' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcDrawerHeaderContent.prototype, \"classPrimaryOnPrimary\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.primary ? 'mdc-theme--text-primary-on-primary' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return MdcDrawerHeaderContent;\n}());\nvar MdcDrawerContent = /** @class */ /*@__PURE__*/ (function () {\n    function MdcDrawerContent(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n    }\n    return MdcDrawerContent;\n}());\nvar MdcDrawerNavigation = /** @class */ /*@__PURE__*/ (function () {\n    function MdcDrawerNavigation(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n        this.role = 'navigation';\n    }\n    return MdcDrawerNavigation;\n}());\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar TAB_DATA = 'data-mdc-tabindex';\nvar TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';\nvar storedTransformPropertyName_;\nvar supportsPassive_; // Remap touch events to pointer events, if the browser doesn't support touch events.\nfunction remapEvent(eventName) {\n    var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n    if (!('ontouchstart' in globalObj.document)) {\n        switch (eventName) {\n            case 'touchstart':\n                return 'pointerdown';\n            case 'touchmove':\n                return 'pointermove';\n            case 'touchend':\n                return 'pointerup';\n            default:\n                return eventName;\n        }\n    }\n    return eventName;\n} // Choose the correct transform property to use on the current browser.\nfunction getTransformPropertyName() {\n    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (storedTransformPropertyName_ === undefined || forceRefresh) {\n        var el = globalObj.document.createElement('div');\n        var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';\n        storedTransformPropertyName_ = transformPropertyName;\n    }\n    return storedTransformPropertyName_;\n} // Determine whether the current browser supports CSS properties.\nfunction supportsCssCustomProperties() {\n    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n    if ('CSS' in globalObj) {\n        return globalObj.CSS.supports('(--color: red)');\n    }\n    return false;\n} // Determine whether the current browser supports passive event listeners, and if so, use them.\nfunction applyPassive() {\n    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (supportsPassive_ === undefined || forceRefresh) {\n        var isSupported = false;\n        try {\n            globalObj.document.addEventListener('test', null, {\n                get passive() {\n                    isSupported = true;\n                }\n            });\n        }\n        catch (e) { }\n        supportsPassive_ = isSupported;\n    }\n    return supportsPassive_ ? {\n        passive: true\n    } : false;\n} // Save the tab state for an element.\nfunction saveElementTabState(el) {\n    if (el.hasAttribute('tabindex')) {\n        el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));\n    }\n    el.setAttribute(TAB_DATA_HANDLED, true);\n} // Restore the tab state for an element, if it was saved.\nfunction restoreElementTabState(el) {\n    // Only modify elements we've already handled, in case anything was dynamically added since we saved state.\n    if (el.hasAttribute(TAB_DATA_HANDLED)) {\n        if (el.hasAttribute(TAB_DATA)) {\n            el.setAttribute('tabindex', el.getAttribute(TAB_DATA));\n            el.removeAttribute(TAB_DATA);\n        }\n        else {\n            el.removeAttribute('tabindex');\n        }\n        el.removeAttribute(TAB_DATA_HANDLED);\n    }\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _get(object, property, receiver) {\n    if (object === null)\n        object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);\n        if (parent === null) {\n            return undefined;\n        }\n        else {\n            return _get(parent, property, receiver);\n        }\n    }\n    else if (\"value\" in desc) {\n        return desc.value;\n    }\n    else {\n        var getter = desc.get;\n        if (getter === undefined) {\n            return undefined;\n        }\n        return getter.call(receiver);\n    }\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass)\n        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @template A\n */\nvar MDCFoundation = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    _createClass(MDCFoundation, null, [{\n            key: \"cssClasses\",\n            /** @return enum{cssClasses} */\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports every\n                // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}\n                return {};\n            }\n            /** @return enum{strings} */\n        }, {\n            key: \"strings\",\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports all\n                // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}\n                return {};\n            }\n            /** @return enum{numbers} */\n        }, {\n            key: \"numbers\",\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports all\n                // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n                return {};\n            }\n            /** @return {!Object} */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n                // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n                // validation.\n                return {};\n            }\n            /**\n             * @param {A=} adapter\n             */\n        }]);\n    function MDCFoundation() {\n        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, MDCFoundation);\n        /** @protected {!A} */\n        this.adapter_ = adapter;\n    }\n    _createClass(MDCFoundation, [{\n            key: \"init\",\n            value: function init() {\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n            }\n        }]);\n    return MDCFoundation;\n}();\n/**\n * @template F\n */\nvar MDCComponent = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    _createClass(MDCComponent, null, [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCComponent}\n             */\n            value: function attachTo(root) {\n                // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and\n                // returns an instantiated component with its root set to that element. Also note that in the cases of\n                // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized\n                // from getDefaultFoundation().\n                return new MDCComponent(root, new MDCFoundation());\n            }\n            /**\n             * @param {!Element} root\n             * @param {F=} foundation\n             * @param {...?} args\n             */\n        }]);\n    function MDCComponent(root) {\n        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        _classCallCheck(this, MDCComponent);\n        /** @protected {!Element} */\n        this.root_ = root;\n        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n            args[_key - 2] = arguments[_key];\n        }\n        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that\n        // this.root_ is defined and can be used within the foundation class.\n        /** @protected {!F} */\n        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;\n        this.foundation_.init();\n        this.initialSyncWithDOM();\n    }\n    _createClass(MDCComponent, [{\n            key: \"initialize\",\n            value: function initialize() { } // Subclasses can override this to do any additional setup work that would be considered part of a\n            // \"constructor\". Essentially, it is a hook into the parent constructor before the foundation is\n            // initialized. Any additional arguments besides root and foundation will be passed in here.\n            /**\n             * @return {!F} foundation\n             */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                // Subclasses must override this method to return a properly configured foundation class for the\n                // component.\n                throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');\n            }\n        }, {\n            key: \"initialSyncWithDOM\",\n            value: function initialSyncWithDOM() {\n                // object. An example of this would be a form control wrapper that needs to synchronize its internal state\n                // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM\n                // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                // Subclasses may implement this method to release any resources / deregister any listeners they have\n                // attached. An example of this might be deregistering a resize event from the window object.\n                this.foundation_.destroy();\n            }\n            /**\n             * Wrapper method to add an event listener to the component's root element. This is most useful when\n             * listening for custom events.\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"listen\",\n            value: function listen(evtType, handler) {\n                this.root_.addEventListener(evtType, handler);\n            }\n            /**\n             * Wrapper method to remove an event listener to the component's root element. This is most useful when\n             * unlistening for custom events.\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"unlisten\",\n            value: function unlisten(evtType, handler) {\n                this.root_.removeEventListener(evtType, handler);\n            }\n            /**\n             * Fires a cross-browser-compatible custom event from the component root of the given type,\n             * with the given data.\n             * @param {string} evtType\n             * @param {!Object} evtData\n             * @param {boolean=} shouldBubble\n             */\n        }, {\n            key: \"emit\",\n            value: function emit(evtType, evtData) {\n                var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var evt;\n                if (typeof CustomEvent === 'function') {\n                    evt = new CustomEvent(evtType, {\n                        detail: evtData,\n                        bubbles: shouldBubble\n                    });\n                }\n                else {\n                    evt = document.createEvent('CustomEvent');\n                    evt.initCustomEvent(evtType, shouldBubble, false, evtData);\n                }\n                this.root_.dispatchEvent(evt);\n            }\n        }]);\n    return MDCComponent;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';\nvar MDCSlidableDrawerFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCSlidableDrawerFoundation, _MDCFoundation);\n    _createClass(MDCSlidableDrawerFoundation, null, [{\n            key: \"defaultAdapter\",\n            get: function get() {\n                return {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    hasClass: function hasClass() { },\n                    hasNecessaryDom: function hasNecessaryDom() {\n                        return (\n                        /* boolean */\n                        false);\n                    },\n                    registerInteractionHandler: function registerInteractionHandler() { },\n                    deregisterInteractionHandler: function deregisterInteractionHandler() { },\n                    registerDrawerInteractionHandler: function registerDrawerInteractionHandler() { },\n                    deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() { },\n                    registerTransitionEndHandler: function registerTransitionEndHandler() { },\n                    deregisterTransitionEndHandler: function deregisterTransitionEndHandler() { },\n                    registerDocumentKeydownHandler: function registerDocumentKeydownHandler() { },\n                    deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() { },\n                    setTranslateX: function setTranslateX() { },\n                    getFocusableElements: function getFocusableElements() { },\n                    saveElementTabState: function saveElementTabState() { },\n                    restoreElementTabState: function restoreElementTabState() { },\n                    makeElementUntabbable: function makeElementUntabbable() { },\n                    notifyOpen: function notifyOpen() { },\n                    notifyClose: function notifyClose() { },\n                    isRtl: function isRtl() {\n                        return (\n                        /* boolean */\n                        false);\n                    },\n                    getDrawerWidth: function getDrawerWidth() {\n                        return (\n                        /* number */\n                        0);\n                    }\n                };\n            }\n        }]);\n    function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {\n        var _this;\n        _classCallCheck(this, MDCSlidableDrawerFoundation);\n        _this = _possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));\n        _this.rootCssClass_ = rootCssClass;\n        _this.animatingCssClass_ = animatingCssClass;\n        _this.openCssClass_ = openCssClass;\n        _this.transitionEndHandler_ = function (evt) {\n            return _this.handleTransitionEnd_(evt);\n        };\n        _this.inert_ = false;\n        _this.componentTouchStartHandler_ = function (evt) {\n            return _this.handleTouchStart_(evt);\n        };\n        _this.componentTouchMoveHandler_ = function (evt) {\n            return _this.handleTouchMove_(evt);\n        };\n        _this.componentTouchEndHandler_ = function (evt) {\n            return _this.handleTouchEnd_(evt);\n        };\n        _this.documentKeydownHandler_ = function (evt) {\n            if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {\n                _this.close();\n            }\n        };\n        return _this;\n    }\n    _createClass(MDCSlidableDrawerFoundation, [{\n            key: \"init\",\n            value: function init() {\n                var ROOT = this.rootCssClass_;\n                var OPEN = this.openCssClass_;\n                if (!this.adapter_.hasClass(ROOT)) {\n                    throw new Error(\"\".concat(ROOT, \" class required in root element.\"));\n                }\n                if (!this.adapter_.hasNecessaryDom()) {\n                    throw new Error(\"Required DOM nodes missing in \".concat(ROOT, \" component.\"));\n                }\n                if (this.adapter_.hasClass(OPEN)) {\n                    this.isOpen_ = true;\n                }\n                else {\n                    this.detabinate_();\n                    this.isOpen_ = false;\n                }\n                this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);\n                this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);\n                this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);\n                this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);\n                this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_); // Deregister the document keydown handler just in case the component is destroyed while the menu is open.\n                this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);\n            }\n        }, {\n            key: \"open\",\n            value: function open() {\n                this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);\n                this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);\n                this.adapter_.addClass(this.animatingCssClass_);\n                this.adapter_.addClass(this.openCssClass_);\n                this.retabinate_(); // Debounce multiple calls\n                if (!this.isOpen_) {\n                    this.adapter_.notifyOpen();\n                }\n                this.isOpen_ = true;\n            }\n        }, {\n            key: \"close\",\n            value: function close() {\n                this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);\n                this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);\n                this.adapter_.addClass(this.animatingCssClass_);\n                this.adapter_.removeClass(this.openCssClass_);\n                this.detabinate_(); // Debounce multiple calls\n                if (this.isOpen_) {\n                    this.adapter_.notifyClose();\n                }\n                this.isOpen_ = false;\n            }\n        }, {\n            key: \"isOpen\",\n            value: function isOpen() {\n                return this.isOpen_;\n            }\n            /**\n             *  Render all children of the drawer inert when it's closed.\n             */\n        }, {\n            key: \"detabinate_\",\n            value: function detabinate_() {\n                if (this.inert_) {\n                    return;\n                }\n                var elements = this.adapter_.getFocusableElements();\n                if (elements) {\n                    for (var i = 0; i < elements.length; i++) {\n                        this.adapter_.saveElementTabState(elements[i]);\n                        this.adapter_.makeElementUntabbable(elements[i]);\n                    }\n                }\n                this.inert_ = true;\n            }\n            /**\n             *  Make all children of the drawer tabbable again when it's open.\n             */\n        }, {\n            key: \"retabinate_\",\n            value: function retabinate_() {\n                if (!this.inert_) {\n                    return;\n                }\n                var elements = this.adapter_.getFocusableElements();\n                if (elements) {\n                    for (var i = 0; i < elements.length; i++) {\n                        this.adapter_.restoreElementTabState(elements[i]);\n                    }\n                }\n                this.inert_ = false;\n            }\n        }, {\n            key: \"handleTouchStart_\",\n            value: function handleTouchStart_(evt) {\n                if (!this.adapter_.hasClass(this.openCssClass_)) {\n                    return;\n                }\n                if (evt.pointerType && evt.pointerType !== 'touch') {\n                    return;\n                }\n                this.direction_ = this.adapter_.isRtl() ? -1 : 1;\n                this.drawerWidth_ = this.adapter_.getDrawerWidth();\n                this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;\n                this.currentX_ = this.startX_;\n                this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));\n            }\n        }, {\n            key: \"handleTouchMove_\",\n            value: function handleTouchMove_(evt) {\n                if (evt.pointerType && evt.pointerType !== 'touch') {\n                    return;\n                }\n                this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;\n            }\n        }, {\n            key: \"handleTouchEnd_\",\n            value: function handleTouchEnd_(evt) {\n                if (evt.pointerType && evt.pointerType !== 'touch') {\n                    return;\n                }\n                this.prepareForTouchEnd_(); // Did the user close the drawer by more than 50%?\n                if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {\n                    this.close();\n                }\n                else {\n                    // Triggering an open here means we'll get a nice animation back to the fully open state.\n                    this.open();\n                }\n            }\n        }, {\n            key: \"prepareForTouchEnd_\",\n            value: function prepareForTouchEnd_() {\n                cancelAnimationFrame(this.updateRaf_);\n                this.adapter_.setTranslateX(null);\n            }\n        }, {\n            key: \"updateDrawer_\",\n            value: function updateDrawer_() {\n                this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));\n                this.adapter_.setTranslateX(this.newPosition_);\n            }\n        }, {\n            key: \"isRootTransitioningEventTarget_\",\n            value: function isRootTransitioningEventTarget_() {\n                // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false\n                // if the event target is the root event target currently transitioning.\n                return false;\n            }\n        }, {\n            key: \"handleTransitionEnd_\",\n            value: function handleTransitionEnd_(evt) {\n                if (this.isRootTransitioningEventTarget_(evt.target)) {\n                    this.adapter_.removeClass(this.animatingCssClass_);\n                    this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);\n                }\n            }\n        }, {\n            key: \"newPosition_\",\n            get: function get() {\n                var newPos = null;\n                if (this.direction_ === 1) {\n                    newPos = Math.min(0, this.currentX_ - this.startX_);\n                }\n                else {\n                    newPos = Math.max(0, this.currentX_ - this.startX_);\n                }\n                return newPos;\n            }\n        }]);\n    return MDCSlidableDrawerFoundation;\n}(MDCFoundation);\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar cssClasses = {\n    ROOT: 'mdc-drawer--temporary',\n    OPEN: 'mdc-drawer--open',\n    ANIMATING: 'mdc-drawer--animating',\n    SCROLL_LOCK: 'mdc-drawer-scroll-lock'\n};\nvar strings = {\n    DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',\n    OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',\n    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,\n    OPEN_EVENT: 'MDCTemporaryDrawer:open',\n    CLOSE_EVENT: 'MDCTemporaryDrawer:close'\n};\nvar MDCTemporaryDrawerFoundation = \n/*#__PURE__*/\nfunction (_MDCSlidableDrawerFou) {\n    _inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);\n    _createClass(MDCTemporaryDrawerFoundation, null, [{\n            key: \"cssClasses\",\n            get: function get$$1() {\n                return cssClasses;\n            }\n        }, {\n            key: \"strings\",\n            get: function get$$1() {\n                return strings;\n            }\n        }, {\n            key: \"defaultAdapter\",\n            get: function get$$1() {\n                return Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, {\n                    addBodyClass: function addBodyClass() { },\n                    removeBodyClass: function removeBodyClass() { },\n                    isDrawer: function isDrawer() {\n                        return false;\n                    },\n                    updateCssVariable: function updateCssVariable() { },\n                    eventTargetHasClass: function eventTargetHasClass() {\n                        return (\n                        /* target: EventTarget, className: string */\n                        /* boolean */\n                        false);\n                    }\n                });\n            }\n        }]);\n    function MDCTemporaryDrawerFoundation(adapter) {\n        var _this;\n        _classCallCheck(this, MDCTemporaryDrawerFoundation);\n        _this = _possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, Object.assign(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));\n        _this.componentClickHandler_ = function (evt) {\n            if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses.ROOT)) {\n                _this.close(true);\n            }\n        };\n        return _this;\n    }\n    _createClass(MDCTemporaryDrawerFoundation, [{\n            key: \"init\",\n            value: function init() {\n                _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), \"init\", this).call(this); // Make browser aware of custom property being used in this element.\n                // Workaround for certain types of hard-to-reproduce heisenbugs.\n                this.adapter_.updateCssVariable(0);\n                this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), \"destroy\", this).call(this);\n                this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);\n                this.enableScroll_();\n            }\n        }, {\n            key: \"open\",\n            value: function open() {\n                this.disableScroll_(); // Make sure custom property values are cleared before starting.\n                this.adapter_.updateCssVariable('');\n                _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), \"open\", this).call(this);\n            }\n        }, {\n            key: \"close\",\n            value: function close() {\n                // Make sure custom property values are cleared before making any changes.\n                this.adapter_.updateCssVariable('');\n                _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), \"close\", this).call(this);\n            }\n        }, {\n            key: \"prepareForTouchEnd_\",\n            value: function prepareForTouchEnd_() {\n                _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), \"prepareForTouchEnd_\", this).call(this);\n                this.adapter_.updateCssVariable('');\n            }\n        }, {\n            key: \"updateDrawer_\",\n            value: function updateDrawer_() {\n                _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), \"updateDrawer_\", this).call(this);\n                var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));\n                this.adapter_.updateCssVariable(newOpacity);\n            }\n        }, {\n            key: \"isRootTransitioningEventTarget_\",\n            value: function isRootTransitioningEventTarget_(el) {\n                return this.adapter_.isDrawer(el);\n            }\n        }, {\n            key: \"handleTransitionEnd_\",\n            value: function handleTransitionEnd_(evt) {\n                _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), \"handleTransitionEnd_\", this).call(this, evt);\n                if (!this.isOpen_) {\n                    this.enableScroll_();\n                }\n            }\n        }, {\n            key: \"disableScroll_\",\n            value: function disableScroll_() {\n                this.adapter_.addBodyClass(cssClasses.SCROLL_LOCK);\n            }\n        }, {\n            key: \"enableScroll_\",\n            value: function enableScroll_() {\n                this.adapter_.removeBodyClass(cssClasses.SCROLL_LOCK);\n            }\n        }]);\n    return MDCTemporaryDrawerFoundation;\n}(MDCSlidableDrawerFoundation);\nvar MDCTemporaryDrawer = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCTemporaryDrawer, _MDCComponent);\n    function MDCTemporaryDrawer() {\n        _classCallCheck(this, MDCTemporaryDrawer);\n        return _possibleConstructorReturn(this, (MDCTemporaryDrawer.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawer)).apply(this, arguments));\n    }\n    _createClass(MDCTemporaryDrawer, [{\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this = this;\n                var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings, FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS, OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;\n                return new MDCTemporaryDrawerFoundation({\n                    addClass: function addClass(className) {\n                        return _this.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this.root_.classList.remove(className);\n                    },\n                    hasClass: function hasClass(className) {\n                        return _this.root_.classList.contains(className);\n                    },\n                    addBodyClass: function addBodyClass(className) {\n                        return document.body.classList.add(className);\n                    },\n                    removeBodyClass: function removeBodyClass(className) {\n                        return document.body.classList.remove(className);\n                    },\n                    eventTargetHasClass: function eventTargetHasClass(target, className) {\n                        return target.classList.contains(className);\n                    },\n                    hasNecessaryDom: function hasNecessaryDom() {\n                        return Boolean(_this.drawer);\n                    },\n                    registerInteractionHandler: function registerInteractionHandler(evt, handler) {\n                        return _this.root_.addEventListener(remapEvent(evt), handler, applyPassive());\n                    },\n                    deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {\n                        return _this.root_.removeEventListener(remapEvent(evt), handler, applyPassive());\n                    },\n                    registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {\n                        return _this.drawer.addEventListener(remapEvent(evt), handler);\n                    },\n                    deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {\n                        return _this.drawer.removeEventListener(remapEvent(evt), handler);\n                    },\n                    registerTransitionEndHandler: function registerTransitionEndHandler(handler) {\n                        return _this.drawer.addEventListener('transitionend', handler);\n                    },\n                    deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {\n                        return _this.drawer.removeEventListener('transitionend', handler);\n                    },\n                    registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {\n                        return document.addEventListener('keydown', handler);\n                    },\n                    deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {\n                        return document.removeEventListener('keydown', handler);\n                    },\n                    getDrawerWidth: function getDrawerWidth() {\n                        return _this.drawer.offsetWidth;\n                    },\n                    setTranslateX: function setTranslateX(value) {\n                        return _this.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : \"translateX(\".concat(value, \"px)\"));\n                    },\n                    updateCssVariable: function updateCssVariable(value) {\n                        if (supportsCssCustomProperties()) {\n                            _this.root_.style.setProperty(OPACITY_VAR_NAME, value);\n                        }\n                    },\n                    getFocusableElements: function getFocusableElements() {\n                        return _this.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);\n                    },\n                    saveElementTabState: function saveElementTabState$$1(el) {\n                        return saveElementTabState(el);\n                    },\n                    restoreElementTabState: function restoreElementTabState$$1(el) {\n                        return restoreElementTabState(el);\n                    },\n                    makeElementUntabbable: function makeElementUntabbable(el) {\n                        return el.setAttribute('tabindex', -1);\n                    },\n                    notifyOpen: function notifyOpen() {\n                        return _this.emit(MDCTemporaryDrawerFoundation.strings.OPEN_EVENT);\n                    },\n                    notifyClose: function notifyClose() {\n                        return _this.emit(MDCTemporaryDrawerFoundation.strings.CLOSE_EVENT);\n                    },\n                    isRtl: function isRtl() {\n                        return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';\n                    },\n                    isDrawer: function isDrawer(el) {\n                        return el === _this.drawer;\n                    }\n                });\n            }\n        }, {\n            key: \"open\",\n            get: function get() {\n                return this.foundation_.isOpen();\n            },\n            set: function set(value) {\n                if (value) {\n                    this.foundation_.open();\n                }\n                else {\n                    this.foundation_.close();\n                }\n            }\n            /* Return the drawer element inside the component. */\n        }, {\n            key: \"drawer\",\n            get: function get() {\n                return this.root_.querySelector(MDCTemporaryDrawerFoundation.strings.DRAWER_SELECTOR);\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                return new MDCTemporaryDrawer(root);\n            }\n        }]);\n    return MDCTemporaryDrawer;\n}(MDCComponent);\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar cssClasses$1 = {\n    ROOT: 'mdc-drawer--persistent',\n    OPEN: 'mdc-drawer--open',\n    ANIMATING: 'mdc-drawer--animating'\n};\nvar strings$1 = {\n    DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',\n    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,\n    OPEN_EVENT: 'MDCPersistentDrawer:open',\n    CLOSE_EVENT: 'MDCPersistentDrawer:close'\n};\nvar MDCPersistentDrawerFoundation = \n/*#__PURE__*/\nfunction (_MDCSlidableDrawerFou) {\n    _inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);\n    _createClass(MDCPersistentDrawerFoundation, null, [{\n            key: \"cssClasses\",\n            get: function get() {\n                return cssClasses$1;\n            }\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings$1;\n            }\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, {\n                    isDrawer: function isDrawer() {\n                        return false;\n                    }\n                });\n            }\n        }]);\n    function MDCPersistentDrawerFoundation(adapter) {\n        _classCallCheck(this, MDCPersistentDrawerFoundation);\n        return _possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, Object.assign(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));\n    }\n    _createClass(MDCPersistentDrawerFoundation, [{\n            key: \"isRootTransitioningEventTarget_\",\n            value: function isRootTransitioningEventTarget_(el) {\n                return this.adapter_.isDrawer(el);\n            }\n        }]);\n    return MDCPersistentDrawerFoundation;\n}(MDCSlidableDrawerFoundation);\nvar MDCPersistentDrawer = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCPersistentDrawer, _MDCComponent);\n    function MDCPersistentDrawer() {\n        _classCallCheck(this, MDCPersistentDrawer);\n        return _possibleConstructorReturn(this, (MDCPersistentDrawer.__proto__ || Object.getPrototypeOf(MDCPersistentDrawer)).apply(this, arguments));\n    }\n    _createClass(MDCPersistentDrawer, [{\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this = this;\n                var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;\n                return new MDCPersistentDrawerFoundation({\n                    addClass: function addClass(className) {\n                        return _this.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this.root_.classList.remove(className);\n                    },\n                    hasClass: function hasClass(className) {\n                        return _this.root_.classList.contains(className);\n                    },\n                    hasNecessaryDom: function hasNecessaryDom() {\n                        return Boolean(_this.drawer);\n                    },\n                    registerInteractionHandler: function registerInteractionHandler(evt, handler) {\n                        return _this.root_.addEventListener(remapEvent(evt), handler, applyPassive());\n                    },\n                    deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {\n                        return _this.root_.removeEventListener(remapEvent(evt), handler, applyPassive());\n                    },\n                    registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {\n                        return _this.drawer.addEventListener(remapEvent(evt), handler);\n                    },\n                    deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {\n                        return _this.drawer.removeEventListener(remapEvent(evt), handler);\n                    },\n                    registerTransitionEndHandler: function registerTransitionEndHandler(handler) {\n                        return _this.root_.addEventListener('transitionend', handler);\n                    },\n                    deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {\n                        return _this.root_.removeEventListener('transitionend', handler);\n                    },\n                    registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {\n                        return document.addEventListener('keydown', handler);\n                    },\n                    deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {\n                        return document.removeEventListener('keydown', handler);\n                    },\n                    getDrawerWidth: function getDrawerWidth() {\n                        return _this.drawer.offsetWidth;\n                    },\n                    setTranslateX: function setTranslateX(value) {\n                        return _this.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : \"translateX(\".concat(value, \"px)\"));\n                    },\n                    getFocusableElements: function getFocusableElements() {\n                        return _this.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);\n                    },\n                    saveElementTabState: function saveElementTabState$$1(el) {\n                        return saveElementTabState(el);\n                    },\n                    restoreElementTabState: function restoreElementTabState$$1(el) {\n                        return restoreElementTabState(el);\n                    },\n                    makeElementUntabbable: function makeElementUntabbable(el) {\n                        return el.setAttribute('tabindex', -1);\n                    },\n                    notifyOpen: function notifyOpen() {\n                        return _this.emit(MDCPersistentDrawerFoundation.strings.OPEN_EVENT);\n                    },\n                    notifyClose: function notifyClose() {\n                        return _this.emit(MDCPersistentDrawerFoundation.strings.CLOSE_EVENT);\n                    },\n                    isRtl: function isRtl() {\n                        return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';\n                    },\n                    isDrawer: function isDrawer(el) {\n                        return el === _this.drawer;\n                    }\n                });\n            }\n        }, {\n            key: \"open\",\n            get: function get() {\n                return this.foundation_.isOpen();\n            },\n            set: function set(value) {\n                if (value) {\n                    this.foundation_.open();\n                }\n                else {\n                    this.foundation_.close();\n                }\n            } // Return the drawer element inside the component.\n        }, {\n            key: \"drawer\",\n            get: function get() {\n                return this.root_.querySelector(MDCPersistentDrawerFoundation.strings.DRAWER_SELECTOR);\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                return new MDCPersistentDrawer(root);\n            }\n        }]);\n    return MDCPersistentDrawer;\n}(MDCComponent);\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ FOCUSABLE_ELEMENTS$1 = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' +\n    'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';\nvar MdcDrawer = /** @class */ /*@__PURE__*/ (function () {\n    function MdcDrawer(_changeDetectorRef, renderer, elementRef, _registry) {\n        var _this = this;\n        this._changeDetectorRef = _changeDetectorRef;\n        this.renderer = renderer;\n        this.elementRef = elementRef;\n        this._registry = _registry;\n        this._fixed = false;\n        this._drawer = 'permanent';\n        this.closeOnClick = true;\n        this.opened = new EventEmitter();\n        this.closed = new EventEmitter();\n        this.isHostClass = true;\n        this.role = 'navigation';\n        this._mdcAdapter = {\n            addClass: function (className) { return _this.renderer.addClass(_this._getHostElement(), className); },\n            removeClass: function (className) { return _this.renderer.removeClass(_this._getHostElement(), className); },\n            hasClass: function (className) { return _this._getHostElement().classList.contains(className); },\n            addBodyClass: function (className) {\n                if (isBrowser()) {\n                    _this.renderer.addClass(_this.fixedAdjustElement\n                        ? _this.fixedAdjustElement : document.body, className);\n                }\n            },\n            removeBodyClass: function (className) {\n                if (isBrowser()) {\n                    _this.renderer.removeClass(_this.fixedAdjustElement\n                        ? _this.fixedAdjustElement : document.body, className);\n                }\n            },\n            eventTargetHasClass: function (target, className) { return target.classList.contains(className); },\n            hasNecessaryDom: function () { return !!_this.drawerNav; },\n            registerInteractionHandler: function (evt, handler) {\n                return _this._registry.listen(remapEvent(evt), handler, _this._getHostElement(), applyPassive());\n            },\n            deregisterInteractionHandler: function (evt, handler) { return _this._registry.unlisten(evt, handler); },\n            registerDrawerInteractionHandler: function (evt, handler) {\n                if (_this.drawerElement) {\n                    _this._registry.listen(remapEvent(evt), handler, _this.drawerElement.nativeElement);\n                }\n            },\n            deregisterDrawerInteractionHandler: function (evt, handler) { return _this._registry.unlisten(evt, handler); },\n            registerTransitionEndHandler: function (handler) {\n                if (_this.drawerElement) {\n                    _this._registry.listen('transitionend', handler, _this.drawerElement.nativeElement);\n                }\n            },\n            deregisterTransitionEndHandler: function (handler) { return _this._registry.unlisten('transitionend', handler); },\n            registerDocumentKeydownHandler: function (handler) {\n                if (isBrowser()) {\n                    _this._registry.listen('keydown', handler, document);\n                }\n            },\n            deregisterDocumentKeydownHandler: function (handler) { return _this._registry.unlisten('keydown', handler); },\n            getDrawerWidth: function () { return _this._getHostElement().offsetWidth; },\n            setTranslateX: function (value) {\n                if (_this.drawerNav) {\n                    _this.renderer.setProperty(_this.drawerNav.elementRef, getTransformPropertyName(), value === null ? null : \"translateX(\" + value + \"px)\");\n                }\n            },\n            updateCssVariable: function (value) {\n                if (supportsCssCustomProperties()) {\n                    _this.renderer.setStyle(_this._getHostElement(), '--mdc-temporary-drawer-opacity', value);\n                }\n            },\n            getFocusableElements: function () {\n                return _this.drawerNav ? _this.drawerNav.elementRef.nativeElement.querySelectorAll(FOCUSABLE_ELEMENTS$1) : null;\n            },\n            saveElementTabState: function (el) { return saveElementTabState(el); },\n            restoreElementTabState: function (el) { return restoreElementTabState(el); },\n            makeElementUntabbable: function (el) { return _this.renderer.setAttribute(el, 'tabindex', '-1'); },\n            notifyOpen: function () { return _this.opened.emit(); },\n            notifyClose: function () { return _this.closed.emit(); },\n            isRtl: function () { return getComputedStyle(_this._getHostElement()).direction === 'rtl'; },\n            isDrawer: function (el) {\n                return _this.drawerNav ? el === _this.drawerNav.elementRef.nativeElement : false;\n            }\n        };\n        this._initializeFoundation(this._drawer);\n    }\n    Object.defineProperty(MdcDrawer.prototype, \"fixed\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._fixed; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setFixed(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcDrawer.prototype, \"drawer\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._drawer; },\n        set: /**\n         * @param {?} drawer\n         * @return {?}\n         */ function (drawer) {\n            this.setDrawer(drawer);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcDrawer.prototype, \"fixedAdjustElement\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._fixedAdjustElement; },\n        set: /**\n         * @param {?} element\n         * @return {?}\n         */ function (element) {\n            this.setFixedAdjustElement(element);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcDrawer.prototype, \"drawerElement\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.drawerNav && this.drawerNav.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcDrawer.prototype, \"classFixed\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.fixed && this.isDrawerPermanent() ? 'ng-mdc-drawer--fixed' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._foundation) {\n                this._foundation.destroy();\n            }\n        };\n    /**\n     * @param {?} drawer\n     * @return {?}\n     */\n    MdcDrawer.prototype.setDrawer = /**\n     * @param {?} drawer\n     * @return {?}\n     */\n        function (drawer) {\n            var _this = this;\n            this._drawer = drawer ? drawer : 'permanent';\n            this._initializeFoundation(drawer);\n            if (drawer === 'temporary') {\n                this._registry.listen('click', function () {\n                    if (_this.closeOnClick) {\n                        _this._foundation.close();\n                    }\n                }, this.drawerElement.nativeElement);\n            }\n            else if (drawer === 'temporary') {\n                this._registry.unlisten('click', function () {\n                    if (_this.closeOnClick) {\n                        _this._foundation.close();\n                    }\n                });\n            }\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    MdcDrawer.prototype.setFixedAdjustElement = /**\n     * @param {?} element\n     * @return {?}\n     */\n        function (element) {\n            this._fixedAdjustElement = element;\n            if (element) {\n                this.renderer.setStyle(this._getHostElement(), 'position', 'absolute');\n            }\n            else {\n                this.renderer.removeStyle(this._getHostElement(), 'position');\n            }\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} fixed\n     * @return {?}\n     */\n    MdcDrawer.prototype.setFixed = /**\n     * @param {?} fixed\n     * @return {?}\n     */\n        function (fixed) {\n            this._fixed = fixed;\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype.isDrawerPermanent = /**\n     * @return {?}\n     */\n        function () {\n            return this._drawer === 'permanent';\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype.isDrawerTemporary = /**\n     * @return {?}\n     */\n        function () {\n            return this._drawer === 'temporary';\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype.isDrawerPersistent = /**\n     * @return {?}\n     */\n        function () {\n            return this._drawer === 'persistent';\n        };\n    /**\n     * @param {?} drawer\n     * @return {?}\n     */\n    MdcDrawer.prototype._initializeFoundation = /**\n     * @param {?} drawer\n     * @return {?}\n     */\n        function (drawer) {\n            this._removeDrawerModifierClass();\n            this.renderer.addClass(this._getHostElement(), \"mdc-drawer--\" + drawer);\n            if (!this.isDrawerPermanent()) {\n                if (drawer === 'temporary') {\n                    this._foundation = new MDCTemporaryDrawerFoundation(this._mdcAdapter);\n                }\n                else if (drawer === 'persistent') {\n                    this._foundation = new MDCPersistentDrawerFoundation(this._mdcAdapter);\n                }\n                this._foundation.init();\n            }\n            else {\n                if (this._foundation) {\n                    this._foundation.destroy();\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype._removeDrawerModifierClass = /**\n     * @return {?}\n     */\n        function () {\n            this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--temporary');\n            this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--persistent');\n            this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--permanent');\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype.isOpen = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isDrawerPermanent()) {\n                return true;\n            }\n            return this._foundation.isOpen();\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype.open = /**\n     * @return {?}\n     */\n        function () {\n            if (this._foundation) {\n                this.isOpen() ? this._foundation.close() : this._foundation.open();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype.close = /**\n     * @return {?}\n     */\n        function () {\n            if (this._foundation) {\n                this._foundation.close();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype.getDrawerWidth = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation ? this._mdcAdapter.getDrawerWidth() : this._getHostElement().offsetWidth;\n        };\n    /**\n     * @return {?}\n     */\n    MdcDrawer.prototype._getHostElement = /**\n     * @return {?}\n     */\n        function () {\n            return this.elementRef.nativeElement;\n        };\n    return MdcDrawer;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ DRAWER_COMPONENTS = [\n    MdcDrawer,\n    MdcDrawerContent,\n    MdcDrawerHeader,\n    MdcDrawerHeaderContent,\n    MdcDrawerNavigation,\n    MdcDrawerSpacer,\n];\nvar MdcDrawerModule = /** @class */ /*@__PURE__*/ (function () {\n    function MdcDrawerModule() {\n    }\n    return MdcDrawerModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MdcDrawerModule, FOCUSABLE_ELEMENTS$1 as FOCUSABLE_ELEMENTS, MdcDrawer, MdcDrawerContent as d14, MdcDrawerHeader as b14, MdcDrawerHeaderContent as c14, MdcDrawerNavigation as e14, MdcDrawerSpacer as a14 };\n",null]}