{"remainingRequest":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\overlay.es5.js","dependencies":[{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\overlay.es5.js","mtime":1554924123942},{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1554924186691},{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1554924110461}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright (c) 2018 Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\n/** PURE_IMPORTS_START rxjs,_angular_core,_angular_mdc_web_portal PURE_IMPORTS_END */\nimport { Subject } from 'rxjs';\nimport { Injectable, Optional, SkipSelf, ComponentFactoryResolver, ApplicationRef, Injector, NgZone, NgModule } from '@angular/core';\nimport { DomPortalOutlet, PortalModule } from '@angular-mdc/web/portal';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar /**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */ OverlayRef = /** @class */ /*@__PURE__*/ (function () {\n    function OverlayRef(_portalOutlet, _pane, _ngZone) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._ngZone = _ngZone;\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject();\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */ function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n        function (portal) {\n            var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n            // Update the pane element with the given configuration.\n            this._updateStackingOrder();\n            // Enable pointer events for the overlay pane element.\n            this._togglePointerEvents(true);\n            // Only emit the `attachments` event once all other setup is done.\n            this._attachments.next();\n            return attachResult;\n        };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n        function () {\n            if (!this.hasAttached()) {\n                return;\n            }\n            // When the overlay is detached, the pane element should disable pointer events.\n            // This is necessary because otherwise the pane element will cover the page and disable\n            // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n            this._togglePointerEvents(false);\n            var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n            // Only emit after everything is detached.\n            this._detachments.next();\n            return detachmentResult;\n        };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ isAttached = this.hasAttached();\n            this._portalOutlet.dispose();\n            this._attachments.complete();\n            if (isAttached) {\n                this._detachments.next();\n            }\n            this._detachments.complete();\n        };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n        function () {\n            return this._portalOutlet.hasAttached();\n        };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n        function () {\n            return this._attachments.asObservable();\n        };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n        function () {\n            return this._detachments.asObservable();\n        };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n        function () {\n            return this._keydownEvents.asObservable();\n        };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n        function (enablePointer) {\n            this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n        };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n        function () {\n            if (this._pane.nextSibling) {\n                /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n            }\n        };\n    return OverlayRef;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar OverlayContainer = /** @class */ /*@__PURE__*/ (function () {\n    function OverlayContainer() {\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._containerElement && this._containerElement.parentNode) {\n                this._containerElement.parentNode.removeChild(this._containerElement);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * @return {?}\n     */\n        function () {\n            if (!this._containerElement) {\n                this._createContainer();\n            }\n            return this._containerElement;\n        };\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ container = document.createElement('div');\n            document.body.appendChild(container);\n            this._containerElement = container;\n        };\n    return OverlayContainer;\n}());\n/**\n * @param {?} parentContainer\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {\n    return parentContainer || new OverlayContainer();\n}\nvar /** @type {?} */ OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [[/*@__PURE__*/ new Optional(), /*@__PURE__*/ new SkipSelf(), OverlayContainer]],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Next overlay unique ID.\n */\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\n */\nvar Overlay = /** @class */ /*@__PURE__*/ (function () {\n    function Overlay(_overlayContainer, _componentFactoryResolver, _appRef, _injector, _ngZone) {\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * Creates an overlay.\n     * @param state State to apply to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @return {?} Reference to the created overlay.\n     */\n        function () {\n            var /** @type {?} */ pane = this._createPaneElement();\n            var /** @type {?} */ portalHost = this._createPortalHost(pane);\n            return new OverlayRef(portalHost, pane, this._ngZone);\n        };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n        function () {\n            var /** @type {?} */ pane = document.createElement('div');\n            pane.id = \"mdc-overlay-\" + nextUniqueId++;\n            this._overlayContainer.getContainerElement().appendChild(pane);\n            return pane;\n        };\n    /**\n     * Create a DomOverlayHost into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal host.\n     * @return {?} A portal host for the given DOM element.\n     */\n    Overlay.prototype._createPortalHost = /**\n     * Create a DomOverlayHost into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal host.\n     * @return {?} A portal host for the given DOM element.\n     */\n        function (pane) {\n            return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n        };\n    return Overlay;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ OVERLAY_PROVIDERS = [\n    Overlay,\n    OVERLAY_CONTAINER_PROVIDER,\n];\nvar OverlayModule = /** @class */ /*@__PURE__*/ (function () {\n    function OverlayModule() {\n    }\n    return OverlayModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { Overlay, OverlayRef, OverlayContainer, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_CONTAINER_PROVIDER as ɵb9, OVERLAY_CONTAINER_PROVIDER_FACTORY as ɵa9 };\n",null]}