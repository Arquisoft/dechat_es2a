{"remainingRequest":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\textfield.es5.js","dependencies":[{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\textfield.es5.js","mtime":1554924124052},{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1554924186691},{"path":"C:\\Users\\rauls\\OneDrive\\Documentos\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1554924110461}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright (c) 2018 Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\n/** PURE_IMPORTS_START _angular_core,_angular_forms,rxjs_operators,rxjs,_angular_mdc_web_common,_angular_mdc_web_ripple,_angular_mdc_web_floating_label,_angular_mdc_web_line_ripple,_angular_mdc_web_notched_outline,_angular_mdc_web_icon,tslib,_angular_common PURE_IMPORTS_END */\nimport { Directive, ElementRef, HostBinding, Input, Renderer2, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, EventEmitter, forwardRef, Output, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { startWith, takeUntil } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport { toBoolean, isBrowser, EventRegistry, toNumber, getSupportedInputTypes } from '@angular-mdc/web/common';\nimport { MdcRipple } from '@angular-mdc/web/ripple';\nimport { MdcFloatingLabel, MdcFloatingLabelModule } from '@angular-mdc/web/floating-label';\nimport { MdcLineRipple, MdcLineRippleModule } from '@angular-mdc/web/line-ripple';\nimport { MdcNotchedOutline, MdcNotchedOutlineIdle, MdcNotchedOutlineModule } from '@angular-mdc/web/notched-outline';\nimport { MdcIcon } from '@angular-mdc/web/icon';\nimport { __extends } from 'tslib';\nimport { CommonModule } from '@angular/common';\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _get(object, property, receiver) {\n    if (object === null)\n        object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);\n        if (parent === null) {\n            return undefined;\n        }\n        else {\n            return _get(parent, property, receiver);\n        }\n    }\n    else if (\"value\" in desc) {\n        return desc.value;\n    }\n    else {\n        var getter = desc.get;\n        if (getter === undefined) {\n            return undefined;\n        }\n        return getter.call(receiver);\n    }\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass)\n        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @template A\n */\nvar MDCFoundation = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    _createClass(MDCFoundation, null, [{\n            key: \"cssClasses\",\n            /** @return enum{cssClasses} */\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports every\n                // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}\n                return {};\n            }\n            /** @return enum{strings} */\n        }, {\n            key: \"strings\",\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports all\n                // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}\n                return {};\n            }\n            /** @return enum{numbers} */\n        }, {\n            key: \"numbers\",\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports all\n                // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n                return {};\n            }\n            /** @return {!Object} */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n                // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n                // validation.\n                return {};\n            }\n            /**\n             * @param {A=} adapter\n             */\n        }]);\n    function MDCFoundation() {\n        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, MDCFoundation);\n        /** @protected {!A} */\n        this.adapter_ = adapter;\n    }\n    _createClass(MDCFoundation, [{\n            key: \"init\",\n            value: function init() {\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n            }\n        }]);\n    return MDCFoundation;\n}();\n/**\n * @template F\n */\nvar MDCComponent = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    _createClass(MDCComponent, null, [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCComponent}\n             */\n            value: function attachTo(root) {\n                // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and\n                // returns an instantiated component with its root set to that element. Also note that in the cases of\n                // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized\n                // from getDefaultFoundation().\n                return new MDCComponent(root, new MDCFoundation());\n            }\n            /**\n             * @param {!Element} root\n             * @param {F=} foundation\n             * @param {...?} args\n             */\n        }]);\n    function MDCComponent(root) {\n        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        _classCallCheck(this, MDCComponent);\n        /** @protected {!Element} */\n        this.root_ = root;\n        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n            args[_key - 2] = arguments[_key];\n        }\n        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that\n        // this.root_ is defined and can be used within the foundation class.\n        /** @protected {!F} */\n        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;\n        this.foundation_.init();\n        this.initialSyncWithDOM();\n    }\n    _createClass(MDCComponent, [{\n            key: \"initialize\",\n            value: function initialize() { } // Subclasses can override this to do any additional setup work that would be considered part of a\n            // \"constructor\". Essentially, it is a hook into the parent constructor before the foundation is\n            // initialized. Any additional arguments besides root and foundation will be passed in here.\n            /**\n             * @return {!F} foundation\n             */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                // Subclasses must override this method to return a properly configured foundation class for the\n                // component.\n                throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');\n            }\n        }, {\n            key: \"initialSyncWithDOM\",\n            value: function initialSyncWithDOM() {\n                // object. An example of this would be a form control wrapper that needs to synchronize its internal state\n                // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM\n                // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                // Subclasses may implement this method to release any resources / deregister any listeners they have\n                // attached. An example of this might be deregistering a resize event from the window object.\n                this.foundation_.destroy();\n            }\n            /**\n             * Wrapper method to add an event listener to the component's root element. This is most useful when\n             * listening for custom events.\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"listen\",\n            value: function listen(evtType, handler) {\n                this.root_.addEventListener(evtType, handler);\n            }\n            /**\n             * Wrapper method to remove an event listener to the component's root element. This is most useful when\n             * unlistening for custom events.\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"unlisten\",\n            value: function unlisten(evtType, handler) {\n                this.root_.removeEventListener(evtType, handler);\n            }\n            /**\n             * Fires a cross-browser-compatible custom event from the component root of the given type,\n             * with the given data.\n             * @param {string} evtType\n             * @param {!Object} evtData\n             * @param {boolean=} shouldBubble\n             */\n        }, {\n            key: \"emit\",\n            value: function emit(evtType, evtData) {\n                var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var evt;\n                if (typeof CustomEvent === 'function') {\n                    evt = new CustomEvent(evtType, {\n                        detail: evtData,\n                        bubbles: shouldBubble\n                    });\n                }\n                else {\n                    evt = document.createEvent('CustomEvent');\n                    evt.initCustomEvent(evtType, shouldBubble, false, evtData);\n                }\n                this.root_.dispatchEvent(evt);\n            }\n        }]);\n    return MDCComponent;\n}();\n/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n/**\n * Adapter for MDC Text Field Helper Text.\n *\n * Defines the shape of the adapter expected by the foundation. Implement this\n * adapter to integrate the TextField helper text into your framework. See\n * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md\n * for more information.\n *\n * @record\n */\nvar MDCTextFieldHelperTextAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCTextFieldHelperTextAdapter() {\n        _classCallCheck(this, MDCTextFieldHelperTextAdapter);\n    }\n    _createClass(MDCTextFieldHelperTextAdapter, [{\n            key: \"addClass\",\n            /**\n             * Adds a class to the helper text element.\n             * @param {string} className\n             */\n            value: function addClass(className) { }\n            /**\n             * Removes a class from the helper text element.\n             * @param {string} className\n             */\n        }, {\n            key: \"removeClass\",\n            value: function removeClass(className) { }\n            /**\n             * Returns whether or not the helper text element contains the given class.\n             * @param {string} className\n             * @return {boolean}\n             */\n        }, {\n            key: \"hasClass\",\n            value: function hasClass(className) { }\n            /**\n             * Sets an attribute with a given value on the helper text element.\n             * @param {string} attr\n             * @param {string} value\n             */\n        }, {\n            key: \"setAttr\",\n            value: function setAttr(attr, value) { }\n            /**\n             * Removes an attribute from the helper text element.\n             * @param {string} attr\n             */\n        }, {\n            key: \"removeAttr\",\n            value: function removeAttr(attr) { }\n            /**\n             * Sets the text content for the helper text element.\n             * @param {string} content\n             */\n        }, {\n            key: \"setContent\",\n            value: function setContent(content) { }\n        }]);\n    return MDCTextFieldHelperTextAdapter;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @enum {string} */\nvar strings = {\n    ARIA_HIDDEN: 'aria-hidden',\n    ROLE: 'role'\n};\n/** @enum {string} */\nvar cssClasses = {\n    HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',\n    HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'\n};\n/**\n * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}\n * @final\n */\nvar MDCTextFieldHelperTextFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);\n    _createClass(MDCTextFieldHelperTextFoundation, null, [{\n            key: \"cssClasses\",\n            /** @return enum {string} */\n            get: function get() {\n                return cssClasses;\n            }\n            /** @return enum {string} */\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings;\n            }\n            /**\n             * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return\n             * types.\n             * @return {!MDCTextFieldHelperTextAdapter}\n             */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return (\n                /** @type {!MDCTextFieldHelperTextAdapter} */\n                {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    hasClass: function hasClass() { },\n                    setAttr: function setAttr() { },\n                    removeAttr: function removeAttr() { },\n                    setContent: function setContent() { }\n                });\n            }\n            /**\n             * @param {!MDCTextFieldHelperTextAdapter} adapter\n             */\n        }]);\n    function MDCTextFieldHelperTextFoundation(adapter) {\n        _classCallCheck(this, MDCTextFieldHelperTextFoundation);\n        return _possibleConstructorReturn(this, (MDCTextFieldHelperTextFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperTextFoundation)).call(this, Object.assign(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));\n    }\n    /**\n     * Sets the content of the helper text field.\n     * @param {string} content\n     */\n    _createClass(MDCTextFieldHelperTextFoundation, [{\n            key: \"setContent\",\n            value: function setContent(content) {\n                this.adapter_.setContent(content);\n            }\n            /** @param {boolean} isPersistent Sets the persistency of the helper text. */\n        }, {\n            key: \"setPersistent\",\n            value: function setPersistent(isPersistent) {\n                if (isPersistent) {\n                    this.adapter_.addClass(cssClasses.HELPER_TEXT_PERSISTENT);\n                }\n                else {\n                    this.adapter_.removeClass(cssClasses.HELPER_TEXT_PERSISTENT);\n                }\n            }\n            /**\n             * @param {boolean} isValidation True to make the helper text act as an\n             *   error validation message.\n             */\n        }, {\n            key: \"setValidation\",\n            value: function setValidation(isValidation) {\n                if (isValidation) {\n                    this.adapter_.addClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);\n                }\n                else {\n                    this.adapter_.removeClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);\n                }\n            }\n            /** Makes the helper text visible to the screen reader. */\n        }, {\n            key: \"showToScreenReader\",\n            value: function showToScreenReader() {\n                this.adapter_.removeAttr(strings.ARIA_HIDDEN);\n            }\n            /**\n             * Sets the validity of the helper text based on the input validity.\n             * @param {boolean} inputIsValid\n             */\n        }, {\n            key: \"setValidity\",\n            value: function setValidity(inputIsValid) {\n                var helperTextIsPersistent = this.adapter_.hasClass(cssClasses.HELPER_TEXT_PERSISTENT);\n                var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);\n                var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;\n                if (validationMsgNeedsDisplay) {\n                    this.adapter_.setAttr(strings.ROLE, 'alert');\n                }\n                else {\n                    this.adapter_.removeAttr(strings.ROLE);\n                }\n                if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {\n                    this.hide_();\n                }\n            }\n            /**\n             * Hides the help text from screen readers.\n             * @private\n             */\n        }, {\n            key: \"hide_\",\n            value: function hide_() {\n                this.adapter_.setAttr(strings.ARIA_HIDDEN, 'true');\n            }\n        }]);\n    return MDCTextFieldHelperTextFoundation;\n}(MDCFoundation);\n/**\n * @extends {MDCComponent<!MDCTextFieldHelperTextFoundation>}\n * @final\n */\nvar MDCTextFieldHelperText = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCTextFieldHelperText, _MDCComponent);\n    function MDCTextFieldHelperText() {\n        _classCallCheck(this, MDCTextFieldHelperText);\n        return _possibleConstructorReturn(this, (MDCTextFieldHelperText.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperText)).apply(this, arguments));\n    }\n    _createClass(MDCTextFieldHelperText, [{\n            key: \"getDefaultFoundation\",\n            /**\n             * @return {!MDCTextFieldHelperTextFoundation}\n             */\n            value: function getDefaultFoundation() {\n                var _this = this;\n                return new MDCTextFieldHelperTextFoundation(\n                /** @type {!MDCTextFieldHelperTextAdapter} */\n                Object.assign({\n                    addClass: function addClass(className) {\n                        return _this.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this.root_.classList.remove(className);\n                    },\n                    hasClass: function hasClass(className) {\n                        return _this.root_.classList.contains(className);\n                    },\n                    setAttr: function setAttr(attr, value) {\n                        return _this.root_.setAttribute(attr, value);\n                    },\n                    removeAttr: function removeAttr(attr) {\n                        return _this.root_.removeAttribute(attr);\n                    },\n                    setContent: function setContent(content) {\n                        _this.root_.textContent = content;\n                    }\n                }));\n            }\n        }, {\n            key: \"foundation\",\n            /**\n             * @return {!MDCTextFieldHelperTextFoundation}\n             */\n            get: function get() {\n                return this.foundation_;\n            }\n        }], [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCTextFieldHelperText}\n             */\n            value: function attachTo(root) {\n                return new MDCTextFieldHelperText(root);\n            }\n        }]);\n    return MDCTextFieldHelperText;\n}(MDCComponent);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MdcTextFieldHelperText = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTextFieldHelperText(_renderer, elementRef) {\n        var _this = this;\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this.persistent = false;\n        this.validation = false;\n        this.isHostClass = true;\n        this.ariaHidden = 'true';\n        this._mdcAdapter = {\n            addClass: function (className) { return _this._renderer.addClass(_this.elementRef.nativeElement, className); },\n            removeClass: function (className) { return _this._renderer.removeClass(_this.elementRef.nativeElement, className); },\n            hasClass: function (className) { return _this.elementRef.nativeElement.classList.contains(className); },\n            setAttr: function (attr, value) { return _this._renderer.setAttribute(_this.elementRef.nativeElement, attr, value); },\n            removeAttr: function (attr) { return _this._renderer.removeAttribute(_this.elementRef.nativeElement, attr); },\n            setContent: function (content) { return _this.elementRef.nativeElement.textContent = content; },\n        };\n        this.foundation = new MDCTextFieldHelperTextFoundation(this._mdcAdapter);\n    }\n    Object.defineProperty(MdcTextFieldHelperText.prototype, \"classPersistent\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.persistent ? 'mdc-text-field-helper-text--persistent' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextFieldHelperText.prototype, \"classValidation\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.validation ? 'mdc-text-field-helper-text--validation-msg' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdcTextFieldHelperText.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.foundation.init();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextFieldHelperText.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.destroy();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextFieldHelperText.prototype.destroy = /**\n     * @return {?}\n     */\n        function () {\n            this.foundation.destroy();\n        };\n    /** Sets the content of the helper text field. */\n    /**\n     * Sets the content of the helper text field.\n     * @param {?} content\n     * @return {?}\n     */\n    MdcTextFieldHelperText.prototype.setContent = /**\n     * Sets the content of the helper text field.\n     * @param {?} content\n     * @return {?}\n     */\n        function (content) {\n            this.foundation.setContent(content);\n        };\n    /** Sets the validity of the helper text based on the input validity. */\n    /**\n     * Sets the validity of the helper text based on the input validity.\n     * @param {?} validity\n     * @return {?}\n     */\n    MdcTextFieldHelperText.prototype.setValidity = /**\n     * Sets the validity of the helper text based on the input validity.\n     * @param {?} validity\n     * @return {?}\n     */\n        function (validity) {\n            this.foundation.setValidity(validity);\n        };\n    /** Makes the helper text visible to the screen reader. */\n    /**\n     * Makes the helper text visible to the screen reader.\n     * @return {?}\n     */\n    MdcTextFieldHelperText.prototype.showToScreenReader = /**\n     * Makes the helper text visible to the screen reader.\n     * @return {?}\n     */\n        function () {\n            this.foundation.showToScreenReader();\n        };\n    /** Sets the persistency of the helper text. */\n    /**\n     * Sets the persistency of the helper text.\n     * @param {?} isPersistent\n     * @return {?}\n     */\n    MdcTextFieldHelperText.prototype.setPersistent = /**\n     * Sets the persistency of the helper text.\n     * @param {?} isPersistent\n     * @return {?}\n     */\n        function (isPersistent) {\n            this.persistent = isPersistent;\n            this.foundation.setPersistent(isPersistent);\n        };\n    /** True to make the helper text act as an error validation message. */\n    /**\n     * True to make the helper text act as an error validation message.\n     * @param {?} isValidation\n     * @return {?}\n     */\n    MdcTextFieldHelperText.prototype.setValidation = /**\n     * True to make the helper text act as an error validation message.\n     * @param {?} isValidation\n     * @return {?}\n     */\n        function (isValidation) {\n            this.validation = isValidation;\n            this.foundation.setValidation(isValidation);\n        };\n    return MdcTextFieldHelperText;\n}());\n/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n/**\n * Adapter for MDC Text Field Icon.\n *\n * Defines the shape of the adapter expected by the foundation. Implement this\n * adapter to integrate the text field icon into your framework. See\n * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md\n * for more information.\n *\n * @record\n */\nvar MDCTextFieldIconAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCTextFieldIconAdapter() {\n        _classCallCheck(this, MDCTextFieldIconAdapter);\n    }\n    _createClass(MDCTextFieldIconAdapter, [{\n            key: \"getAttr\",\n            /**\n             * Gets the value of an attribute on the icon element.\n             * @param {string} attr\n             * @return {string}\n             */\n            value: function getAttr(attr) { }\n            /**\n             * Sets an attribute on the icon element.\n             * @param {string} attr\n             * @param {string} value\n             */\n        }, {\n            key: \"setAttr\",\n            value: function setAttr(attr, value) { }\n            /**\n             * Removes an attribute from the icon element.\n             * @param {string} attr\n             */\n        }, {\n            key: \"removeAttr\",\n            value: function removeAttr(attr) { }\n            /**\n             * Sets the text content of the icon element.\n             * @param {string} content\n             */\n        }, {\n            key: \"setContent\",\n            value: function setContent(content) { }\n            /**\n             * Registers an event listener on the icon element for a given event.\n             * @param {string} evtType\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"registerInteractionHandler\",\n            value: function registerInteractionHandler(evtType, handler) { }\n            /**\n             * Deregisters an event listener on the icon element for a given event.\n             * @param {string} evtType\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"deregisterInteractionHandler\",\n            value: function deregisterInteractionHandler(evtType, handler) { }\n            /**\n             * Emits a custom event \"MDCTextField:icon\" denoting a user has clicked the icon.\n             */\n        }, {\n            key: \"notifyIconAction\",\n            value: function notifyIconAction() { }\n        }]);\n    return MDCTextFieldIconAdapter;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @enum {string} */\nvar strings$1 = {\n    ICON_EVENT: 'MDCTextField:icon',\n    ICON_ROLE: 'button'\n};\n/**\n * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}\n * @final\n */\nvar MDCTextFieldIconFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCTextFieldIconFoundation, _MDCFoundation);\n    _createClass(MDCTextFieldIconFoundation, null, [{\n            key: \"strings\",\n            /** @return enum {string} */\n            get: function get() {\n                return strings$1;\n            }\n            /**\n             * {@see MDCTextFieldIconAdapter} for typing information on parameters and return\n             * types.\n             * @return {!MDCTextFieldIconAdapter}\n             */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return (\n                /** @type {!MDCTextFieldIconAdapter} */\n                {\n                    getAttr: function getAttr() { },\n                    setAttr: function setAttr() { },\n                    removeAttr: function removeAttr() { },\n                    setContent: function setContent() { },\n                    registerInteractionHandler: function registerInteractionHandler() { },\n                    deregisterInteractionHandler: function deregisterInteractionHandler() { },\n                    notifyIconAction: function notifyIconAction() { }\n                });\n            }\n            /**\n             * @param {!MDCTextFieldIconAdapter} adapter\n             */\n        }]);\n    function MDCTextFieldIconFoundation(adapter) {\n        var _this;\n        _classCallCheck(this, MDCTextFieldIconFoundation);\n        _this = _possibleConstructorReturn(this, (MDCTextFieldIconFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldIconFoundation)).call(this, Object.assign(MDCTextFieldIconFoundation.defaultAdapter, adapter)));\n        /** @private {string?} */\n        _this.savedTabIndex_ = null;\n        /** @private {function(!Event): undefined} */\n        _this.interactionHandler_ = function (evt) {\n            return _this.handleInteraction(evt);\n        };\n        return _this;\n    }\n    _createClass(MDCTextFieldIconFoundation, [{\n            key: \"init\",\n            value: function init() {\n                var _this2 = this;\n                this.savedTabIndex_ = this.adapter_.getAttr('tabindex');\n                ['click', 'keydown'].forEach(function (evtType) {\n                    _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);\n                });\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                var _this3 = this;\n                ['click', 'keydown'].forEach(function (evtType) {\n                    _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);\n                });\n            }\n            /** @param {boolean} disabled */\n        }, {\n            key: \"setDisabled\",\n            value: function setDisabled(disabled) {\n                if (!this.savedTabIndex_) {\n                    return;\n                }\n                if (disabled) {\n                    this.adapter_.setAttr('tabindex', '-1');\n                    this.adapter_.removeAttr('role');\n                }\n                else {\n                    this.adapter_.setAttr('tabindex', this.savedTabIndex_);\n                    this.adapter_.setAttr('role', strings$1.ICON_ROLE);\n                }\n            }\n            /** @param {string} label */\n        }, {\n            key: \"setAriaLabel\",\n            value: function setAriaLabel(label) {\n                this.adapter_.setAttr('aria-label', label);\n            }\n            /** @param {string} content */\n        }, {\n            key: \"setContent\",\n            value: function setContent(content) {\n                this.adapter_.setContent(content);\n            }\n            /**\n             * Handles an interaction event\n             * @param {!Event} evt\n             */\n        }, {\n            key: \"handleInteraction\",\n            value: function handleInteraction(evt) {\n                if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {\n                    this.adapter_.notifyIconAction();\n                }\n            }\n        }]);\n    return MDCTextFieldIconFoundation;\n}(MDCFoundation);\n/**\n * @extends {MDCComponent<!MDCTextFieldIconFoundation>}\n * @final\n */\nvar MDCTextFieldIcon = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCTextFieldIcon, _MDCComponent);\n    function MDCTextFieldIcon() {\n        _classCallCheck(this, MDCTextFieldIcon);\n        return _possibleConstructorReturn(this, (MDCTextFieldIcon.__proto__ || Object.getPrototypeOf(MDCTextFieldIcon)).apply(this, arguments));\n    }\n    _createClass(MDCTextFieldIcon, [{\n            key: \"getDefaultFoundation\",\n            /**\n             * @return {!MDCTextFieldIconFoundation}\n             */\n            value: function getDefaultFoundation() {\n                var _this = this;\n                return new MDCTextFieldIconFoundation(\n                /** @type {!MDCTextFieldIconAdapter} */\n                Object.assign({\n                    getAttr: function getAttr(attr) {\n                        return _this.root_.getAttribute(attr);\n                    },\n                    setAttr: function setAttr(attr, value) {\n                        return _this.root_.setAttribute(attr, value);\n                    },\n                    removeAttr: function removeAttr(attr) {\n                        return _this.root_.removeAttribute(attr);\n                    },\n                    setContent: function setContent(content) {\n                        _this.root_.textContent = content;\n                    },\n                    registerInteractionHandler: function registerInteractionHandler(evtType, handler) {\n                        return _this.root_.addEventListener(evtType, handler);\n                    },\n                    deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {\n                        return _this.root_.removeEventListener(evtType, handler);\n                    },\n                    notifyIconAction: function notifyIconAction() {\n                        return _this.emit(MDCTextFieldIconFoundation.strings.ICON_EVENT, {}\n                        /* evtData */\n                        , true\n                        /* shouldBubble */\n                        );\n                    }\n                }));\n            }\n        }, {\n            key: \"foundation\",\n            /**\n             * @return {!MDCTextFieldIconFoundation}\n             */\n            get: function get() {\n                return this.foundation_;\n            }\n        }], [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCTextFieldIcon}\n             */\n            value: function attachTo(root) {\n                return new MDCTextFieldIcon(root);\n            }\n        }]);\n    return MDCTextFieldIcon;\n}(MDCComponent);\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n/**\n * Adapter for MDC Ripple. Provides an interface for managing\n * - classes\n * - dom\n * - CSS variables\n * - position\n * - dimensions\n * - scroll position\n * - event handlers\n * - unbounded, active and disabled states\n *\n * Additionally, provides type information for the adapter to the Closure\n * compiler.\n *\n * Implement this adapter for your framework of choice to delegate updates to\n * the component in your framework of choice. See architecture documentation\n * for more details.\n * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md\n *\n * @record\n */\nvar MDCRippleAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCRippleAdapter() {\n        _classCallCheck(this, MDCRippleAdapter);\n    }\n    _createClass(MDCRippleAdapter, [{\n            key: \"browserSupportsCssVars\",\n            /** @return {boolean} */\n            value: function browserSupportsCssVars() { }\n            /** @return {boolean} */\n        }, {\n            key: \"isUnbounded\",\n            value: function isUnbounded() { }\n            /** @return {boolean} */\n        }, {\n            key: \"isSurfaceActive\",\n            value: function isSurfaceActive() { }\n            /** @return {boolean} */\n        }, {\n            key: \"isSurfaceDisabled\",\n            value: function isSurfaceDisabled() { }\n            /** @param {string} className */\n        }, {\n            key: \"addClass\",\n            value: function addClass(className) { }\n            /** @param {string} className */\n        }, {\n            key: \"removeClass\",\n            value: function removeClass(className) { }\n            /** @param {!EventTarget} target */\n        }, {\n            key: \"containsEventTarget\",\n            value: function containsEventTarget(target) { }\n            /**\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"registerInteractionHandler\",\n            value: function registerInteractionHandler(evtType, handler) { }\n            /**\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"deregisterInteractionHandler\",\n            value: function deregisterInteractionHandler(evtType, handler) { }\n            /**\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"registerDocumentInteractionHandler\",\n            value: function registerDocumentInteractionHandler(evtType, handler) { }\n            /**\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"deregisterDocumentInteractionHandler\",\n            value: function deregisterDocumentInteractionHandler(evtType, handler) { }\n            /**\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"registerResizeHandler\",\n            value: function registerResizeHandler(handler) { }\n            /**\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"deregisterResizeHandler\",\n            value: function deregisterResizeHandler(handler) { }\n            /**\n             * @param {string} varName\n             * @param {?number|string} value\n             */\n        }, {\n            key: \"updateCssVariable\",\n            value: function updateCssVariable(varName, value) { }\n            /** @return {!ClientRect} */\n        }, {\n            key: \"computeBoundingRect\",\n            value: function computeBoundingRect() { }\n            /** @return {{x: number, y: number}} */\n        }, {\n            key: \"getWindowPageOffset\",\n            value: function getWindowPageOffset() { }\n        }]);\n    return MDCRippleAdapter;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar cssClasses$1 = {\n    // Ripple is a special case where the \"root\" component is really a \"mixin\" of sorts,\n    // given that it's an 'upgrade' to an existing component. That being said it is the root\n    // CSS class that all other CSS classes derive from.\n    ROOT: 'mdc-ripple-upgraded',\n    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',\n    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',\n    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',\n    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'\n};\nvar strings$2 = {\n    VAR_LEFT: '--mdc-ripple-left',\n    VAR_TOP: '--mdc-ripple-top',\n    VAR_FG_SIZE: '--mdc-ripple-fg-size',\n    VAR_FG_SCALE: '--mdc-ripple-fg-scale',\n    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',\n    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'\n};\nvar numbers = {\n    PADDING: 10,\n    INITIAL_ORIGIN_SCALE: 0.6,\n    DEACTIVATION_TIMEOUT_MS: 225,\n    // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)\n    FG_DEACTIVATION_MS: 150,\n    // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)\n    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices\n};\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.\n * @private {boolean|undefined}\n */\nvar supportsCssVariables_;\n/**\n * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.\n * @private {boolean|undefined}\n */\nvar supportsPassive_;\n/**\n * @param {!Window} windowObj\n * @return {boolean}\n */\nfunction detectEdgePseudoVarBug(windowObj) {\n    // Detect versions of Edge with buggy var() support\n    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/\n    var document = windowObj.document;\n    var node = document.createElement('div');\n    node.className = 'mdc-ripple-surface--test-edge-var-bug';\n    document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.\n    // Additionally, getComputedStyle returns null in iframes with display: \"none\" in Firefox,\n    // but Firefox is known to support CSS custom properties correctly.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    var computedStyle = windowObj.getComputedStyle(node);\n    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';\n    node.remove();\n    return hasPseudoVarBug;\n}\n/**\n * @param {!Window} windowObj\n * @param {boolean=} forceRefresh\n * @return {boolean|undefined}\n */\nfunction supportsCssVariables(windowObj) {\n    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var supportsCssVariables = supportsCssVariables_;\n    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {\n        return supportsCssVariables;\n    }\n    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';\n    if (!supportsFunctionPresent) {\n        return;\n    }\n    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669\n    // See: README section on Safari\n    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');\n    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {\n        supportsCssVariables = !detectEdgePseudoVarBug(windowObj);\n    }\n    else {\n        supportsCssVariables = false;\n    }\n    if (!forceRefresh) {\n        supportsCssVariables_ = supportsCssVariables;\n    }\n    return supportsCssVariables;\n} //\n/**\n * Determine whether the current browser supports passive event listeners, and if so, use them.\n * @param {!Window=} globalObj\n * @param {boolean=} forceRefresh\n * @return {boolean|{passive: boolean}}\n */\nfunction applyPassive() {\n    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (supportsPassive_ === undefined || forceRefresh) {\n        var isSupported = false;\n        try {\n            globalObj.document.addEventListener('test', null, {\n                get passive() {\n                    isSupported = true;\n                }\n            });\n        }\n        catch (e) { }\n        supportsPassive_ = isSupported;\n    }\n    return supportsPassive_ ? {\n        passive: true\n    } : false;\n}\n/**\n * @param {!Object} HTMLElementPrototype\n * @return {!Array<string>}\n */\nfunction getMatchesProperty(HTMLElementPrototype) {\n    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {\n        return p in HTMLElementPrototype;\n    }).pop();\n}\n/**\n * @param {!Event} ev\n * @param {{x: number, y: number}} pageOffset\n * @param {!ClientRect} clientRect\n * @return {{x: number, y: number}}\n */\nfunction getNormalizedEventCoords(ev, pageOffset, clientRect) {\n    var x = pageOffset.x, y = pageOffset.y;\n    var documentX = x + clientRect.left;\n    var documentY = y + clientRect.top;\n    var normalizedX;\n    var normalizedY; // Determine touch point relative to the ripple container.\n    if (ev.type === 'touchstart') {\n        normalizedX = ev.changedTouches[0].pageX - documentX;\n        normalizedY = ev.changedTouches[0].pageY - documentY;\n    }\n    else {\n        normalizedX = ev.pageX - documentX;\n        normalizedY = ev.pageY - documentY;\n    }\n    return {\n        x: normalizedX,\n        y: normalizedY\n    };\n}\nvar ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs\nvar POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations\n/** @type {!Array<!EventTarget>} */\nvar activatedTargets = [];\n/**\n * @extends {MDCFoundation<!MDCRippleAdapter>}\n */\nvar MDCRippleFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCRippleFoundation, _MDCFoundation);\n    _createClass(MDCRippleFoundation, null, [{\n            key: \"cssClasses\",\n            get: function get() {\n                return cssClasses$1;\n            }\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings$2;\n            }\n        }, {\n            key: \"numbers\",\n            get: function get() {\n                return numbers;\n            }\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return {\n                    browserSupportsCssVars: function browserSupportsCssVars() { },\n                    isUnbounded: function isUnbounded() { },\n                    isSurfaceActive: function isSurfaceActive() { },\n                    isSurfaceDisabled: function isSurfaceDisabled() { },\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    containsEventTarget: function containsEventTarget() { },\n                    registerInteractionHandler: function registerInteractionHandler() { },\n                    deregisterInteractionHandler: function deregisterInteractionHandler() { },\n                    registerDocumentInteractionHandler: function registerDocumentInteractionHandler() { },\n                    deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() { },\n                    registerResizeHandler: function registerResizeHandler() { },\n                    deregisterResizeHandler: function deregisterResizeHandler() { },\n                    updateCssVariable: function updateCssVariable() { },\n                    computeBoundingRect: function computeBoundingRect() { },\n                    getWindowPageOffset: function getWindowPageOffset() { }\n                };\n            }\n        }]);\n    function MDCRippleFoundation(adapter) {\n        var _this;\n        _classCallCheck(this, MDCRippleFoundation);\n        _this = _possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));\n        /** @private {number} */\n        _this.layoutFrame_ = 0;\n        /** @private {!ClientRect} */\n        _this.frame_ =\n            /** @type {!ClientRect} */\n            {\n                width: 0,\n                height: 0\n            };\n        /** @private {!ActivationStateType} */\n        _this.activationState_ = _this.defaultActivationState_();\n        /** @private {number} */\n        _this.initialSize_ = 0;\n        /** @private {number} */\n        _this.maxRadius_ = 0;\n        /** @private {function(!Event)} */\n        _this.activateHandler_ = function (e) {\n            return _this.activate_(e);\n        };\n        /** @private {function(!Event)} */\n        _this.deactivateHandler_ = function (e) {\n            return _this.deactivate_(e);\n        };\n        /** @private {function(?Event=)} */\n        _this.focusHandler_ = function () {\n            return requestAnimationFrame(function () {\n                return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);\n            });\n        };\n        /** @private {function(?Event=)} */\n        _this.blurHandler_ = function () {\n            return requestAnimationFrame(function () {\n                return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);\n            });\n        };\n        /** @private {!Function} */\n        _this.resizeHandler_ = function () {\n            return _this.layout();\n        };\n        /** @private {{left: number, top:number}} */\n        _this.unboundedCoords_ = {\n            left: 0,\n            top: 0\n        };\n        /** @private {number} */\n        _this.fgScale_ = 0;\n        /** @private {number} */\n        _this.activationTimer_ = 0;\n        /** @private {number} */\n        _this.fgDeactivationRemovalTimer_ = 0;\n        /** @private {boolean} */\n        _this.activationAnimationHasEnded_ = false;\n        /** @private {!Function} */\n        _this.activationTimerCallback_ = function () {\n            _this.activationAnimationHasEnded_ = true;\n            _this.runDeactivationUXLogicIfReady_();\n        };\n        /** @private {?Event} */\n        _this.previousActivationEvent_ = null;\n        return _this;\n    }\n    /**\n     * We compute this property so that we are not querying information about the client\n     * until the point in time where the foundation requests it. This prevents scenarios where\n     * client-side feature-detection may happen too early, such as when components are rendered on the server\n     * and then initialized at mount time on the client.\n     * @return {boolean}\n     * @private\n     */\n    _createClass(MDCRippleFoundation, [{\n            key: \"isSupported_\",\n            value: function isSupported_() {\n                return this.adapter_.browserSupportsCssVars();\n            }\n            /**\n             * @return {!ActivationStateType}\n             */\n        }, {\n            key: \"defaultActivationState_\",\n            value: function defaultActivationState_() {\n                return {\n                    isActivated: false,\n                    hasDeactivationUXRun: false,\n                    wasActivatedByPointer: false,\n                    wasElementMadeActive: false,\n                    activationEvent: null,\n                    isProgrammatic: false\n                };\n            }\n        }, {\n            key: \"init\",\n            value: function init() {\n                var _this2 = this;\n                if (!this.isSupported_()) {\n                    return;\n                }\n                this.registerRootHandlers_();\n                var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses, ROOT = _MDCRippleFoundation$.ROOT, UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;\n                requestAnimationFrame(function () {\n                    _this2.adapter_.addClass(ROOT);\n                    if (_this2.adapter_.isUnbounded()) {\n                        _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple\n                        _this2.layoutInternal_();\n                    }\n                });\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                var _this3 = this;\n                if (!this.isSupported_()) {\n                    return;\n                }\n                if (this.activationTimer_) {\n                    clearTimeout(this.activationTimer_);\n                    this.activationTimer_ = 0;\n                    var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;\n                    this.adapter_.removeClass(FG_ACTIVATION);\n                }\n                this.deregisterRootHandlers_();\n                this.deregisterDeactivationHandlers_();\n                var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses, ROOT = _MDCRippleFoundation$2.ROOT, UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;\n                requestAnimationFrame(function () {\n                    _this3.adapter_.removeClass(ROOT);\n                    _this3.adapter_.removeClass(UNBOUNDED);\n                    _this3.removeCssVars_();\n                });\n            }\n            /** @private */\n        }, {\n            key: \"registerRootHandlers_\",\n            value: function registerRootHandlers_() {\n                var _this4 = this;\n                ACTIVATION_EVENT_TYPES.forEach(function (type) {\n                    _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);\n                });\n                this.adapter_.registerInteractionHandler('focus', this.focusHandler_);\n                this.adapter_.registerInteractionHandler('blur', this.blurHandler_);\n                if (this.adapter_.isUnbounded()) {\n                    this.adapter_.registerResizeHandler(this.resizeHandler_);\n                }\n            }\n            /**\n             * @param {!Event} e\n             * @private\n             */\n        }, {\n            key: \"registerDeactivationHandlers_\",\n            value: function registerDeactivationHandlers_(e) {\n                var _this5 = this;\n                if (e.type === 'keydown') {\n                    this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);\n                }\n                else {\n                    POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {\n                        _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);\n                    });\n                }\n            }\n            /** @private */\n        }, {\n            key: \"deregisterRootHandlers_\",\n            value: function deregisterRootHandlers_() {\n                var _this6 = this;\n                ACTIVATION_EVENT_TYPES.forEach(function (type) {\n                    _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);\n                });\n                this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);\n                this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);\n                if (this.adapter_.isUnbounded()) {\n                    this.adapter_.deregisterResizeHandler(this.resizeHandler_);\n                }\n            }\n            /** @private */\n        }, {\n            key: \"deregisterDeactivationHandlers_\",\n            value: function deregisterDeactivationHandlers_() {\n                var _this7 = this;\n                this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);\n                POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {\n                    _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);\n                });\n            }\n            /** @private */\n        }, {\n            key: \"removeCssVars_\",\n            value: function removeCssVars_() {\n                var _this8 = this;\n                var strings = MDCRippleFoundation.strings;\n                Object.keys(strings).forEach(function (k) {\n                    if (k.indexOf('VAR_') === 0) {\n                        _this8.adapter_.updateCssVariable(strings[k], null);\n                    }\n                });\n            }\n            /**\n             * @param {?Event} e\n             * @private\n             */\n        }, {\n            key: \"activate_\",\n            value: function activate_(e) {\n                var _this9 = this;\n                if (this.adapter_.isSurfaceDisabled()) {\n                    return;\n                }\n                var activationState = this.activationState_;\n                if (activationState.isActivated) {\n                    return;\n                } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction\n                var previousActivationEvent = this.previousActivationEvent_;\n                var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;\n                if (isSameInteraction) {\n                    return;\n                }\n                activationState.isActivated = true;\n                activationState.isProgrammatic = e === null;\n                activationState.activationEvent = e;\n                activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';\n                var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {\n                    return _this9.adapter_.containsEventTarget(target);\n                });\n                if (hasActivatedChild) {\n                    // Immediately reset activation state, while preserving logic that prevents touch follow-on events\n                    this.resetActivationState_();\n                    return;\n                }\n                if (e) {\n                    activatedTargets.push(\n                    /** @type {!EventTarget} */\n                    e.target);\n                    this.registerDeactivationHandlers_(e);\n                }\n                activationState.wasElementMadeActive = this.checkElementMadeActive_(e);\n                if (activationState.wasElementMadeActive) {\n                    this.animateActivation_();\n                }\n                requestAnimationFrame(function () {\n                    // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples\n                    activatedTargets = [];\n                    if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {\n                        // If space was pressed, try again within an rAF call to detect :active, because different UAs report\n                        // active states inconsistently when they're called within event handling code:\n                        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971\n                        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741\n                        // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS\n                        // variable is set within a rAF callback for a submit button interaction (#2241).\n                        activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);\n                        if (activationState.wasElementMadeActive) {\n                            _this9.animateActivation_();\n                        }\n                    }\n                    if (!activationState.wasElementMadeActive) {\n                        // Reset activation state immediately if element was not made active.\n                        _this9.activationState_ = _this9.defaultActivationState_();\n                    }\n                });\n            }\n            /**\n             * @param {?Event} e\n             * @private\n             */\n        }, {\n            key: \"checkElementMadeActive_\",\n            value: function checkElementMadeActive_(e) {\n                return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;\n            }\n            /**\n             * @param {?Event=} event Optional event containing position information.\n             */\n        }, {\n            key: \"activate\",\n            value: function activate() {\n                var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n                this.activate_(event);\n            }\n            /** @private */\n        }, {\n            key: \"animateActivation_\",\n            value: function animateActivation_() {\n                var _this10 = this;\n                var _MDCRippleFoundation$3 = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;\n                var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION, FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;\n                var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;\n                this.layoutInternal_();\n                var translateStart = '';\n                var translateEnd = '';\n                if (!this.adapter_.isUnbounded()) {\n                    var _getFgTranslationCoor = this.getFgTranslationCoordinates_(), startPoint = _getFgTranslationCoor.startPoint, endPoint = _getFgTranslationCoor.endPoint;\n                    translateStart = \"\".concat(startPoint.x, \"px, \").concat(startPoint.y, \"px\");\n                    translateEnd = \"\".concat(endPoint.x, \"px, \").concat(endPoint.y, \"px\");\n                }\n                this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);\n                this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations\n                clearTimeout(this.activationTimer_);\n                clearTimeout(this.fgDeactivationRemovalTimer_);\n                this.rmBoundedActivationClasses_();\n                this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.\n                this.adapter_.computeBoundingRect();\n                this.adapter_.addClass(FG_ACTIVATION);\n                this.activationTimer_ = setTimeout(function () {\n                    return _this10.activationTimerCallback_();\n                }, DEACTIVATION_TIMEOUT_MS);\n            }\n            /**\n             * @private\n             * @return {{startPoint: PointType, endPoint: PointType}}\n             */\n        }, {\n            key: \"getFgTranslationCoordinates_\",\n            value: function getFgTranslationCoordinates_() {\n                var _activationState_ = this.activationState_, activationEvent = _activationState_.activationEvent, wasActivatedByPointer = _activationState_.wasActivatedByPointer;\n                var startPoint;\n                if (wasActivatedByPointer) {\n                    startPoint = getNormalizedEventCoords(\n                    /** @type {!Event} */\n                    activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());\n                }\n                else {\n                    startPoint = {\n                        x: this.frame_.width / 2,\n                        y: this.frame_.height / 2\n                    };\n                } // Center the element around the start point.\n                startPoint = {\n                    x: startPoint.x - this.initialSize_ / 2,\n                    y: startPoint.y - this.initialSize_ / 2\n                };\n                var endPoint = {\n                    x: this.frame_.width / 2 - this.initialSize_ / 2,\n                    y: this.frame_.height / 2 - this.initialSize_ / 2\n                };\n                return {\n                    startPoint: startPoint,\n                    endPoint: endPoint\n                };\n            }\n            /** @private */\n        }, {\n            key: \"runDeactivationUXLogicIfReady_\",\n            value: function runDeactivationUXLogicIfReady_() {\n                var _this11 = this;\n                // This method is called both when a pointing device is released, and when the activation animation ends.\n                // The deactivation animation should only run after both of those occur.\n                var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;\n                var _activationState_2 = this.activationState_, hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun, isActivated = _activationState_2.isActivated;\n                var activationHasEnded = hasDeactivationUXRun || !isActivated;\n                if (activationHasEnded && this.activationAnimationHasEnded_) {\n                    this.rmBoundedActivationClasses_();\n                    this.adapter_.addClass(FG_DEACTIVATION);\n                    this.fgDeactivationRemovalTimer_ = setTimeout(function () {\n                        _this11.adapter_.removeClass(FG_DEACTIVATION);\n                    }, numbers.FG_DEACTIVATION_MS);\n                }\n            }\n            /** @private */\n        }, {\n            key: \"rmBoundedActivationClasses_\",\n            value: function rmBoundedActivationClasses_() {\n                var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;\n                this.adapter_.removeClass(FG_ACTIVATION);\n                this.activationAnimationHasEnded_ = false;\n                this.adapter_.computeBoundingRect();\n            }\n        }, {\n            key: \"resetActivationState_\",\n            value: function resetActivationState_() {\n                var _this12 = this;\n                this.previousActivationEvent_ = this.activationState_.activationEvent;\n                this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.\n                // Store the previous event until it's safe to assume that subsequent events are for new interactions.\n                setTimeout(function () {\n                    return _this12.previousActivationEvent_ = null;\n                }, MDCRippleFoundation.numbers.TAP_DELAY_MS);\n            }\n            /**\n             * @param {?Event} e\n             * @private\n             */\n        }, {\n            key: \"deactivate_\",\n            value: function deactivate_(e) {\n                var _this13 = this;\n                var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.\n                if (!activationState.isActivated) {\n                    return;\n                }\n                var state = \n                /** @type {!ActivationStateType} */\n                Object.assign({}, activationState);\n                if (activationState.isProgrammatic) {\n                    var evtObject = null;\n                    requestAnimationFrame(function () {\n                        return _this13.animateDeactivation_(evtObject, state);\n                    });\n                    this.resetActivationState_();\n                }\n                else {\n                    this.deregisterDeactivationHandlers_();\n                    requestAnimationFrame(function () {\n                        _this13.activationState_.hasDeactivationUXRun = true;\n                        _this13.animateDeactivation_(e, state);\n                        _this13.resetActivationState_();\n                    });\n                }\n            }\n            /**\n             * @param {?Event=} event Optional event containing position information.\n             */\n        }, {\n            key: \"deactivate\",\n            value: function deactivate() {\n                var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n                this.deactivate_(event);\n            }\n            /**\n             * @param {Event} e\n             * @param {!ActivationStateType} options\n             * @private\n             */\n        }, {\n            key: \"animateDeactivation_\",\n            value: function animateDeactivation_(e, _ref) {\n                var wasActivatedByPointer = _ref.wasActivatedByPointer, wasElementMadeActive = _ref.wasElementMadeActive;\n                if (wasActivatedByPointer || wasElementMadeActive) {\n                    this.runDeactivationUXLogicIfReady_();\n                }\n            }\n        }, {\n            key: \"layout\",\n            value: function layout() {\n                var _this14 = this;\n                if (this.layoutFrame_) {\n                    cancelAnimationFrame(this.layoutFrame_);\n                }\n                this.layoutFrame_ = requestAnimationFrame(function () {\n                    _this14.layoutInternal_();\n                    _this14.layoutFrame_ = 0;\n                });\n            }\n            /** @private */\n        }, {\n            key: \"layoutInternal_\",\n            value: function layoutInternal_() {\n                var _this15 = this;\n                this.frame_ = this.adapter_.computeBoundingRect();\n                var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.\n                // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately\n                // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically\n                // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter\n                // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via\n                // `overflow: hidden`.\n                var getBoundedRadius = function getBoundedRadius() {\n                    var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));\n                    return hypotenuse + MDCRippleFoundation.numbers.PADDING;\n                };\n                this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform\n                this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;\n                this.fgScale_ = this.maxRadius_ / this.initialSize_;\n                this.updateLayoutCssVars_();\n            }\n            /** @private */\n        }, {\n            key: \"updateLayoutCssVars_\",\n            value: function updateLayoutCssVars_() {\n                var _MDCRippleFoundation$5 = MDCRippleFoundation.strings, VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE, VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT, VAR_TOP = _MDCRippleFoundation$5.VAR_TOP, VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;\n                this.adapter_.updateCssVariable(VAR_FG_SIZE, \"\".concat(this.initialSize_, \"px\"));\n                this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);\n                if (this.adapter_.isUnbounded()) {\n                    this.unboundedCoords_ = {\n                        left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),\n                        top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)\n                    };\n                    this.adapter_.updateCssVariable(VAR_LEFT, \"\".concat(this.unboundedCoords_.left, \"px\"));\n                    this.adapter_.updateCssVariable(VAR_TOP, \"\".concat(this.unboundedCoords_.top, \"px\"));\n                }\n            }\n            /** @param {boolean} unbounded */\n        }, {\n            key: \"setUnbounded\",\n            value: function setUnbounded(unbounded) {\n                var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;\n                if (unbounded) {\n                    this.adapter_.addClass(UNBOUNDED);\n                }\n                else {\n                    this.adapter_.removeClass(UNBOUNDED);\n                }\n            }\n        }]);\n    return MDCRippleFoundation;\n}(MDCFoundation);\n/**\n * @extends MDCComponent<!MDCRippleFoundation>\n */\nvar MDCRipple = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCRipple, _MDCComponent);\n    /** @param {...?} args */\n    function MDCRipple() {\n        var _ref;\n        var _this;\n        _classCallCheck(this, MDCRipple);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));\n        /** @type {boolean} */\n        _this.disabled = false;\n        /** @private {boolean} */\n        _this.unbounded_;\n        return _this;\n    }\n    /**\n     * @param {!Element} root\n     * @param {{isUnbounded: (boolean|undefined)}=} options\n     * @return {!MDCRipple}\n     */\n    _createClass(MDCRipple, [{\n            key: \"setUnbounded_\",\n            /**\n             * Closure Compiler throws an access control error when directly accessing a\n             * protected or private property inside a getter/setter, like unbounded above.\n             * By accessing the protected property inside a method, we solve that problem.\n             * That's why this function exists.\n             * @private\n             */\n            value: function setUnbounded_() {\n                this.foundation_.setUnbounded(this.unbounded_);\n            }\n        }, {\n            key: \"activate\",\n            value: function activate() {\n                this.foundation_.activate();\n            }\n        }, {\n            key: \"deactivate\",\n            value: function deactivate() {\n                this.foundation_.deactivate();\n            }\n        }, {\n            key: \"layout\",\n            value: function layout() {\n                this.foundation_.layout();\n            }\n            /** @return {!MDCRippleFoundation} */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                return new MDCRippleFoundation(MDCRipple.createAdapter(this));\n            }\n        }, {\n            key: \"initialSyncWithDOM\",\n            value: function initialSyncWithDOM() {\n                this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;\n            }\n        }, {\n            key: \"unbounded\",\n            /** @return {boolean} */\n            get: function get() {\n                return this.unbounded_;\n            }\n            /** @param {boolean} unbounded */\n            ,\n            set: function set(unbounded) {\n                this.unbounded_ = Boolean(unbounded);\n                this.setUnbounded_();\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref2$isUnbounded = _ref2.isUnbounded, isUnbounded = _ref2$isUnbounded === void 0 ? undefined : _ref2$isUnbounded;\n                var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified\n                if (isUnbounded !== undefined) {\n                    ripple.unbounded =\n                        /** @type {boolean} */\n                        isUnbounded;\n                }\n                return ripple;\n            }\n            /**\n             * @param {!RippleCapableSurface} instance\n             * @return {!MDCRippleAdapter}\n             */\n        }, {\n            key: \"createAdapter\",\n            value: function createAdapter(instance) {\n                var MATCHES = getMatchesProperty(HTMLElement.prototype);\n                return {\n                    browserSupportsCssVars: function browserSupportsCssVars() {\n                        return supportsCssVariables(window);\n                    },\n                    isUnbounded: function isUnbounded() {\n                        return instance.unbounded;\n                    },\n                    isSurfaceActive: function isSurfaceActive() {\n                        return instance.root_[MATCHES](':active');\n                    },\n                    isSurfaceDisabled: function isSurfaceDisabled() {\n                        return instance.disabled;\n                    },\n                    addClass: function addClass(className) {\n                        return instance.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return instance.root_.classList.remove(className);\n                    },\n                    containsEventTarget: function containsEventTarget(target) {\n                        return instance.root_.contains(target);\n                    },\n                    registerInteractionHandler: function registerInteractionHandler(evtType, handler) {\n                        return instance.root_.addEventListener(evtType, handler, applyPassive());\n                    },\n                    deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {\n                        return instance.root_.removeEventListener(evtType, handler, applyPassive());\n                    },\n                    registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {\n                        return document.documentElement.addEventListener(evtType, handler, applyPassive());\n                    },\n                    deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {\n                        return document.documentElement.removeEventListener(evtType, handler, applyPassive());\n                    },\n                    registerResizeHandler: function registerResizeHandler(handler) {\n                        return window.addEventListener('resize', handler);\n                    },\n                    deregisterResizeHandler: function deregisterResizeHandler(handler) {\n                        return window.removeEventListener('resize', handler);\n                    },\n                    updateCssVariable: function updateCssVariable(varName, value) {\n                        return instance.root_.style.setProperty(varName, value);\n                    },\n                    computeBoundingRect: function computeBoundingRect() {\n                        return instance.root_.getBoundingClientRect();\n                    },\n                    getWindowPageOffset: function getWindowPageOffset() {\n                        return {\n                            x: window.pageXOffset,\n                            y: window.pageYOffset\n                        };\n                    }\n                };\n            }\n        }]);\n    return MDCRipple;\n}(MDCComponent);\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @enum {string} */\nvar strings$3 = {\n    ARIA_CONTROLS: 'aria-controls',\n    INPUT_SELECTOR: '.mdc-text-field__input',\n    LABEL_SELECTOR: '.mdc-floating-label',\n    ICON_SELECTOR: '.mdc-text-field__icon',\n    OUTLINE_SELECTOR: '.mdc-notched-outline',\n    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple'\n};\n/** @enum {string} */\nvar cssClasses$2 = {\n    ROOT: 'mdc-text-field',\n    UPGRADED: 'mdc-text-field--upgraded',\n    DISABLED: 'mdc-text-field--disabled',\n    DENSE: 'mdc-text-field--dense',\n    FOCUSED: 'mdc-text-field--focused',\n    INVALID: 'mdc-text-field--invalid',\n    BOX: 'mdc-text-field--box',\n    OUTLINED: 'mdc-text-field--outlined'\n};\n/** @enum {number} */\nvar numbers$1 = {\n    LABEL_SCALE: 0.75,\n    DENSE_LABEL_SCALE: 0.923\n}; // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation\n// under section: `Validation-related attributes`\nvar VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];\n/**\n * Adapter for MDC Text Field.\n *\n * Defines the shape of the adapter expected by the foundation. Implement this\n * adapter to integrate the Text Field into your framework. See\n * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md\n * for more information.\n *\n * @record\n */\nvar MDCTextFieldAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCTextFieldAdapter() {\n        _classCallCheck(this, MDCTextFieldAdapter);\n    }\n    _createClass(MDCTextFieldAdapter, [{\n            key: \"addClass\",\n            /**\n             * Adds a class to the root Element.\n             * @param {string} className\n             */\n            value: function addClass(className) { }\n            /**\n             * Removes a class from the root Element.\n             * @param {string} className\n             */\n        }, {\n            key: \"removeClass\",\n            value: function removeClass(className) { }\n            /**\n             * Returns true if the root element contains the given class name.\n             * @param {string} className\n             * @return {boolean}\n             */\n        }, {\n            key: \"hasClass\",\n            value: function hasClass(className) { }\n            /**\n             * Registers an event handler on the root element for a given event.\n             * @param {string} type\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"registerTextFieldInteractionHandler\",\n            value: function registerTextFieldInteractionHandler(type, handler) { }\n            /**\n             * Deregisters an event handler on the root element for a given event.\n             * @param {string} type\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"deregisterTextFieldInteractionHandler\",\n            value: function deregisterTextFieldInteractionHandler(type, handler) { }\n            /**\n             * Registers an event listener on the native input element for a given event.\n             * @param {string} evtType\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"registerInputInteractionHandler\",\n            value: function registerInputInteractionHandler(evtType, handler) { }\n            /**\n             * Deregisters an event listener on the native input element for a given event.\n             * @param {string} evtType\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"deregisterInputInteractionHandler\",\n            value: function deregisterInputInteractionHandler(evtType, handler) { }\n            /**\n             * Registers a validation attribute change listener on the input element.\n             * Handler accepts list of attribute names.\n             * @param {function(!Array<string>): undefined} handler\n             * @return {!MutationObserver}\n             */\n        }, {\n            key: \"registerValidationAttributeChangeHandler\",\n            value: function registerValidationAttributeChangeHandler(handler) { }\n            /**\n             * Disconnects a validation attribute observer on the input element.\n             * @param {!MutationObserver} observer\n             */\n        }, {\n            key: \"deregisterValidationAttributeChangeHandler\",\n            value: function deregisterValidationAttributeChangeHandler(observer) { }\n            /**\n             * Returns an object representing the native text input element, with a\n             * similar API shape. The object returned should include the value, disabled\n             * and badInput properties, as well as the checkValidity() function. We never\n             * alter the value within our code, however we do update the disabled\n             * property, so if you choose to duck-type the return value for this method\n             * in your implementation it's important to keep this in mind. Also note that\n             * this method can return null, which the foundation will handle gracefully.\n             * @return {?Element|?NativeInputType}\n             */\n        }, {\n            key: \"getNativeInput\",\n            value: function getNativeInput() { }\n            /**\n             * Returns true if the textfield is focused.\n             * We achieve this via `document.activeElement === this.root_`.\n             * @return {boolean}\n             */\n        }, {\n            key: \"isFocused\",\n            value: function isFocused() { }\n            /**\n             * Returns true if the direction of the root element is set to RTL.\n             * @return {boolean}\n             */\n        }, {\n            key: \"isRtl\",\n            value: function isRtl() { }\n            /**\n             * Activates the line ripple.\n             */\n        }, {\n            key: \"activateLineRipple\",\n            value: function activateLineRipple() { }\n            /**\n             * Deactivates the line ripple.\n             */\n        }, {\n            key: \"deactivateLineRipple\",\n            value: function deactivateLineRipple() { }\n            /**\n             * Sets the transform origin of the line ripple.\n             * @param {number} normalizedX\n             */\n        }, {\n            key: \"setLineRippleTransformOrigin\",\n            value: function setLineRippleTransformOrigin(normalizedX) { }\n            /**\n             * Only implement if label exists.\n             * Shakes label if shouldShake is true.\n             * @param {boolean} shouldShake\n             */\n        }, {\n            key: \"shakeLabel\",\n            value: function shakeLabel(shouldShake) { }\n            /**\n             * Only implement if label exists.\n             * Floats the label above the input element if shouldFloat is true.\n             * @param {boolean} shouldFloat\n             */\n        }, {\n            key: \"floatLabel\",\n            value: function floatLabel(shouldFloat) { }\n            /**\n             * Returns true if label element exists, false if it doesn't.\n             * @return {boolean}\n             */\n        }, {\n            key: \"hasLabel\",\n            value: function hasLabel() { }\n            /**\n             * Only implement if label exists.\n             * Returns width of label in pixels.\n             * @return {number}\n             */\n        }, {\n            key: \"getLabelWidth\",\n            value: function getLabelWidth() { }\n            /**\n             * Returns true if outline element exists, false if it doesn't.\n             * @return {boolean}\n             */\n        }, {\n            key: \"hasOutline\",\n            value: function hasOutline() { }\n            /**\n             * Only implement if outline element exists.\n             * Updates SVG Path and outline element based on the\n             * label element width and RTL context.\n             * @param {number} labelWidth\n             * @param {boolean=} isRtl\n             */\n        }, {\n            key: \"notchOutline\",\n            value: function notchOutline(labelWidth, isRtl) { }\n            /**\n             * Only implement if outline element exists.\n             * Closes notch in outline element.\n             */\n        }, {\n            key: \"closeOutline\",\n            value: function closeOutline() { }\n        }]);\n    return MDCTextFieldAdapter;\n}();\n/**\n * @extends {MDCFoundation<!MDCTextFieldAdapter>}\n * @final\n */\nvar MDCTextFieldFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCTextFieldFoundation, _MDCFoundation);\n    _createClass(MDCTextFieldFoundation, [{\n            key: \"shouldShake\",\n            /** @return {boolean} */\n            get: function get() {\n                return !this.isValid() && !this.isFocused_;\n            }\n            /** @return {boolean} */\n        }, {\n            key: \"shouldFloat\",\n            get: function get() {\n                return this.isFocused_ || !!this.getValue() || this.isBadInput_();\n            }\n            /**\n             * {@see MDCTextFieldAdapter} for typing information on parameters and return\n             * types.\n             * @return {!MDCTextFieldAdapter}\n             */\n        }], [{\n            key: \"cssClasses\",\n            /** @return enum {string} */\n            get: function get() {\n                return cssClasses$2;\n            }\n            /** @return enum {string} */\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings$3;\n            }\n            /** @return enum {string} */\n        }, {\n            key: \"numbers\",\n            get: function get() {\n                return numbers$1;\n            }\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return (\n                /** @type {!MDCTextFieldAdapter} */\n                {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    hasClass: function hasClass() { },\n                    registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() { },\n                    deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() { },\n                    registerInputInteractionHandler: function registerInputInteractionHandler() { },\n                    deregisterInputInteractionHandler: function deregisterInputInteractionHandler() { },\n                    registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() { },\n                    deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() { },\n                    getNativeInput: function getNativeInput() { },\n                    isFocused: function isFocused() { },\n                    isRtl: function isRtl() { },\n                    activateLineRipple: function activateLineRipple() { },\n                    deactivateLineRipple: function deactivateLineRipple() { },\n                    setLineRippleTransformOrigin: function setLineRippleTransformOrigin() { },\n                    shakeLabel: function shakeLabel() { },\n                    floatLabel: function floatLabel() { },\n                    hasLabel: function hasLabel() { },\n                    getLabelWidth: function getLabelWidth() { },\n                    hasOutline: function hasOutline() { },\n                    notchOutline: function notchOutline() { },\n                    closeOutline: function closeOutline() { }\n                });\n            }\n            /**\n             * @param {!MDCTextFieldAdapter} adapter\n             * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.\n             */\n        }]);\n    function MDCTextFieldFoundation(adapter) {\n        var _this;\n        var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :\n            /** @type {!FoundationMapType} */\n            {};\n        _classCallCheck(this, MDCTextFieldFoundation);\n        _this = _possibleConstructorReturn(this, (MDCTextFieldFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldFoundation)).call(this, Object.assign(MDCTextFieldFoundation.defaultAdapter, adapter)));\n        /** @type {!MDCTextFieldHelperTextFoundation|undefined} */\n        _this.helperText_ = foundationMap.helperText;\n        /** @type {!MDCTextFieldIconFoundation|undefined} */\n        _this.icon_ = foundationMap.icon;\n        /** @private {boolean} */\n        _this.isFocused_ = false;\n        /** @private {boolean} */\n        _this.receivedUserInput_ = false;\n        /** @private {boolean} */\n        _this.useCustomValidityChecking_ = false;\n        /** @private {boolean} */\n        _this.isValid_ = true;\n        /** @private {function(): undefined} */\n        _this.inputFocusHandler_ = function () {\n            return _this.activateFocus();\n        };\n        /** @private {function(): undefined} */\n        _this.inputBlurHandler_ = function () {\n            return _this.deactivateFocus();\n        };\n        /** @private {function(): undefined} */\n        _this.inputInputHandler_ = function () {\n            return _this.autoCompleteFocus();\n        };\n        /** @private {function(!Event): undefined} */\n        _this.setPointerXOffset_ = function (evt) {\n            return _this.setTransformOrigin(evt);\n        };\n        /** @private {function(!Event): undefined} */\n        _this.textFieldInteractionHandler_ = function () {\n            return _this.handleTextFieldInteraction();\n        };\n        /** @private {function(!Array): undefined} */\n        _this.validationAttributeChangeHandler_ = function (attributesList) {\n            return _this.handleValidationAttributeChange(attributesList);\n        };\n        /** @private {!MutationObserver} */\n        _this.validationObserver_;\n        return _this;\n    }\n    _createClass(MDCTextFieldFoundation, [{\n            key: \"init\",\n            value: function init() {\n                var _this2 = this;\n                this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED); // Ensure label does not collide with any pre-filled value.\n                if (this.adapter_.hasLabel() && (this.getValue() || this.isBadInput_())) {\n                    this.adapter_.floatLabel(this.shouldFloat);\n                    this.notchOutline(this.shouldFloat);\n                }\n                if (this.adapter_.isFocused()) {\n                    this.inputFocusHandler_();\n                }\n                this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);\n                this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);\n                this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);\n                ['mousedown', 'touchstart'].forEach(function (evtType) {\n                    _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);\n                });\n                ['click', 'keydown'].forEach(function (evtType) {\n                    _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);\n                });\n                this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                var _this3 = this;\n                this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);\n                this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);\n                this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);\n                this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);\n                ['mousedown', 'touchstart'].forEach(function (evtType) {\n                    _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);\n                });\n                ['click', 'keydown'].forEach(function (evtType) {\n                    _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);\n                });\n                this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);\n            }\n            /**\n             * Handles user interactions with the Text Field.\n             */\n        }, {\n            key: \"handleTextFieldInteraction\",\n            value: function handleTextFieldInteraction() {\n                if (this.adapter_.getNativeInput().disabled) {\n                    return;\n                }\n                this.receivedUserInput_ = true;\n            }\n            /**\n             * Handles validation attribute changes\n             * @param {!Array<string>} attributesList\n             */\n        }, {\n            key: \"handleValidationAttributeChange\",\n            value: function handleValidationAttributeChange(attributesList) {\n                var _this4 = this;\n                attributesList.some(function (attributeName) {\n                    if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {\n                        _this4.styleValidity_(true);\n                        return true;\n                    }\n                });\n            }\n            /**\n             * Opens/closes the notched outline.\n             * @param {boolean} openNotch\n             */\n        }, {\n            key: \"notchOutline\",\n            value: function notchOutline(openNotch) {\n                if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {\n                    return;\n                }\n                if (openNotch) {\n                    var isDense = this.adapter_.hasClass(cssClasses$2.DENSE);\n                    var labelScale = isDense ? numbers$1.DENSE_LABEL_SCALE : numbers$1.LABEL_SCALE;\n                    var labelWidth = this.adapter_.getLabelWidth() * labelScale;\n                    var isRtl = this.adapter_.isRtl();\n                    this.adapter_.notchOutline(labelWidth, isRtl);\n                }\n                else {\n                    this.adapter_.closeOutline();\n                }\n            }\n            /**\n             * Activates the text field focus state.\n             */\n        }, {\n            key: \"activateFocus\",\n            value: function activateFocus() {\n                this.isFocused_ = true;\n                this.styleFocused_(this.isFocused_);\n                this.adapter_.activateLineRipple();\n                this.notchOutline(this.shouldFloat);\n                if (this.adapter_.hasLabel()) {\n                    this.adapter_.shakeLabel(this.shouldShake);\n                    this.adapter_.floatLabel(this.shouldFloat);\n                }\n                if (this.helperText_) {\n                    this.helperText_.showToScreenReader();\n                }\n            }\n            /**\n             * Sets the line ripple's transform origin, so that the line ripple activate\n             * animation will animate out from the user's click location.\n             * @param {!Event} evt\n             */\n        }, {\n            key: \"setTransformOrigin\",\n            value: function setTransformOrigin(evt) {\n                var targetClientRect = evt.target.getBoundingClientRect();\n                var evtCoords = {\n                    x: evt.clientX,\n                    y: evt.clientY\n                };\n                var normalizedX = evtCoords.x - targetClientRect.left;\n                this.adapter_.setLineRippleTransformOrigin(normalizedX);\n            }\n            /**\n             * Activates the Text Field's focus state in cases when the input value\n             * changes without user input (e.g. programatically).\n             */\n        }, {\n            key: \"autoCompleteFocus\",\n            value: function autoCompleteFocus() {\n                if (!this.receivedUserInput_) {\n                    this.activateFocus();\n                }\n            }\n            /**\n             * Deactivates the Text Field's focus state.\n             */\n        }, {\n            key: \"deactivateFocus\",\n            value: function deactivateFocus() {\n                this.isFocused_ = false;\n                this.adapter_.deactivateLineRipple();\n                var input = this.getNativeInput_();\n                var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();\n                var isValid = this.isValid();\n                this.styleValidity_(isValid);\n                this.styleFocused_(this.isFocused_);\n                if (this.adapter_.hasLabel()) {\n                    this.adapter_.shakeLabel(this.shouldShake);\n                    this.adapter_.floatLabel(this.shouldFloat);\n                    this.notchOutline(this.shouldFloat);\n                }\n                if (shouldRemoveLabelFloat) {\n                    this.receivedUserInput_ = false;\n                }\n            }\n            /**\n             * @return {string} The value of the input Element.\n             */\n        }, {\n            key: \"getValue\",\n            value: function getValue() {\n                return this.getNativeInput_().value;\n            }\n            /**\n             * @param {string} value The value to set on the input Element.\n             */\n        }, {\n            key: \"setValue\",\n            value: function setValue(value) {\n                this.getNativeInput_().value = value;\n                var isValid = this.isValid();\n                this.styleValidity_(isValid);\n                if (this.adapter_.hasLabel()) {\n                    this.adapter_.shakeLabel(this.shouldShake);\n                    this.adapter_.floatLabel(this.shouldFloat);\n                    this.notchOutline(this.shouldFloat);\n                }\n            }\n            /**\n             * @return {boolean} If a custom validity is set, returns that value.\n             *     Otherwise, returns the result of native validity checks.\n             */\n        }, {\n            key: \"isValid\",\n            value: function isValid() {\n                return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();\n            }\n            /**\n             * @param {boolean} isValid Sets the validity state of the Text Field.\n             */\n        }, {\n            key: \"setValid\",\n            value: function setValid(isValid) {\n                this.useCustomValidityChecking_ = true;\n                this.isValid_ = isValid; // Retrieve from the getter to ensure correct logic is applied.\n                isValid = this.isValid();\n                this.styleValidity_(isValid);\n                if (this.adapter_.hasLabel()) {\n                    this.adapter_.shakeLabel(this.shouldShake);\n                }\n            }\n            /**\n             * @return {boolean} True if the Text Field is disabled.\n             */\n        }, {\n            key: \"isDisabled\",\n            value: function isDisabled() {\n                return this.getNativeInput_().disabled;\n            }\n            /**\n             * @param {boolean} disabled Sets the text-field disabled or enabled.\n             */\n        }, {\n            key: \"setDisabled\",\n            value: function setDisabled(disabled) {\n                this.getNativeInput_().disabled = disabled;\n                this.styleDisabled_(disabled);\n            }\n            /**\n             * @param {string} content Sets the content of the helper text.\n             */\n        }, {\n            key: \"setHelperTextContent\",\n            value: function setHelperTextContent(content) {\n                if (this.helperText_) {\n                    this.helperText_.setContent(content);\n                }\n            }\n            /**\n             * Sets the aria label of the icon.\n             * @param {string} label\n             */\n        }, {\n            key: \"setIconAriaLabel\",\n            value: function setIconAriaLabel(label) {\n                if (this.icon_) {\n                    this.icon_.setAriaLabel(label);\n                }\n            }\n            /**\n             * Sets the text content of the icon.\n             * @param {string} content\n             */\n        }, {\n            key: \"setIconContent\",\n            value: function setIconContent(content) {\n                if (this.icon_) {\n                    this.icon_.setContent(content);\n                }\n            }\n            /**\n             * @return {boolean} True if the Text Field input fails in converting the\n             *     user-supplied value.\n             * @private\n             */\n        }, {\n            key: \"isBadInput_\",\n            value: function isBadInput_() {\n                return this.getNativeInput_().validity.badInput;\n            }\n            /**\n             * @return {boolean} The result of native validity checking\n             *     (ValidityState.valid).\n             */\n        }, {\n            key: \"isNativeInputValid_\",\n            value: function isNativeInputValid_() {\n                return this.getNativeInput_().validity.valid;\n            }\n            /**\n             * Styles the component based on the validity state.\n             * @param {boolean} isValid\n             * @private\n             */\n        }, {\n            key: \"styleValidity_\",\n            value: function styleValidity_(isValid) {\n                var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;\n                if (isValid) {\n                    this.adapter_.removeClass(INVALID);\n                }\n                else {\n                    this.adapter_.addClass(INVALID);\n                }\n                if (this.helperText_) {\n                    this.helperText_.setValidity(isValid);\n                }\n            }\n            /**\n             * Styles the component based on the focused state.\n             * @param {boolean} isFocused\n             * @private\n             */\n        }, {\n            key: \"styleFocused_\",\n            value: function styleFocused_(isFocused) {\n                var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;\n                if (isFocused) {\n                    this.adapter_.addClass(FOCUSED);\n                }\n                else {\n                    this.adapter_.removeClass(FOCUSED);\n                }\n            }\n            /**\n             * Styles the component based on the disabled state.\n             * @param {boolean} isDisabled\n             * @private\n             */\n        }, {\n            key: \"styleDisabled_\",\n            value: function styleDisabled_(isDisabled) {\n                var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses, DISABLED = _MDCTextFieldFoundati.DISABLED, INVALID = _MDCTextFieldFoundati.INVALID;\n                if (isDisabled) {\n                    this.adapter_.addClass(DISABLED);\n                    this.adapter_.removeClass(INVALID);\n                }\n                else {\n                    this.adapter_.removeClass(DISABLED);\n                }\n                if (this.icon_) {\n                    this.icon_.setDisabled(isDisabled);\n                }\n            }\n            /**\n             * @return {!Element|!NativeInputType} The native text input from the\n             * host environment, or a dummy if none exists.\n             * @private\n             */\n        }, {\n            key: \"getNativeInput_\",\n            value: function getNativeInput_() {\n                return this.adapter_.getNativeInput() ||\n                    /** @type {!NativeInputType} */\n                    {\n                        value: '',\n                        disabled: false,\n                        validity: {\n                            badInput: false,\n                            valid: true\n                        }\n                    };\n            }\n        }]);\n    return MDCTextFieldFoundation;\n}(MDCFoundation);\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n/**\n * Adapter for MDC TextField Line Ripple.\n *\n * Defines the shape of the adapter expected by the foundation. Implement this\n * adapter to integrate the line ripple into your framework. See\n * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md\n * for more information.\n *\n * @record\n */\nvar MDCLineRippleAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCLineRippleAdapter() {\n        _classCallCheck(this, MDCLineRippleAdapter);\n    }\n    _createClass(MDCLineRippleAdapter, [{\n            key: \"addClass\",\n            /**\n             * Adds a class to the line ripple element.\n             * @param {string} className\n             */\n            value: function addClass(className) { }\n            /**\n             * Removes a class from the line ripple element.\n             * @param {string} className\n             */\n        }, {\n            key: \"removeClass\",\n            value: function removeClass(className) { }\n            /**\n             * @param {string} className\n             * @return {boolean}\n             */\n        }, {\n            key: \"hasClass\",\n            value: function hasClass(className) { }\n            /**\n             * Sets the style property with propertyName to value on the root element.\n             * @param {string} propertyName\n             * @param {string} value\n             */\n        }, {\n            key: \"setStyle\",\n            value: function setStyle(propertyName, value) { }\n            /**\n             * Registers an event listener on the line ripple element for a given event.\n             * @param {string} evtType\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"registerEventHandler\",\n            value: function registerEventHandler(evtType, handler) { }\n            /**\n             * Deregisters an event listener on the line ripple element for a given event.\n             * @param {string} evtType\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"deregisterEventHandler\",\n            value: function deregisterEventHandler(evtType, handler) { }\n        }]);\n    return MDCLineRippleAdapter;\n}();\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @enum {string} */\nvar cssClasses$3 = {\n    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',\n    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'\n};\n/**\n * @extends {MDCFoundation<!MDCLineRippleAdapter>}\n * @final\n */\nvar MDCLineRippleFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCLineRippleFoundation, _MDCFoundation);\n    _createClass(MDCLineRippleFoundation, null, [{\n            key: \"cssClasses\",\n            /** @return enum {string} */\n            get: function get() {\n                return cssClasses$3;\n            }\n            /**\n             * {@see MDCLineRippleAdapter} for typing information on parameters and return\n             * types.\n             * @return {!MDCLineRippleAdapter}\n             */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return (\n                /** @type {!MDCLineRippleAdapter} */\n                {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    hasClass: function hasClass() { },\n                    setStyle: function setStyle() { },\n                    registerEventHandler: function registerEventHandler() { },\n                    deregisterEventHandler: function deregisterEventHandler() { }\n                });\n            }\n            /**\n             * @param {!MDCLineRippleAdapter=} adapter\n             */\n        }]);\n    function MDCLineRippleFoundation() {\n        var _this;\n        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] :\n            /** @type {!MDCLineRippleAdapter} */\n            {};\n        _classCallCheck(this, MDCLineRippleFoundation);\n        _this = _possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));\n        /** @private {function(!Event): undefined} */\n        _this.transitionEndHandler_ = function (evt) {\n            return _this.handleTransitionEnd(evt);\n        };\n        return _this;\n    }\n    _createClass(MDCLineRippleFoundation, [{\n            key: \"init\",\n            value: function init() {\n                this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);\n            }\n            /**\n             * Activates the line ripple\n             */\n        }, {\n            key: \"activate\",\n            value: function activate() {\n                this.adapter_.removeClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);\n                this.adapter_.addClass(cssClasses$3.LINE_RIPPLE_ACTIVE);\n            }\n            /**\n             * Sets the center of the ripple animation to the given X coordinate.\n             * @param {number} xCoordinate\n             */\n        }, {\n            key: \"setRippleCenter\",\n            value: function setRippleCenter(xCoordinate) {\n                this.adapter_.setStyle('transform-origin', \"\".concat(xCoordinate, \"px center\"));\n            }\n            /**\n             * Deactivates the line ripple\n             */\n        }, {\n            key: \"deactivate\",\n            value: function deactivate() {\n                this.adapter_.addClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);\n            }\n            /**\n             * Handles a transition end event\n             * @param {!Event} evt\n             */\n        }, {\n            key: \"handleTransitionEnd\",\n            value: function handleTransitionEnd(evt) {\n                // Wait for the line ripple to be either transparent or opaque\n                // before emitting the animation end event\n                var isDeactivating = this.adapter_.hasClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);\n                if (evt.propertyName === 'opacity') {\n                    if (isDeactivating) {\n                        this.adapter_.removeClass(cssClasses$3.LINE_RIPPLE_ACTIVE);\n                        this.adapter_.removeClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);\n                    }\n                }\n            }\n        }]);\n    return MDCLineRippleFoundation;\n}(MDCFoundation);\n/**\n * @extends {MDCComponent<!MDCLineRippleFoundation>}\n * @final\n */\nvar MDCLineRipple = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCLineRipple, _MDCComponent);\n    function MDCLineRipple() {\n        _classCallCheck(this, MDCLineRipple);\n        return _possibleConstructorReturn(this, (MDCLineRipple.__proto__ || Object.getPrototypeOf(MDCLineRipple)).apply(this, arguments));\n    }\n    _createClass(MDCLineRipple, [{\n            key: \"activate\",\n            /**\n             * Activates the line ripple\n             */\n            value: function activate() {\n                this.foundation_.activate();\n            }\n            /**\n             * Deactivates the line ripple\n             */\n        }, {\n            key: \"deactivate\",\n            value: function deactivate() {\n                this.foundation_.deactivate();\n            }\n            /**\n             * Sets the transform origin given a user's click location. The `rippleCenter` is the\n             * x-coordinate of the middle of the ripple.\n             * @param {number} xCoordinate\n             */\n        }, {\n            key: \"setRippleCenter\",\n            value: function setRippleCenter(xCoordinate) {\n                this.foundation_.setRippleCenter(xCoordinate);\n            }\n            /**\n             * @return {!MDCLineRippleFoundation}\n             */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this = this;\n                return new MDCLineRippleFoundation(\n                /** @type {!MDCLineRippleAdapter} */\n                Object.assign({\n                    addClass: function addClass(className) {\n                        return _this.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this.root_.classList.remove(className);\n                    },\n                    hasClass: function hasClass(className) {\n                        return _this.root_.classList.contains(className);\n                    },\n                    setStyle: function setStyle(propertyName, value) {\n                        return _this.root_.style[propertyName] = value;\n                    },\n                    registerEventHandler: function registerEventHandler(evtType, handler) {\n                        return _this.root_.addEventListener(evtType, handler);\n                    },\n                    deregisterEventHandler: function deregisterEventHandler(evtType, handler) {\n                        return _this.root_.removeEventListener(evtType, handler);\n                    }\n                }));\n            }\n        }], [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCLineRipple}\n             */\n            value: function attachTo(root) {\n                return new MDCLineRipple(root);\n            }\n        }]);\n    return MDCLineRipple;\n}(MDCComponent);\n/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n/**\n * Adapter for MDC Floating Label.\n *\n * Defines the shape of the adapter expected by the foundation. Implement this\n * adapter to integrate the floating label into your framework. See\n * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md\n * for more information.\n *\n * @record\n */\nvar MDCFloatingLabelAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCFloatingLabelAdapter() {\n        _classCallCheck(this, MDCFloatingLabelAdapter);\n    }\n    _createClass(MDCFloatingLabelAdapter, [{\n            key: \"addClass\",\n            /**\n             * Adds a class to the label element.\n             * @param {string} className\n             */\n            value: function addClass(className) { }\n            /**\n             * Removes a class from the label element.\n             * @param {string} className\n             */\n        }, {\n            key: \"removeClass\",\n            value: function removeClass(className) { }\n            /**\n             * Returns the width of the label element.\n             * @return {number}\n             */\n        }, {\n            key: \"getWidth\",\n            value: function getWidth() { }\n            /**\n             * Registers an event listener on the root element for a given event.\n             * @param {string} evtType\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"registerInteractionHandler\",\n            value: function registerInteractionHandler(evtType, handler) { }\n            /**\n             * Deregisters an event listener on the root element for a given event.\n             * @param {string} evtType\n             * @param {function(!Event): undefined} handler\n             */\n        }, {\n            key: \"deregisterInteractionHandler\",\n            value: function deregisterInteractionHandler(evtType, handler) { }\n        }]);\n    return MDCFloatingLabelAdapter;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @enum {string} */\nvar cssClasses$4 = {\n    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',\n    LABEL_SHAKE: 'mdc-floating-label--shake'\n};\n/**\n * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}\n * @final\n */\nvar MDCFloatingLabelFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCFloatingLabelFoundation, _MDCFoundation);\n    _createClass(MDCFloatingLabelFoundation, null, [{\n            key: \"cssClasses\",\n            /** @return enum {string} */\n            get: function get() {\n                return cssClasses$4;\n            }\n            /**\n             * {@see MDCFloatingLabelAdapter} for typing information on parameters and return\n             * types.\n             * @return {!MDCFloatingLabelAdapter}\n             */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return (\n                /** @type {!MDCFloatingLabelAdapter} */\n                {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    getWidth: function getWidth() { },\n                    registerInteractionHandler: function registerInteractionHandler() { },\n                    deregisterInteractionHandler: function deregisterInteractionHandler() { }\n                });\n            }\n            /**\n             * @param {!MDCFloatingLabelAdapter} adapter\n             */\n        }]);\n    function MDCFloatingLabelFoundation(adapter) {\n        var _this;\n        _classCallCheck(this, MDCFloatingLabelFoundation);\n        _this = _possibleConstructorReturn(this, (MDCFloatingLabelFoundation.__proto__ || Object.getPrototypeOf(MDCFloatingLabelFoundation)).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));\n        /** @private {function(!Event): undefined} */\n        _this.shakeAnimationEndHandler_ = function () {\n            return _this.handleShakeAnimationEnd_();\n        };\n        return _this;\n    }\n    _createClass(MDCFloatingLabelFoundation, [{\n            key: \"init\",\n            value: function init() {\n                this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);\n            }\n            /**\n             * Returns the width of the label element.\n             * @return {number}\n             */\n        }, {\n            key: \"getWidth\",\n            value: function getWidth() {\n                return this.adapter_.getWidth();\n            }\n            /**\n             * Styles the label to produce the label shake for errors.\n             * @param {boolean} shouldShake adds shake class if true,\n             * otherwise removes shake class.\n             */\n        }, {\n            key: \"shake\",\n            value: function shake(shouldShake) {\n                var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;\n                if (shouldShake) {\n                    this.adapter_.addClass(LABEL_SHAKE);\n                }\n                else {\n                    this.adapter_.removeClass(LABEL_SHAKE);\n                }\n            }\n            /**\n             * Styles the label to float or dock.\n             * @param {boolean} shouldFloat adds float class if true, otherwise remove\n             * float and shake class to dock label.\n             */\n        }, {\n            key: \"float\",\n            value: function float(shouldFloat) {\n                var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses, LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;\n                if (shouldFloat) {\n                    this.adapter_.addClass(LABEL_FLOAT_ABOVE);\n                }\n                else {\n                    this.adapter_.removeClass(LABEL_FLOAT_ABOVE);\n                    this.adapter_.removeClass(LABEL_SHAKE);\n                }\n            }\n            /**\n             * Handles an interaction event on the root element.\n             */\n        }, {\n            key: \"handleShakeAnimationEnd_\",\n            value: function handleShakeAnimationEnd_() {\n                var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;\n                this.adapter_.removeClass(LABEL_SHAKE);\n            }\n        }]);\n    return MDCFloatingLabelFoundation;\n}(MDCFoundation);\n/**\n * @extends {MDCComponent<!MDCFloatingLabelFoundation>}\n * @final\n */\nvar MDCFloatingLabel = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCFloatingLabel, _MDCComponent);\n    function MDCFloatingLabel() {\n        _classCallCheck(this, MDCFloatingLabel);\n        return _possibleConstructorReturn(this, (MDCFloatingLabel.__proto__ || Object.getPrototypeOf(MDCFloatingLabel)).apply(this, arguments));\n    }\n    _createClass(MDCFloatingLabel, [{\n            key: \"shake\",\n            /**\n             * Styles the label to produce the label shake for errors.\n             * @param {boolean} shouldShake styles the label to shake by adding shake class\n             * if true, otherwise will stop shaking by removing shake class.\n             */\n            value: function shake(shouldShake) {\n                this.foundation_.shake(shouldShake);\n            }\n            /**\n             * Styles label to float/dock.\n             * @param {boolean} shouldFloat styles the label to float by adding float class\n             * if true, otherwise docks the label by removing the float class.\n             */\n        }, {\n            key: \"float\",\n            value: function float(shouldFloat) {\n                this.foundation_.float(shouldFloat);\n            }\n            /**\n             * @return {number}\n             */\n        }, {\n            key: \"getWidth\",\n            value: function getWidth() {\n                return this.foundation_.getWidth();\n            }\n            /**\n             * @return {!MDCFloatingLabelFoundation}\n             */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this = this;\n                return new MDCFloatingLabelFoundation({\n                    addClass: function addClass(className) {\n                        return _this.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this.root_.classList.remove(className);\n                    },\n                    getWidth: function getWidth() {\n                        return _this.root_.offsetWidth;\n                    },\n                    registerInteractionHandler: function registerInteractionHandler(evtType, handler) {\n                        return _this.root_.addEventListener(evtType, handler);\n                    },\n                    deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {\n                        return _this.root_.removeEventListener(evtType, handler);\n                    }\n                });\n            }\n        }], [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCFloatingLabel}\n             */\n            value: function attachTo(root) {\n                return new MDCFloatingLabel(root);\n            }\n        }]);\n    return MDCFloatingLabel;\n}(MDCComponent);\n/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n/**\n * Adapter for MDC Notched Outline.\n *\n * Defines the shape of the adapter expected by the foundation. Implement this\n * adapter to integrate the Notched Outline into your framework. See\n * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md\n * for more information.\n *\n * @record\n */\nvar MDCNotchedOutlineAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCNotchedOutlineAdapter() {\n        _classCallCheck(this, MDCNotchedOutlineAdapter);\n    }\n    _createClass(MDCNotchedOutlineAdapter, [{\n            key: \"getWidth\",\n            /**\n             * Returns the width of the root element.\n             * @return {number}\n             */\n            value: function getWidth() { }\n            /**\n             * Returns the height of the root element.\n             * @return {number}\n             */\n        }, {\n            key: \"getHeight\",\n            value: function getHeight() { }\n            /**\n             * Adds a class to the root element.\n             * @param {string} className\n             */\n        }, {\n            key: \"addClass\",\n            value: function addClass(className) { }\n            /**\n             * Removes a class from the root element.\n             * @param {string} className\n             */\n        }, {\n            key: \"removeClass\",\n            value: function removeClass(className) { }\n            /**\n             * Sets the \"d\" attribute of the outline element's SVG path.\n             * @param {string} value\n             */\n        }, {\n            key: \"setOutlinePathAttr\",\n            value: function setOutlinePathAttr(value) { }\n            /**\n             * Returns the idle outline element's computed style value of the given css property `propertyName`.\n             * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.\n             * @param {string} propertyName\n             * @return {string}\n             */\n        }, {\n            key: \"getIdleOutlineStyleValue\",\n            value: function getIdleOutlineStyleValue(propertyName) { }\n        }]);\n    return MDCNotchedOutlineAdapter;\n}();\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @enum {string} */\nvar strings$4 = {\n    PATH_SELECTOR: '.mdc-notched-outline__path',\n    IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'\n};\n/** @enum {string} */\nvar cssClasses$5 = {\n    OUTLINE_NOTCHED: 'mdc-notched-outline--notched'\n};\n/**\n * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}\n * @final\n */\nvar MDCNotchedOutlineFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCNotchedOutlineFoundation, _MDCFoundation);\n    _createClass(MDCNotchedOutlineFoundation, null, [{\n            key: \"strings\",\n            /** @return enum {string} */\n            get: function get() {\n                return strings$4;\n            }\n            /** @return enum {string} */\n        }, {\n            key: \"cssClasses\",\n            get: function get() {\n                return cssClasses$5;\n            }\n            /**\n             * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return\n             * types.\n             * @return {!MDCNotchedOutlineAdapter}\n             */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return (\n                /** @type {!MDCNotchedOutlineAdapter} */\n                {\n                    getWidth: function getWidth() { },\n                    getHeight: function getHeight() { },\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    setOutlinePathAttr: function setOutlinePathAttr() { },\n                    getIdleOutlineStyleValue: function getIdleOutlineStyleValue() { }\n                });\n            }\n            /**\n             * @param {!MDCNotchedOutlineAdapter} adapter\n             */\n        }]);\n    function MDCNotchedOutlineFoundation(adapter) {\n        _classCallCheck(this, MDCNotchedOutlineFoundation);\n        return _possibleConstructorReturn(this, (MDCNotchedOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCNotchedOutlineFoundation)).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));\n    }\n    /**\n     * Adds the outline notched selector and updates the notch width\n     * calculated based off of notchWidth and isRtl.\n     * @param {number} notchWidth\n     * @param {boolean=} isRtl\n     */\n    _createClass(MDCNotchedOutlineFoundation, [{\n            key: \"notch\",\n            value: function notch(notchWidth) {\n                var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;\n                this.adapter_.addClass(OUTLINE_NOTCHED);\n                this.updateSvgPath_(notchWidth, isRtl);\n            }\n            /**\n             * Removes notched outline selector to close the notch in the outline.\n             */\n        }, {\n            key: \"closeNotch\",\n            value: function closeNotch() {\n                var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;\n                this.adapter_.removeClass(OUTLINE_NOTCHED);\n            }\n            /**\n             * Updates the SVG path of the focus outline element based on the notchWidth\n             * and the RTL context.\n             * @param {number} notchWidth\n             * @param {boolean=} isRtl\n             * @private\n             */\n        }, {\n            key: \"updateSvgPath_\",\n            value: function updateSvgPath_(notchWidth, isRtl) {\n                // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.\n                var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');\n                var radius = parseFloat(radiusStyleValue);\n                var width = this.adapter_.getWidth();\n                var height = this.adapter_.getHeight();\n                var cornerWidth = radius + 1.2;\n                var leadingStrokeLength = Math.abs(11 - cornerWidth);\n                var paddedNotchWidth = notchWidth + 8; // The right, bottom, and left sides of the outline follow the same SVG path.\n                var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;\n                var path;\n                if (!isRtl) {\n                    path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;\n                }\n                else {\n                    path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);\n                }\n                this.adapter_.setOutlinePathAttr(path);\n            }\n        }]);\n    return MDCNotchedOutlineFoundation;\n}(MDCFoundation);\n/**\n * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}\n * @final\n */\nvar MDCNotchedOutline = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCNotchedOutline, _MDCComponent);\n    function MDCNotchedOutline() {\n        _classCallCheck(this, MDCNotchedOutline);\n        return _possibleConstructorReturn(this, (MDCNotchedOutline.__proto__ || Object.getPrototypeOf(MDCNotchedOutline)).apply(this, arguments));\n    }\n    _createClass(MDCNotchedOutline, [{\n            key: \"notch\",\n            /**\n              * Updates outline selectors and SVG path to open notch.\n              * @param {number} notchWidth The notch width in the outline.\n              * @param {boolean=} isRtl Determines if outline is rtl. If rtl is true, notch\n              * will be right justified in outline path, otherwise left justified.\n              */\n            value: function notch(notchWidth, isRtl) {\n                this.foundation_.notch(notchWidth, isRtl);\n            }\n            /**\n             * Updates the outline selectors to close notch and return it to idle state.\n             */\n        }, {\n            key: \"closeNotch\",\n            value: function closeNotch() {\n                this.foundation_.closeNotch();\n            }\n            /**\n             * @return {!MDCNotchedOutlineFoundation}\n             */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this = this;\n                return new MDCNotchedOutlineFoundation({\n                    getWidth: function getWidth() {\n                        return _this.root_.offsetWidth;\n                    },\n                    getHeight: function getHeight() {\n                        return _this.root_.offsetHeight;\n                    },\n                    addClass: function addClass(className) {\n                        return _this.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this.root_.classList.remove(className);\n                    },\n                    setOutlinePathAttr: function setOutlinePathAttr(value) {\n                        var path = _this.root_.querySelector(strings$4.PATH_SELECTOR);\n                        path.setAttribute('d', value);\n                    },\n                    getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {\n                        var idleOutlineElement = _this.root_.parentNode.querySelector(strings$4.IDLE_OUTLINE_SELECTOR);\n                        return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);\n                    }\n                });\n            }\n        }], [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCNotchedOutline}\n             */\n            value: function attachTo(root) {\n                return new MDCNotchedOutline(root);\n            }\n        }]);\n    return MDCNotchedOutline;\n}(MDCComponent);\n/* eslint-enable no-unused-vars */\n/**\n * @extends {MDCComponent<!MDCTextFieldFoundation>}\n * @final\n */\nvar MDCTextField = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCTextField, _MDCComponent);\n    /**\n     * @param {...?} args\n     */\n    function MDCTextField() {\n        var _ref;\n        var _this;\n        _classCallCheck(this, MDCTextField);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _possibleConstructorReturn(this, (_ref = MDCTextField.__proto__ || Object.getPrototypeOf(MDCTextField)).call.apply(_ref, [this].concat(args)));\n        /** @private {?Element} */\n        _this.input_;\n        /** @type {?MDCRipple} */\n        _this.ripple;\n        /** @private {?MDCLineRipple} */\n        _this.lineRipple_;\n        /** @private {?MDCTextFieldHelperText} */\n        _this.helperText_;\n        /** @private {?MDCTextFieldIcon} */\n        _this.icon_;\n        /** @private {?MDCFloatingLabel} */\n        _this.label_;\n        /** @private {?MDCNotchedOutline} */\n        _this.outline_;\n        return _this;\n    }\n    /**\n     * @param {!Element} root\n     * @return {!MDCTextField}\n     */\n    _createClass(MDCTextField, [{\n            key: \"initialize\",\n            /**\n             * @param {(function(!Element): !MDCRipple)=} rippleFactory A function which\n             * creates a new MDCRipple.\n             * @param {(function(!Element): !MDCLineRipple)=} lineRippleFactory A function which\n             * creates a new MDCLineRipple.\n             * @param {(function(!Element): !MDCTextFieldHelperText)=} helperTextFactory A function which\n             * creates a new MDCTextFieldHelperText.\n             * @param {(function(!Element): !MDCTextFieldIcon)=} iconFactory A function which\n             * creates a new MDCTextFieldIcon.\n             * @param {(function(!Element): !MDCFloatingLabel)=} labelFactory A function which\n             * creates a new MDCFloatingLabel.\n             * @param {(function(!Element): !MDCNotchedOutline)=} outlineFactory A function which\n             * creates a new MDCNotchedOutline.\n             */\n            value: function initialize() {\n                var _this2 = this;\n                var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el, foundation) {\n                    return new MDCRipple(el, foundation);\n                };\n                var lineRippleFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {\n                    return new MDCLineRipple(el);\n                };\n                var helperTextFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el) {\n                    return new MDCTextFieldHelperText(el);\n                };\n                var iconFactory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (el) {\n                    return new MDCTextFieldIcon(el);\n                };\n                var labelFactory = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (el) {\n                    return new MDCFloatingLabel(el);\n                };\n                var outlineFactory = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (el) {\n                    return new MDCNotchedOutline(el);\n                };\n                this.input_ = this.root_.querySelector(strings$3.INPUT_SELECTOR);\n                var labelElement = this.root_.querySelector(strings$3.LABEL_SELECTOR);\n                if (labelElement) {\n                    this.label_ = labelFactory(labelElement);\n                }\n                var lineRippleElement = this.root_.querySelector(strings$3.LINE_RIPPLE_SELECTOR);\n                if (lineRippleElement) {\n                    this.lineRipple_ = lineRippleFactory(lineRippleElement);\n                }\n                var outlineElement = this.root_.querySelector(strings$3.OUTLINE_SELECTOR);\n                if (outlineElement) {\n                    this.outline_ = outlineFactory(outlineElement);\n                }\n                if (this.input_.hasAttribute(strings$3.ARIA_CONTROLS)) {\n                    var helperTextElement = document.getElementById(this.input_.getAttribute(strings$3.ARIA_CONTROLS));\n                    if (helperTextElement) {\n                        this.helperText_ = helperTextFactory(helperTextElement);\n                    }\n                }\n                var iconElement = this.root_.querySelector(strings$3.ICON_SELECTOR);\n                if (iconElement) {\n                    this.icon_ = iconFactory(iconElement);\n                }\n                this.ripple = null;\n                if (this.root_.classList.contains(cssClasses$2.BOX)) {\n                    var MATCHES = getMatchesProperty(HTMLElement.prototype);\n                    var adapter = Object.assign(MDCRipple.createAdapter(\n                    /** @type {!RippleCapableSurface} */\n                    this), {\n                        isSurfaceActive: function isSurfaceActive() {\n                            return _this2.input_[MATCHES](':active');\n                        },\n                        registerInteractionHandler: function registerInteractionHandler(type, handler) {\n                            return _this2.input_.addEventListener(type, handler);\n                        },\n                        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {\n                            return _this2.input_.removeEventListener(type, handler);\n                        }\n                    });\n                    var foundation = new MDCRippleFoundation(adapter);\n                    this.ripple = rippleFactory(this.root_, foundation);\n                }\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                if (this.ripple) {\n                    this.ripple.destroy();\n                }\n                if (this.lineRipple_) {\n                    this.lineRipple_.destroy();\n                }\n                if (this.helperText_) {\n                    this.helperText_.destroy();\n                }\n                if (this.icon_) {\n                    this.icon_.destroy();\n                }\n                if (this.label_) {\n                    this.label_.destroy();\n                }\n                if (this.outline_) {\n                    this.outline_.destroy();\n                }\n                _get(MDCTextField.prototype.__proto__ || Object.getPrototypeOf(MDCTextField.prototype), \"destroy\", this).call(this);\n            }\n            /**\n             * Initiliazes the Text Field's internal state based on the environment's\n             * state.\n             */\n        }, {\n            key: \"initialSyncWithDom\",\n            value: function initialSyncWithDom() {\n                this.disabled = this.input_.disabled;\n            }\n            /**\n             * @return {string} The value of the input.\n             */\n        }, {\n            key: \"layout\",\n            /**\n             * Recomputes the outline SVG path for the outline element.\n             */\n            value: function layout() {\n                var openNotch = this.foundation_.shouldFloat;\n                this.foundation_.notchOutline(openNotch);\n            }\n            /**\n             * @return {!MDCTextFieldFoundation}\n             */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                var _this3 = this;\n                return new MDCTextFieldFoundation(\n                /** @type {!MDCTextFieldAdapter} */\n                Object.assign({\n                    addClass: function addClass(className) {\n                        return _this3.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this3.root_.classList.remove(className);\n                    },\n                    hasClass: function hasClass(className) {\n                        return _this3.root_.classList.contains(className);\n                    },\n                    registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {\n                        return _this3.root_.addEventListener(evtType, handler);\n                    },\n                    deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {\n                        return _this3.root_.removeEventListener(evtType, handler);\n                    },\n                    registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {\n                        var getAttributesList = function getAttributesList(mutationsList) {\n                            return mutationsList.map(function (mutation) {\n                                return mutation.attributeName;\n                            });\n                        };\n                        var observer = new MutationObserver(function (mutationsList) {\n                            return handler(getAttributesList(mutationsList));\n                        });\n                        var targetNode = _this3.root_.querySelector(strings$3.INPUT_SELECTOR);\n                        var config = {\n                            attributes: true\n                        };\n                        observer.observe(targetNode, config);\n                        return observer;\n                    },\n                    deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {\n                        return observer.disconnect();\n                    },\n                    isFocused: function isFocused() {\n                        return document.activeElement === _this3.root_.querySelector(strings$3.INPUT_SELECTOR);\n                    },\n                    isRtl: function isRtl() {\n                        return window.getComputedStyle(_this3.root_).getPropertyValue('direction') === 'rtl';\n                    }\n                }, this.getInputAdapterMethods_(), this.getLabelAdapterMethods_(), this.getLineRippleAdapterMethods_(), this.getOutlineAdapterMethods_()), this.getFoundationMap_());\n            }\n            /**\n             * @return {!{\n             *   shakeLabel: function(boolean): undefined,\n             *   floatLabel: function(boolean): undefined,\n             *   hasLabel: function(): boolean,\n             *   getLabelWidth: function(): number,\n             * }}\n             */\n        }, {\n            key: \"getLabelAdapterMethods_\",\n            value: function getLabelAdapterMethods_() {\n                var _this4 = this;\n                return {\n                    shakeLabel: function shakeLabel(shouldShake) {\n                        return _this4.label_.shake(shouldShake);\n                    },\n                    floatLabel: function floatLabel(shouldFloat) {\n                        return _this4.label_.float(shouldFloat);\n                    },\n                    hasLabel: function hasLabel() {\n                        return !!_this4.label_;\n                    },\n                    getLabelWidth: function getLabelWidth() {\n                        return _this4.label_.getWidth();\n                    }\n                };\n            }\n            /**\n             * @return {!{\n             *   activateLineRipple: function(): undefined,\n             *   deactivateLineRipple: function(): undefined,\n             *   setLineRippleTransformOrigin: function(number): undefined,\n             * }}\n             */\n        }, {\n            key: \"getLineRippleAdapterMethods_\",\n            value: function getLineRippleAdapterMethods_() {\n                var _this5 = this;\n                return {\n                    activateLineRipple: function activateLineRipple() {\n                        if (_this5.lineRipple_) {\n                            _this5.lineRipple_.activate();\n                        }\n                    },\n                    deactivateLineRipple: function deactivateLineRipple() {\n                        if (_this5.lineRipple_) {\n                            _this5.lineRipple_.deactivate();\n                        }\n                    },\n                    setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {\n                        if (_this5.lineRipple_) {\n                            _this5.lineRipple_.setRippleCenter(normalizedX);\n                        }\n                    }\n                };\n            }\n            /**\n             * @return {!{\n             *   notchOutline: function(number, boolean): undefined,\n             *   hasOutline: function(): boolean,\n             * }}\n             */\n        }, {\n            key: \"getOutlineAdapterMethods_\",\n            value: function getOutlineAdapterMethods_() {\n                var _this6 = this;\n                return {\n                    notchOutline: function notchOutline(labelWidth, isRtl) {\n                        return _this6.outline_.notch(labelWidth, isRtl);\n                    },\n                    closeOutline: function closeOutline() {\n                        return _this6.outline_.closeNotch();\n                    },\n                    hasOutline: function hasOutline() {\n                        return !!_this6.outline_;\n                    }\n                };\n            }\n            /**\n             * @return {!{\n             *   registerInputInteractionHandler: function(string, function()): undefined,\n             *   deregisterInputInteractionHandler: function(string, function()): undefined,\n             *   getNativeInput: function(): ?Element,\n             * }}\n             */\n        }, {\n            key: \"getInputAdapterMethods_\",\n            value: function getInputAdapterMethods_() {\n                var _this7 = this;\n                return {\n                    registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {\n                        return _this7.input_.addEventListener(evtType, handler);\n                    },\n                    deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {\n                        return _this7.input_.removeEventListener(evtType, handler);\n                    },\n                    getNativeInput: function getNativeInput() {\n                        return _this7.input_;\n                    }\n                };\n            }\n            /**\n             * Returns a map of all subcomponents to subfoundations.\n             * @return {!FoundationMapType}\n             */\n        }, {\n            key: \"getFoundationMap_\",\n            value: function getFoundationMap_() {\n                return {\n                    helperText: this.helperText_ ? this.helperText_.foundation : undefined,\n                    icon: this.icon_ ? this.icon_.foundation : undefined\n                };\n            }\n        }, {\n            key: \"value\",\n            get: function get$$1() {\n                return this.foundation_.getValue();\n            }\n            /**\n             * @param {string} value The value to set on the input.\n             */\n            ,\n            set: function set(value) {\n                this.foundation_.setValue(value);\n            }\n            /**\n             * @return {boolean} True if the Text Field is disabled.\n             */\n        }, {\n            key: \"disabled\",\n            get: function get$$1() {\n                return this.foundation_.isDisabled();\n            }\n            /**\n             * @param {boolean} disabled Sets the Text Field disabled or enabled.\n             */\n            ,\n            set: function set(disabled) {\n                this.foundation_.setDisabled(disabled);\n            }\n            /**\n             * @return {boolean} valid True if the Text Field is valid.\n             */\n        }, {\n            key: \"valid\",\n            get: function get$$1() {\n                return this.foundation_.isValid();\n            }\n            /**\n             * @param {boolean} valid Sets the Text Field valid or invalid.\n             */\n            ,\n            set: function set(valid) {\n                this.foundation_.setValid(valid);\n            }\n            /**\n             * @return {boolean} True if the Text Field is required.\n             */\n        }, {\n            key: \"required\",\n            get: function get$$1() {\n                return this.input_.required;\n            }\n            /**\n             * @param {boolean} required Sets the Text Field to required.\n             */\n            ,\n            set: function set(required) {\n                this.input_.required = required;\n            }\n            /**\n             * @return {string} The input element's validation pattern.\n             */\n        }, {\n            key: \"pattern\",\n            get: function get$$1() {\n                return this.input_.pattern;\n            }\n            /**\n             * @param {string} pattern Sets the input element's validation pattern.\n             */\n            ,\n            set: function set(pattern) {\n                this.input_.pattern = pattern;\n            }\n            /**\n             * @return {number} The input element's minLength.\n             */\n        }, {\n            key: \"minLength\",\n            get: function get$$1() {\n                return this.input_.minLength;\n            }\n            /**\n             * @param {number} minLength Sets the input element's minLength.\n             */\n            ,\n            set: function set(minLength) {\n                this.input_.minLength = minLength;\n            }\n            /**\n             * @return {number} The input element's maxLength.\n             */\n        }, {\n            key: \"maxLength\",\n            get: function get$$1() {\n                return this.input_.maxLength;\n            }\n            /**\n             * @param {number} maxLength Sets the input element's maxLength.\n             */\n            ,\n            set: function set(maxLength) {\n                // Chrome throws exception if maxLength is set < 0\n                if (maxLength < 0) {\n                    this.input_.removeAttribute('maxLength');\n                }\n                else {\n                    this.input_.maxLength = maxLength;\n                }\n            }\n            /**\n             * @return {string} The input element's min.\n             */\n        }, {\n            key: \"min\",\n            get: function get$$1() {\n                return this.input_.min;\n            }\n            /**\n             * @param {string} min Sets the input element's min.\n             */\n            ,\n            set: function set(min) {\n                this.input_.min = min;\n            }\n            /**\n             * @return {string} The input element's max.\n             */\n        }, {\n            key: \"max\",\n            get: function get$$1() {\n                return this.input_.max;\n            }\n            /**\n             * @param {string} max Sets the input element's max.\n             */\n            ,\n            set: function set(max) {\n                this.input_.max = max;\n            }\n            /**\n             * @return {string} The input element's step.\n             */\n        }, {\n            key: \"step\",\n            get: function get$$1() {\n                return this.input_.step;\n            }\n            /**\n             * @param {string} step Sets the input element's step.\n             */\n            ,\n            set: function set(step) {\n                this.input_.step = step;\n            }\n            /**\n             * Sets the helper text element content.\n             * @param {string} content\n             */\n        }, {\n            key: \"helperTextContent\",\n            set: function set(content) {\n                this.foundation_.setHelperTextContent(content);\n            }\n            /**\n             * Sets the aria label of the icon.\n             * @param {string} label\n             */\n        }, {\n            key: \"iconAriaLabel\",\n            set: function set(label) {\n                this.foundation_.setIconAriaLabel(label);\n            }\n            /**\n             * Sets the text content of the icon.\n             * @param {string} content\n             */\n        }, {\n            key: \"iconContent\",\n            set: function set(content) {\n                this.foundation_.setIconContent(content);\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                return new MDCTextField(root);\n            }\n        }]);\n    return MDCTextField;\n}(MDCComponent);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: /*@__PURE__*/ forwardRef(function () { return MdcTextField; }),\n    multi: true\n};\n// Invalid input type. Using one of these will throw an error.\nvar /** @type {?} */ MDC_INPUT_INVALID_TYPES = [\n    'button',\n    'checkbox',\n    'color',\n    'file',\n    'hidden',\n    'image',\n    'radio',\n    'range',\n    'reset',\n    'submit'\n];\nvar /** @type {?} */ nextUniqueId = 0;\nvar MdcTextField = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTextField(_changeDetectorRef, _renderer, elementRef, _ripple, _registry) {\n        var _this = this;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this._ripple = _ripple;\n        this._registry = _registry;\n        /**\n         * Emits whenever the component is destroyed.\n         */\n        this._destroy = new Subject();\n        this._uid = \"mdc-input-\" + nextUniqueId++;\n        this.placeholder = '';\n        this.tabIndex = 0;\n        this.direction = 'ltr';\n        this.iconAction = new EventEmitter();\n        this.change = new EventEmitter();\n        this.blur = new EventEmitter();\n        this.isHostClass = true;\n        this._type = 'text';\n        this._box = false;\n        this._outline = false;\n        this._required = false;\n        this._focused = false;\n        this._mdcAdapter = {\n            addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },\n            removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },\n            hasClass: function (className) { return _this._getHostElement().classList.contains(className); },\n            registerTextFieldInteractionHandler: function (evtType, handler) {\n                return _this._registry.listen(evtType, handler, _this._getHostElement());\n            },\n            deregisterTextFieldInteractionHandler: function (evtType, handler) {\n                return _this._registry.unlisten(evtType, handler);\n            },\n            registerInputInteractionHandler: function (evtType, handler) {\n                return _this._registry.listen(evtType, handler, _this.inputText.nativeElement);\n            },\n            deregisterInputInteractionHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },\n            isFocused: function () { return _this._focused; },\n            isRtl: function () { return _this.direction === 'rtl'; },\n            activateLineRipple: function () {\n                if (_this.lineRipple) {\n                    _this.lineRipple.activate();\n                }\n            },\n            deactivateLineRipple: function () {\n                if (_this.lineRipple) {\n                    _this.lineRipple.deactivate();\n                }\n            },\n            setLineRippleTransformOrigin: function (normalizedX) {\n                if (_this.lineRipple) {\n                    _this.lineRipple.setRippleCenter(normalizedX);\n                }\n            },\n            shakeLabel: function (shouldShake) { return _this.floatingLabel.shake(shouldShake); },\n            floatLabel: function (shouldFloat) { return _this.floatingLabel.float(shouldFloat); },\n            hasLabel: function () { return !!_this.floatingLabel; },\n            getLabelWidth: function () { return _this.floatingLabel.getWidth(); },\n            hasOutline: function () { return _this.outline; },\n            notchOutline: function (notchWidth, isRtl) { return _this.outlined.notch(notchWidth, isRtl); },\n            closeOutline: function () { return _this.outlined.closeNotch(); },\n            registerValidationAttributeChangeHandler: function (handler) {\n                var /** @type {?} */ getAttributesList = function (mutationsList) { return mutationsList.map(function (mutation) { return mutation.attributeName; }); };\n                var /** @type {?} */ observer = new MutationObserver(function (mutationsList) { return handler(getAttributesList(mutationsList)); });\n                return observer.observe(_this.inputText.nativeElement, { attributes: true });\n            },\n            deregisterValidationAttributeChangeHandler: function (observer) {\n                if (observer) {\n                    observer.disconnect();\n                }\n            },\n            getNativeInput: function () { return _this.inputText.nativeElement; }\n        };\n        this._mdcIconAdapter = {\n            getAttr: function (attr) { return _this.icons.first.elementRef.nativeElement.getAttribute(attr); },\n            setAttr: function (attr, value) { return _this.icons.first.elementRef.nativeElement.setAttribute(attr, value); },\n            removeAttr: function (attr) { return _this.icons.first.elementRef.nativeElement.removeAttribute(attr); },\n            setContent: function (content) { return _this.icons.first.elementRef.nativeElement.textContent = content; },\n            registerInteractionHandler: function (evtType, handler) {\n                return _this._registry.listen(evtType, handler, _this.icons.first.elementRef.nativeElement);\n            },\n            deregisterInteractionHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },\n            notifyIconAction: function () { return _this.iconAction.emit(true); }\n        };\n        this._foundation = new MDCTextFieldFoundation(this._mdcAdapter);\n        /**\n         * View -> model callback called when value changes\n         */\n        this._onChange = function () { };\n        /**\n         * View -> model callback called when text field has been touched\n         */\n        this._onTouched = function () { };\n        // Force setter to be called in case id was not specified.\n        this.id = this.id;\n    }\n    Object.defineProperty(MdcTextField.prototype, \"id\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._id; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._id = value || this._uid; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"type\", {\n        /** Input type of the element. */\n        get: /**\n         * Input type of the element.\n         * @return {?}\n         */ function () { return this._type; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._type = value || 'text';\n            this._validateType();\n            // When using Angular inputs, developers are no longer able to set the properties on the native\n            // input element. To ensure that bindings for `type` work, we need to sync the setter\n            // with the native property. Textarea elements don't support the type property or attribute.\n            if (!this.isTextarea() && getSupportedInputTypes().has(this._type)) {\n                this.inputText.nativeElement.type = this._type;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"box\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._box; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setBox(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"outline\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._outline; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setOutline(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"disabled\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setDisabled(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"required\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._required; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setRequired(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"focused\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._focused; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._focused = toBoolean(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"fullwidth\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._fullwidth; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setFullwidth(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"dense\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._dense; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setDense(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"helperText\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._helperText; },\n        set: /**\n         * @param {?} helperText\n         * @return {?}\n         */ function (helperText) {\n            this.setHelperText(helperText);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"value\", {\n        /** The input element's value. */\n        get: /**\n         * The input element's value.\n         * @return {?}\n         */ function () { return this._value; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setValue(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"valid\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._useCustomValidity ? this._foundation.isValid() : this.inputText.nativeElement.validity.valid;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"empty\", {\n        /** Whether the control is empty. */\n        get: /**\n         * Whether the control is empty.\n         * @return {?}\n         */ function () {\n            return !this.inputText.nativeElement.value && !this.isBadInput();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"classBox\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.box ? 'mdc-text-field--box' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"classDense\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.dense ? 'mdc-text-field--dense' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"classFullwidth\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.fullwidth ? 'mdc-text-field--fullwidth' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"classFocused\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._focused ? 'mdc-text-field--focused' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcTextField.prototype, \"classOutlined\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.outline ? 'mdc-text-field--outlined' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns a map of all subcomponents to subfoundations.\n     * @return {?}\n     */\n    MdcTextField.prototype._getFoundationMap = /**\n     * Returns a map of all subcomponents to subfoundations.\n     * @return {?}\n     */\n        function () {\n            return {\n                helperText: this._helperText ? this.helperText.foundation : undefined,\n                icon: this._hasIcons() ? this.icons.first.foundation : undefined\n            };\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.outline && this.outlined) {\n                this.outlined.outlineIdle = this.outlineIdle;\n                this._foundation.notchOutline(this.shouldFloat());\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._foundation = new MDCTextFieldFoundation(this._mdcAdapter, this._getFoundationMap());\n            this._foundation.init();\n            this.icons.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(function () {\n                Promise.resolve().then(function () {\n                    _this.icons.forEach(function (icon) {\n                        _this._renderer.addClass(icon.elementRef.nativeElement, 'mdc-text-field__icon');\n                        if (icon.isLeading() || icon.isTrailing()) {\n                            _this._iconFoundation = new MDCTextFieldIconFoundation(_this._mdcIconAdapter);\n                            icon.foundation = _this._iconFoundation;\n                        }\n                    });\n                    _this.updateIconState();\n                    _this.writeValue(_this._value);\n                    _this._changeDetectorRef.detectChanges();\n                });\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._hasIcons()) {\n                this.icons.forEach(function (icon) {\n                    icon.foundation.destroy();\n                });\n            }\n            this._ripple.destroy();\n            this._foundation.destroy();\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdcTextField.prototype.writeValue = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.setValue(value == null ? '' : value, false);\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.shouldFloat = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation.shouldFloat;\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MdcTextField.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._onChange = fn;\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MdcTextField.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._onTouched = fn;\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdcTextField.prototype.onInput = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.setValue(value);\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.onFocus = /**\n     * @return {?}\n     */\n        function () {\n            this._focused = true;\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.onBlur = /**\n     * @return {?}\n     */\n        function () {\n            this._focused = false;\n            this._onTouched();\n            this.blur.emit(this.value);\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.isDisabled = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation.isDisabled();\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.isBadInput = /**\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ validity = this.inputText.nativeElement.validity;\n            return validity && validity.badInput;\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.focus = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.disabled) {\n                this._focused = true;\n                this.inputText.nativeElement.focus();\n            }\n        };\n    /**\n     * @param {?} isValid\n     * @return {?}\n     */\n    MdcTextField.prototype.setValid = /**\n     * @param {?} isValid\n     * @return {?}\n     */\n        function (isValid) {\n            this._useCustomValidity = true;\n            this._foundation.setValid(isValid);\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.isTextarea = /**\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ nativeElement = this._getHostElement();\n            var /** @type {?} */ nodeName = isBrowser ? nativeElement.nodeName : nativeElement.name;\n            return nodeName ? nodeName.toLowerCase() === 'textarea' : false;\n        };\n    /** Sets the text-field required or not. */\n    /**\n     * Sets the text-field required or not.\n     * @param {?} required\n     * @return {?}\n     */\n    MdcTextField.prototype.setRequired = /**\n     * Sets the text-field required or not.\n     * @param {?} required\n     * @return {?}\n     */\n        function (required) {\n            this._required = required;\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    MdcTextField.prototype.setValue = /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n        function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) {\n                isUserInput = true;\n            }\n            this._value = (this.type === 'number') ?\n                (value === '' ? null : toNumber(value)) : value;\n            this._foundation.setValue(this.value);\n            if (isUserInput) {\n                this._onChange(this.value);\n            }\n            if (this.required && !this.value) {\n                this.setRequired(false);\n                setTimeout(function () { return _this.setRequired(true); });\n            }\n            this._changeDetectorRef.markForCheck();\n        };\n    /** Styles the text field as a box text field. */\n    /**\n     * Styles the text field as a box text field.\n     * @param {?} box\n     * @return {?}\n     */\n    MdcTextField.prototype.setBox = /**\n     * Styles the text field as a box text field.\n     * @param {?} box\n     * @return {?}\n     */\n        function (box) {\n            this._box = toBoolean(box);\n            if (this._outline && this._box) {\n                this._outline = false;\n            }\n            this._box ? this._ripple.attachTo(this._getHostElement(), false, this.inputText.nativeElement) : this._ripple.destroy();\n            this._changeDetectorRef.markForCheck();\n        };\n    /** Styles the text field as an outlined text field. */\n    /**\n     * Styles the text field as an outlined text field.\n     * @param {?} outline\n     * @return {?}\n     */\n    MdcTextField.prototype.setOutline = /**\n     * Styles the text field as an outlined text field.\n     * @param {?} outline\n     * @return {?}\n     */\n        function (outline) {\n            this._outline = toBoolean(outline);\n            if (this._outline && this._box) {\n                this._box = false;\n            }\n            this._changeDetectorRef.markForCheck();\n        };\n    /** Styles the text field as a fullwidth text field. */\n    /**\n     * Styles the text field as a fullwidth text field.\n     * @param {?} fullwidth\n     * @return {?}\n     */\n    MdcTextField.prototype.setFullwidth = /**\n     * Styles the text field as a fullwidth text field.\n     * @param {?} fullwidth\n     * @return {?}\n     */\n        function (fullwidth) {\n            this._fullwidth = toBoolean(fullwidth);\n            this.placeholder = this.fullwidth ? this.label : '';\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} dense\n     * @return {?}\n     */\n    MdcTextField.prototype.setDense = /**\n     * @param {?} dense\n     * @return {?}\n     */\n        function (dense) {\n            this._dense = toBoolean(dense);\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n    MdcTextField.prototype.setDisabled = /**\n     * @param {?} disabled\n     * @return {?}\n     */\n        function (disabled) {\n            this.setDisabledState(disabled);\n        };\n    /**\n     * @param {?} helperText\n     * @return {?}\n     */\n    MdcTextField.prototype.setHelperText = /**\n     * @param {?} helperText\n     * @return {?}\n     */\n        function (helperText) {\n            this._helperText = helperText;\n            this._changeDetectorRef.markForCheck();\n        };\n    /** True if the Text Field is required. */\n    /**\n     * True if the Text Field is required.\n     * @return {?}\n     */\n    MdcTextField.prototype.isRequired = /**\n     * True if the Text Field is required.\n     * @return {?}\n     */\n        function () {\n            return this.required;\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.selectAll = /**\n     * @return {?}\n     */\n        function () {\n            this.inputText.nativeElement.select();\n        };\n    /** The value of the input Element. */\n    /**\n     * The value of the input Element.\n     * @return {?}\n     */\n    MdcTextField.prototype.getValue = /**\n     * The value of the input Element.\n     * @return {?}\n     */\n        function () {\n            return this._foundation.getValue();\n        };\n    /** Deactives the Text Field's focus state. */\n    /**\n     * Deactives the Text Field's focus state.\n     * @return {?}\n     */\n    MdcTextField.prototype.deactivateFocus = /**\n     * Deactives the Text Field's focus state.\n     * @return {?}\n     */\n        function () {\n            this._foundation.deactivateFocus();\n        };\n    /** Activates the text field focus state. */\n    /**\n     * Activates the text field focus state.\n     * @return {?}\n     */\n    MdcTextField.prototype.activateFocus = /**\n     * Activates the text field focus state.\n     * @return {?}\n     */\n        function () {\n            this._foundation.activateFocus();\n        };\n    /** Sets the content of the helper text. */\n    /**\n     * Sets the content of the helper text.\n     * @param {?} content\n     * @return {?}\n     */\n    MdcTextField.prototype.setHelperTextContent = /**\n     * Sets the content of the helper text.\n     * @param {?} content\n     * @return {?}\n     */\n        function (content) {\n            this._foundation.setHelperTextContent(content);\n        };\n    /**\n     * @param {?} label\n     * @return {?}\n     */\n    MdcTextField.prototype.setIconAriaLabel = /**\n     * @param {?} label\n     * @return {?}\n     */\n        function (label) {\n            this._iconFoundation.setAriaLabel(label);\n        };\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    MdcTextField.prototype.setIconContent = /**\n     * @param {?} content\n     * @return {?}\n     */\n        function (content) {\n            this._iconFoundation.setContent(content);\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.updateIconState = /**\n     * @return {?}\n     */\n        function () {\n            if (this.icons.find(function (_) { return _.isLeading(); })) {\n                this._renderer.addClass(this._getHostElement(), 'mdc-text-field--with-leading-icon');\n            }\n            else if (this.icons.find(function (_) { return _.isTrailing(); })) {\n                this._renderer.addClass(this._getHostElement(), 'mdc-text-field--with-trailing-icon');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.getLeadingIcon = /**\n     * @return {?}\n     */\n        function () {\n            return this.icons.find(function (_) { return _.isLeading(); });\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype.getTrailingIcon = /**\n     * @return {?}\n     */\n        function () {\n            return this.icons.find(function (_) { return _.isTrailing(); });\n        };\n    /**\n     * @return {?}\n     */\n    MdcTextField.prototype._hasIcons = /**\n     * @return {?}\n     */\n        function () {\n            return this.icons && this.icons.length > 0;\n        };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    MdcTextField.prototype.setDisabledState = /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n        function (isDisabled) {\n            this._disabled = isDisabled;\n            this._foundation.setDisabled(isDisabled);\n            if (this.focused) {\n                this.focused = false;\n            }\n            if (this._hasIcons()) {\n                // Reset the clickable state of mdc-icon\n                this.icons.first.clickable = this.icons.first.clickable;\n            }\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} className\n     * @return {?}\n     */\n    MdcTextField.prototype.hasClass = /**\n     * @param {?} className\n     * @return {?}\n     */\n        function (className) {\n            return this._getHostElement().classList.contains(className);\n        };\n    /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n    MdcTextField.prototype._getHostElement = /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n        function () {\n            return this.elementRef.nativeElement;\n        };\n    /** Make sure the input is a supported type. */\n    /**\n     * Make sure the input is a supported type.\n     * @return {?}\n     */\n    MdcTextField.prototype._validateType = /**\n     * Make sure the input is a supported type.\n     * @return {?}\n     */\n        function () {\n            if (MDC_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n                throw Error(\"Input type \\\"\" + this._type + \"\\\" is not supported.\");\n            }\n        };\n    return MdcTextField;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: /*@__PURE__*/ forwardRef(function () { return MdcTextarea; }),\n    multi: true\n};\nvar MdcTextarea = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(MdcTextarea, _super);\n    function MdcTextarea() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isHostClass = true;\n        return _this;\n    }\n    return MdcTextarea;\n}(MdcTextField));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ TEXTFIELD_DECLARATIONS = [\n    MdcTextarea,\n    MdcTextField,\n    MdcTextFieldHelperText,\n];\nvar MdcTextFieldModule = /** @class */ /*@__PURE__*/ (function () {\n    function MdcTextFieldModule() {\n    }\n    return MdcTextFieldModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MdcTextFieldModule, MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR, MdcTextField, MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR, MdcTextarea, MdcTextFieldHelperText };\n",null]}