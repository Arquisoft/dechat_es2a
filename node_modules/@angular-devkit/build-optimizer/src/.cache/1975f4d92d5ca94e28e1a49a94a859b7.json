{"remainingRequest":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\menu.es5.js","dependencies":[{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-mdc\\web\\esm5\\menu.es5.js","mtime":1556004096892},{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1556004112812},{"path":"C:\\Users\\Becario\\Arquitectura\\dechat_es2a\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1556004088045}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright (c) 2018 Dominic Carretto\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE\n */\n/** PURE_IMPORTS_START _angular_core,_angular_mdc_web_common,_angular_common PURE_IMPORTS_END */\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, Input, Output, Renderer2, ViewChild, NgModule } from '@angular/core';\nimport { isBrowser, toBoolean, EventRegistry } from '@angular-mdc/web/common';\nimport { CommonModule } from '@angular/common';\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @type {string|undefined} */\nvar storedTransformPropertyName_;\n/**\n * Returns the name of the correct transform property to use on the current browser.\n * @param {!Window} globalObj\n * @param {boolean=} forceRefresh\n * @return {string}\n */\nfunction getTransformPropertyName(globalObj) {\n    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (storedTransformPropertyName_ === undefined || forceRefresh) {\n        var el = globalObj.document.createElement('div');\n        var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';\n        storedTransformPropertyName_ = transformPropertyName;\n    }\n    return storedTransformPropertyName_;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    }\n    else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass)\n        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @template A\n */\nvar MDCFoundation = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    _createClass(MDCFoundation, null, [{\n            key: \"cssClasses\",\n            /** @return enum{cssClasses} */\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports every\n                // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}\n                return {};\n            }\n            /** @return enum{strings} */\n        }, {\n            key: \"strings\",\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports all\n                // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}\n                return {};\n            }\n            /** @return enum{numbers} */\n        }, {\n            key: \"numbers\",\n            get: function get() {\n                // Classes extending MDCFoundation should implement this method to return an object which exports all\n                // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n                return {};\n            }\n            /** @return {!Object} */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n                // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n                // validation.\n                return {};\n            }\n            /**\n             * @param {A=} adapter\n             */\n        }]);\n    function MDCFoundation() {\n        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, MDCFoundation);\n        /** @protected {!A} */\n        this.adapter_ = adapter;\n    }\n    _createClass(MDCFoundation, [{\n            key: \"init\",\n            value: function init() {\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n            }\n        }]);\n    return MDCFoundation;\n}();\n/**\n * @template F\n */\nvar MDCComponent = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    _createClass(MDCComponent, null, [{\n            key: \"attachTo\",\n            /**\n             * @param {!Element} root\n             * @return {!MDCComponent}\n             */\n            value: function attachTo(root) {\n                // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and\n                // returns an instantiated component with its root set to that element. Also note that in the cases of\n                // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized\n                // from getDefaultFoundation().\n                return new MDCComponent(root, new MDCFoundation());\n            }\n            /**\n             * @param {!Element} root\n             * @param {F=} foundation\n             * @param {...?} args\n             */\n        }]);\n    function MDCComponent(root) {\n        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        _classCallCheck(this, MDCComponent);\n        /** @protected {!Element} */\n        this.root_ = root;\n        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n            args[_key - 2] = arguments[_key];\n        }\n        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that\n        // this.root_ is defined and can be used within the foundation class.\n        /** @protected {!F} */\n        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;\n        this.foundation_.init();\n        this.initialSyncWithDOM();\n    }\n    _createClass(MDCComponent, [{\n            key: \"initialize\",\n            value: function initialize() { } // Subclasses can override this to do any additional setup work that would be considered part of a\n            // \"constructor\". Essentially, it is a hook into the parent constructor before the foundation is\n            // initialized. Any additional arguments besides root and foundation will be passed in here.\n            /**\n             * @return {!F} foundation\n             */\n        }, {\n            key: \"getDefaultFoundation\",\n            value: function getDefaultFoundation() {\n                // Subclasses must override this method to return a properly configured foundation class for the\n                // component.\n                throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');\n            }\n        }, {\n            key: \"initialSyncWithDOM\",\n            value: function initialSyncWithDOM() {\n                // object. An example of this would be a form control wrapper that needs to synchronize its internal state\n                // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM\n                // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                // Subclasses may implement this method to release any resources / deregister any listeners they have\n                // attached. An example of this might be deregistering a resize event from the window object.\n                this.foundation_.destroy();\n            }\n            /**\n             * Wrapper method to add an event listener to the component's root element. This is most useful when\n             * listening for custom events.\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"listen\",\n            value: function listen(evtType, handler) {\n                this.root_.addEventListener(evtType, handler);\n            }\n            /**\n             * Wrapper method to remove an event listener to the component's root element. This is most useful when\n             * unlistening for custom events.\n             * @param {string} evtType\n             * @param {!Function} handler\n             */\n        }, {\n            key: \"unlisten\",\n            value: function unlisten(evtType, handler) {\n                this.root_.removeEventListener(evtType, handler);\n            }\n            /**\n             * Fires a cross-browser-compatible custom event from the component root of the given type,\n             * with the given data.\n             * @param {string} evtType\n             * @param {!Object} evtData\n             * @param {boolean=} shouldBubble\n             */\n        }, {\n            key: \"emit\",\n            value: function emit(evtType, evtData) {\n                var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var evt;\n                if (typeof CustomEvent === 'function') {\n                    evt = new CustomEvent(evtType, {\n                        detail: evtData,\n                        bubbles: shouldBubble\n                    });\n                }\n                else {\n                    evt = document.createEvent('CustomEvent');\n                    evt.initCustomEvent(evtType, shouldBubble, false, evtData);\n                }\n                this.root_.dispatchEvent(evt);\n            }\n        }]);\n    return MDCComponent;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n/**\n * Adapter for MDC Menu. Provides an interface for managing\n * - classes\n * - dom\n * - focus\n * - position\n * - dimensions\n * - event handlers\n *\n * Additionally, provides type information for the adapter to the Closure\n * compiler.\n *\n * Implement this adapter for your framework of choice to delegate updates to\n * the component in your framework of choice. See architecture documentation\n * for more details.\n * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md\n *\n * @record\n */\nvar MDCMenuAdapter = \n/*#__PURE__*/\n/*@__PURE__*/ function () {\n    function MDCMenuAdapter() {\n        _classCallCheck(this, MDCMenuAdapter);\n    }\n    _createClass(MDCMenuAdapter, [{\n            key: \"addClass\",\n            /** @param {string} className */\n            value: function addClass(className) { }\n            /** @param {string} className */\n        }, {\n            key: \"removeClass\",\n            value: function removeClass(className) { }\n            /**\n             * @param {string} className\n             * @return {boolean}\n             */\n        }, {\n            key: \"hasClass\",\n            value: function hasClass(className) { }\n            /** @return {boolean} */\n        }, {\n            key: \"hasNecessaryDom\",\n            value: function hasNecessaryDom() { }\n            /**\n             * @param {EventTarget} target\n             * @param {string} attributeName\n             * @return {string}\n             */\n        }, {\n            key: \"getAttributeForEventTarget\",\n            value: function getAttributeForEventTarget(target, attributeName) { }\n            /** @return {{ width: number, height: number }} */\n        }, {\n            key: \"getInnerDimensions\",\n            value: function getInnerDimensions() { }\n            /** @return {boolean} */\n        }, {\n            key: \"hasAnchor\",\n            value: function hasAnchor() { }\n            /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */\n        }, {\n            key: \"getAnchorDimensions\",\n            value: function getAnchorDimensions() { }\n            /** @return {{ width: number, height: number }} */\n        }, {\n            key: \"getWindowDimensions\",\n            value: function getWindowDimensions() { }\n            /** @return {number} */\n        }, {\n            key: \"getNumberOfItems\",\n            value: function getNumberOfItems() { }\n            /**\n             * @param {string} type\n             * @param {function(!Event)} handler\n             */\n        }, {\n            key: \"registerInteractionHandler\",\n            value: function registerInteractionHandler(type, handler) { }\n            /**\n             * @param {string} type\n             * @param {function(!Event)} handler\n             */\n        }, {\n            key: \"deregisterInteractionHandler\",\n            value: function deregisterInteractionHandler(type, handler) { }\n            /** @param {function(!Event)} handler */\n        }, {\n            key: \"registerBodyClickHandler\",\n            value: function registerBodyClickHandler(handler) { }\n            /** @param {function(!Event)} handler */\n        }, {\n            key: \"deregisterBodyClickHandler\",\n            value: function deregisterBodyClickHandler(handler) { }\n            /**\n             * @param {EventTarget} target\n             * @return {number}\n             */\n        }, {\n            key: \"getIndexForEventTarget\",\n            value: function getIndexForEventTarget(target) { }\n            /** @param {{index: number}} evtData */\n        }, {\n            key: \"notifySelected\",\n            value: function notifySelected(evtData) { }\n        }, {\n            key: \"notifyCancel\",\n            value: function notifyCancel() { }\n        }, {\n            key: \"saveFocus\",\n            value: function saveFocus() { }\n        }, {\n            key: \"restoreFocus\",\n            value: function restoreFocus() { }\n            /** @return {boolean} */\n        }, {\n            key: \"isFocused\",\n            value: function isFocused() { }\n        }, {\n            key: \"focus\",\n            value: function focus() { }\n            /** @return {number} */\n        }, {\n            key: \"getFocusedItemIndex\",\n            value: function getFocusedItemIndex() { }\n            /** @param {number} index */\n        }, {\n            key: \"focusItemAtIndex\",\n            value: function focusItemAtIndex(index) { }\n            /** @return {boolean} */\n        }, {\n            key: \"isRtl\",\n            value: function isRtl() { }\n            /** @param {string} origin */\n        }, {\n            key: \"setTransformOrigin\",\n            value: function setTransformOrigin(origin) { }\n            /** @param {{\n            *   top: (string|undefined),\n            *   right: (string|undefined),\n            *   bottom: (string|undefined),\n            *   left: (string|undefined)\n            * }} position */\n        }, {\n            key: \"setPosition\",\n            value: function setPosition(position) { }\n            /** @param {string} height */\n        }, {\n            key: \"setMaxHeight\",\n            value: function setMaxHeight(height) { }\n            /**\n             * @param {number} index\n             * @param {string} attr\n             * @param {string} value\n             */\n        }, {\n            key: \"setAttrForOptionAtIndex\",\n            value: function setAttrForOptionAtIndex(index, attr, value) { }\n            /**\n             * @param {number} index\n             * @param {string} attr\n             */\n        }, {\n            key: \"rmAttrForOptionAtIndex\",\n            value: function rmAttrForOptionAtIndex(index, attr) { }\n            /**\n             * @param {number} index\n             * @param {string} className\n             */\n        }, {\n            key: \"addClassForOptionAtIndex\",\n            value: function addClassForOptionAtIndex(index, className) { }\n            /**\n             * @param {number} index\n             * @param {string} className\n             */\n        }, {\n            key: \"rmClassForOptionAtIndex\",\n            value: function rmClassForOptionAtIndex(index, className) { }\n        }]);\n    return MDCMenuAdapter;\n}();\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @enum {string} */\nvar cssClasses = {\n    ROOT: 'mdc-menu',\n    OPEN: 'mdc-menu--open',\n    ANIMATING_OPEN: 'mdc-menu--animating-open',\n    ANIMATING_CLOSED: 'mdc-menu--animating-closed',\n    SELECTED_LIST_ITEM: 'mdc-list-item--selected'\n};\n/** @enum {string} */\nvar strings = {\n    ITEMS_SELECTOR: '.mdc-menu__items',\n    SELECTED_EVENT: 'MDCMenu:selected',\n    CANCEL_EVENT: 'MDCMenu:cancel',\n    ARIA_DISABLED_ATTR: 'aria-disabled'\n};\n/** @enum {number} */\nvar numbers = {\n    // Amount of time to wait before triggering a selected event on the menu. Note that this time\n    // will most likely be bumped up once interactive lists are supported to allow for the ripple to\n    // animate before closing the menu\n    SELECTED_TRIGGER_DELAY: 50,\n    // Total duration of menu open animation.\n    TRANSITION_OPEN_DURATION: 120,\n    // Total duration of menu close animation.\n    TRANSITION_CLOSE_DURATION: 75,\n    // Margin left to the edge of the viewport when menu is at maximum possible height.\n    MARGIN_TO_EDGE: 32,\n    // Ratio of anchor width to menu width for switching from corner positioning to center positioning.\n    ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,\n    // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.\n    OFFSET_TO_MENU_HEIGHT_RATIO: 0.1\n};\n/**\n * Enum for bits in the {@see Corner) bitmap.\n * @enum {number}\n */\nvar CornerBit = {\n    BOTTOM: 1,\n    CENTER: 2,\n    RIGHT: 4,\n    FLIP_RTL: 8\n};\n/**\n * Enum for representing an element corner for positioning the menu.\n *\n * The START constants map to LEFT if element directionality is left\n * to right and RIGHT if the directionality is right to left.\n * Likewise END maps to RIGHT or LEFT depending on the directionality.\n *\n * @enum {number}\n */\nvar Corner = {\n    TOP_LEFT: 0,\n    TOP_RIGHT: CornerBit.RIGHT,\n    BOTTOM_LEFT: CornerBit.BOTTOM,\n    BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,\n    TOP_START: CornerBit.FLIP_RTL,\n    TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,\n    BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,\n    BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL\n};\n/**\n * @extends {MDCFoundation<!MDCMenuAdapter>}\n */\nvar MDCMenuFoundation = \n/*#__PURE__*/\nfunction (_MDCFoundation) {\n    _inherits(MDCMenuFoundation, _MDCFoundation);\n    _createClass(MDCMenuFoundation, null, [{\n            key: \"cssClasses\",\n            /** @return enum{cssClasses} */\n            get: function get() {\n                return cssClasses;\n            }\n            /** @return enum{strings} */\n        }, {\n            key: \"strings\",\n            get: function get() {\n                return strings;\n            }\n            /** @return enum{numbers} */\n        }, {\n            key: \"numbers\",\n            get: function get() {\n                return numbers;\n            }\n            /** @return enum{number} */\n        }, {\n            key: \"Corner\",\n            get: function get() {\n                return Corner;\n            }\n            /**\n             * {@see MDCMenuAdapter} for typing information on parameters and return\n             * types.\n             * @return {!MDCMenuAdapter}\n             */\n        }, {\n            key: \"defaultAdapter\",\n            get: function get() {\n                return (\n                /** @type {!MDCMenuAdapter} */\n                {\n                    addClass: function addClass() { },\n                    removeClass: function removeClass() { },\n                    hasClass: function hasClass() {\n                        return false;\n                    },\n                    hasNecessaryDom: function hasNecessaryDom() {\n                        return false;\n                    },\n                    getAttributeForEventTarget: function getAttributeForEventTarget() { },\n                    getInnerDimensions: function getInnerDimensions() {\n                        return {};\n                    },\n                    hasAnchor: function hasAnchor() {\n                        return false;\n                    },\n                    getAnchorDimensions: function getAnchorDimensions() {\n                        return {};\n                    },\n                    getWindowDimensions: function getWindowDimensions() {\n                        return {};\n                    },\n                    getNumberOfItems: function getNumberOfItems() {\n                        return 0;\n                    },\n                    registerInteractionHandler: function registerInteractionHandler() { },\n                    deregisterInteractionHandler: function deregisterInteractionHandler() { },\n                    registerBodyClickHandler: function registerBodyClickHandler() { },\n                    deregisterBodyClickHandler: function deregisterBodyClickHandler() { },\n                    getIndexForEventTarget: function getIndexForEventTarget() {\n                        return 0;\n                    },\n                    notifySelected: function notifySelected() { },\n                    notifyCancel: function notifyCancel() { },\n                    saveFocus: function saveFocus() { },\n                    restoreFocus: function restoreFocus() { },\n                    isFocused: function isFocused() {\n                        return false;\n                    },\n                    focus: function focus() { },\n                    getFocusedItemIndex: function getFocusedItemIndex() {\n                        return -1;\n                    },\n                    focusItemAtIndex: function focusItemAtIndex() { },\n                    isRtl: function isRtl() {\n                        return false;\n                    },\n                    setTransformOrigin: function setTransformOrigin() { },\n                    setPosition: function setPosition() { },\n                    setMaxHeight: function setMaxHeight() { },\n                    setAttrForOptionAtIndex: function setAttrForOptionAtIndex() { },\n                    rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() { },\n                    addClassForOptionAtIndex: function addClassForOptionAtIndex() { },\n                    rmClassForOptionAtIndex: function rmClassForOptionAtIndex() { }\n                });\n            }\n            /** @param {!MDCMenuAdapter} adapter */\n        }]);\n    function MDCMenuFoundation(adapter) {\n        var _this;\n        _classCallCheck(this, MDCMenuFoundation);\n        _this = _possibleConstructorReturn(this, (MDCMenuFoundation.__proto__ || Object.getPrototypeOf(MDCMenuFoundation)).call(this, Object.assign(MDCMenuFoundation.defaultAdapter, adapter)));\n        /** @private {function(!Event)} */\n        _this.clickHandler_ = function (evt) {\n            return _this.handlePossibleSelected_(evt);\n        };\n        /** @private {function(!Event)} */\n        _this.keydownHandler_ = function (evt) {\n            return _this.handleKeyboardDown_(evt);\n        };\n        /** @private {function(!Event)} */\n        _this.keyupHandler_ = function (evt) {\n            return _this.handleKeyboardUp_(evt);\n        };\n        /** @private {function(!Event)} */\n        _this.documentClickHandler_ = function (evt) {\n            return _this.handleDocumentClick_(evt);\n        };\n        /** @private {boolean} */\n        _this.isOpen_ = false;\n        /** @private {number} */\n        _this.openAnimationEndTimerId_ = 0;\n        /** @private {number} */\n        _this.closeAnimationEndTimerId_ = 0;\n        /** @private {number} */\n        _this.selectedTriggerTimerId_ = 0;\n        /** @private {number} */\n        _this.animationRequestId_ = 0;\n        /** @private {!{ width: number, height: number }} */\n        _this.dimensions_;\n        /** @private {number} */\n        _this.itemHeight_;\n        /** @private {Corner} */\n        _this.anchorCorner_ = Corner.TOP_START;\n        /** @private {AnchorMargin} */\n        _this.anchorMargin_ = {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        };\n        /** @private {?AutoLayoutMeasurements} */\n        _this.measures_ = null;\n        /** @private {number} */\n        _this.selectedIndex_ = -1;\n        /** @private {boolean} */\n        _this.rememberSelection_ = false;\n        /** @private {boolean} */\n        _this.quickOpen_ = false; // A keyup event on the menu needs to have a corresponding keydown\n        // event on the menu. If the user opens the menu with a keydown event on a\n        // button, the menu will only get the key up event causing buggy behavior with selected elements.\n        /** @private {boolean} */\n        _this.keyDownWithinMenu_ = false;\n        return _this;\n    }\n    _createClass(MDCMenuFoundation, [{\n            key: \"init\",\n            value: function init() {\n                var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses, ROOT = _MDCMenuFoundation$cs.ROOT, OPEN = _MDCMenuFoundation$cs.OPEN;\n                if (!this.adapter_.hasClass(ROOT)) {\n                    throw new Error(\"\".concat(ROOT, \" class required in root element.\"));\n                }\n                if (!this.adapter_.hasNecessaryDom()) {\n                    throw new Error(\"Required DOM nodes missing in \".concat(ROOT, \" component.\"));\n                }\n                if (this.adapter_.hasClass(OPEN)) {\n                    this.isOpen_ = true;\n                }\n                this.adapter_.registerInteractionHandler('click', this.clickHandler_);\n                this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);\n                this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);\n            }\n        }, {\n            key: \"destroy\",\n            value: function destroy() {\n                clearTimeout(this.selectedTriggerTimerId_);\n                clearTimeout(this.openAnimationEndTimerId_);\n                clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.\n                cancelAnimationFrame(this.animationRequestId_);\n                this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);\n                this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);\n                this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);\n                this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);\n            }\n            /**\n             * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.\n             */\n        }, {\n            key: \"setAnchorCorner\",\n            value: function setAnchorCorner(corner) {\n                this.anchorCorner_ = corner;\n            }\n            /**\n             * @param {!AnchorMargin} margin 4-plet of margins from anchor.\n             */\n        }, {\n            key: \"setAnchorMargin\",\n            value: function setAnchorMargin(margin) {\n                this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;\n                this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;\n                this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;\n                this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;\n            }\n            /** @param {boolean} rememberSelection */\n        }, {\n            key: \"setRememberSelection\",\n            value: function setRememberSelection(rememberSelection) {\n                this.rememberSelection_ = rememberSelection;\n                this.setSelectedIndex(-1);\n            }\n            /** @param {boolean} quickOpen */\n        }, {\n            key: \"setQuickOpen\",\n            value: function setQuickOpen(quickOpen) {\n                this.quickOpen_ = quickOpen;\n            }\n            /**\n             * @param {?number} focusIndex\n             * @private\n             */\n        }, {\n            key: \"focusOnOpen_\",\n            value: function focusOnOpen_(focusIndex) {\n                if (focusIndex === null) {\n                    // If this instance of MDCMenu remembers selections, and the user has\n                    // made a selection, then focus the last selected item\n                    if (this.rememberSelection_ && this.selectedIndex_ >= 0) {\n                        this.adapter_.focusItemAtIndex(this.selectedIndex_);\n                        return;\n                    }\n                    this.adapter_.focus(); // If that doesn't work, focus first item instead.\n                    if (!this.adapter_.isFocused()) {\n                        this.adapter_.focusItemAtIndex(0);\n                    }\n                }\n                else {\n                    this.adapter_.focusItemAtIndex(focusIndex);\n                }\n            }\n            /**\n             * Handle clicks and cancel the menu if not a child list-item\n             * @param {!Event} evt\n             * @private\n             */\n        }, {\n            key: \"handleDocumentClick_\",\n            value: function handleDocumentClick_(evt) {\n                var el = evt.target;\n                while (el && el !== document.documentElement) {\n                    if (this.adapter_.getIndexForEventTarget(el) !== -1) {\n                        return;\n                    }\n                    el = el.parentNode;\n                }\n                this.adapter_.notifyCancel();\n                this.close(evt);\n            }\n        }, {\n            key: \"handleKeyboardDown_\",\n            /**\n             * Handle keys that we want to repeat on hold (tab and arrows).\n             * @param {!Event} evt\n             * @return {boolean}\n             * @private\n             */\n            value: function handleKeyboardDown_(evt) {\n                // Do nothing if Alt, Ctrl or Meta are pressed.\n                if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n                    return true;\n                }\n                var keyCode = evt.keyCode, key = evt.key, shiftKey = evt.shiftKey;\n                var isTab = key === 'Tab' || keyCode === 9;\n                var isArrowUp = key === 'ArrowUp' || keyCode === 38;\n                var isArrowDown = key === 'ArrowDown' || keyCode === 40;\n                var isSpace = key === 'Space' || keyCode === 32;\n                var isEnter = key === 'Enter' || keyCode === 13; // The menu needs to know if the keydown event was triggered on the menu\n                this.keyDownWithinMenu_ = isEnter || isSpace;\n                var focusedItemIndex = this.adapter_.getFocusedItemIndex();\n                var lastItemIndex = this.adapter_.getNumberOfItems() - 1;\n                if (shiftKey && isTab && focusedItemIndex === 0) {\n                    this.adapter_.focusItemAtIndex(lastItemIndex);\n                    evt.preventDefault();\n                    return false;\n                }\n                if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {\n                    this.adapter_.focusItemAtIndex(0);\n                    evt.preventDefault();\n                    return false;\n                } // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling\n                if (isArrowUp || isArrowDown || isSpace) {\n                    evt.preventDefault();\n                }\n                if (isArrowUp) {\n                    if (focusedItemIndex === 0 || this.adapter_.isFocused()) {\n                        this.adapter_.focusItemAtIndex(lastItemIndex);\n                    }\n                    else {\n                        this.adapter_.focusItemAtIndex(focusedItemIndex - 1);\n                    }\n                }\n                else if (isArrowDown) {\n                    if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {\n                        this.adapter_.focusItemAtIndex(0);\n                    }\n                    else {\n                        this.adapter_.focusItemAtIndex(focusedItemIndex + 1);\n                    }\n                }\n                return true;\n            }\n            /**\n             * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).\n             * @param {!Event} evt\n             * @return {boolean}\n             * @private\n             */\n        }, {\n            key: \"handleKeyboardUp_\",\n            value: function handleKeyboardUp_(evt) {\n                // Do nothing if Alt, Ctrl or Meta are pressed.\n                if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n                    return true;\n                }\n                var keyCode = evt.keyCode, key = evt.key;\n                var isEnter = key === 'Enter' || keyCode === 13;\n                var isSpace = key === 'Space' || keyCode === 32;\n                var isEscape = key === 'Escape' || keyCode === 27;\n                if (isEnter || isSpace) {\n                    // If the keydown event didn't occur on the menu, then it should\n                    // disregard the possible selected event.\n                    if (this.keyDownWithinMenu_) {\n                        this.handlePossibleSelected_(evt);\n                    }\n                    this.keyDownWithinMenu_ = false;\n                }\n                if (isEscape) {\n                    this.adapter_.notifyCancel();\n                    this.close();\n                }\n                return true;\n            }\n            /**\n             * @param {!Event} evt\n             * @private\n             */\n        }, {\n            key: \"handlePossibleSelected_\",\n            value: function handlePossibleSelected_(evt) {\n                var _this2 = this;\n                if (this.adapter_.getAttributeForEventTarget(evt.target, strings.ARIA_DISABLED_ATTR) === 'true') {\n                    return;\n                }\n                var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);\n                if (targetIndex < 0) {\n                    return;\n                } // Debounce multiple selections\n                if (this.selectedTriggerTimerId_) {\n                    return;\n                }\n                this.selectedTriggerTimerId_ = setTimeout(function () {\n                    _this2.selectedTriggerTimerId_ = 0;\n                    _this2.close();\n                    if (_this2.rememberSelection_) {\n                        _this2.setSelectedIndex(targetIndex);\n                    }\n                    _this2.adapter_.notifySelected({\n                        index: targetIndex\n                    });\n                }, numbers.SELECTED_TRIGGER_DELAY);\n            }\n            /**\n             * @return {AutoLayoutMeasurements} Measurements used to position menu popup.\n             */\n        }, {\n            key: \"getAutoLayoutMeasurements_\",\n            value: function getAutoLayoutMeasurements_() {\n                var anchorRect = this.adapter_.getAnchorDimensions();\n                var viewport = this.adapter_.getWindowDimensions();\n                return {\n                    viewport: viewport,\n                    viewportDistance: {\n                        top: anchorRect.top,\n                        right: viewport.width - anchorRect.right,\n                        left: anchorRect.left,\n                        bottom: viewport.height - anchorRect.bottom\n                    },\n                    anchorHeight: anchorRect.height,\n                    anchorWidth: anchorRect.width,\n                    menuHeight: this.dimensions_.height,\n                    menuWidth: this.dimensions_.width\n                };\n            }\n            /**\n             * Computes the corner of the anchor from which to animate and position the menu.\n             * @return {Corner}\n             * @private\n             */\n        }, {\n            key: \"getOriginCorner_\",\n            value: function getOriginCorner_() {\n                // Defaults: open from the top left.\n                var corner = Corner.TOP_LEFT;\n                var _measures_ = this.measures_, viewportDistance = _measures_.viewportDistance, anchorHeight = _measures_.anchorHeight, anchorWidth = _measures_.anchorWidth, menuHeight = _measures_.menuHeight, menuWidth = _measures_.menuWidth;\n                var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);\n                var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;\n                var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;\n                var topOverflow = menuHeight - availableTop;\n                var bottomOverflow = menuHeight - availableBottom;\n                if (bottomOverflow > 0 && topOverflow < bottomOverflow) {\n                    corner |= CornerBit.BOTTOM;\n                }\n                var isRtl = this.adapter_.isRtl();\n                var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);\n                var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);\n                var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;\n                var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;\n                var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;\n                var leftOverflow = menuWidth - availableLeft;\n                var rightOverflow = menuWidth - availableRight;\n                if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {\n                    corner |= CornerBit.RIGHT;\n                }\n                return corner;\n            }\n            /**\n             * @param {Corner} corner Origin corner of the menu.\n             * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.\n             * @private\n             */\n        }, {\n            key: \"getHorizontalOriginOffset_\",\n            value: function getHorizontalOriginOffset_(corner) {\n                var anchorWidth = this.measures_.anchorWidth;\n                var isRightAligned = Boolean(corner & CornerBit.RIGHT);\n                var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);\n                var x = 0;\n                if (isRightAligned) {\n                    var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;\n                    x = rightOffset;\n                }\n                else {\n                    var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;\n                    x = leftOffset;\n                }\n                return x;\n            }\n            /**\n             * @param {Corner} corner Origin corner of the menu.\n             * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.\n             * @private\n             */\n        }, {\n            key: \"getVerticalOriginOffset_\",\n            value: function getVerticalOriginOffset_(corner) {\n                var _measures_2 = this.measures_, viewport = _measures_2.viewport, viewportDistance = _measures_2.viewportDistance, anchorHeight = _measures_2.anchorHeight, menuHeight = _measures_2.menuHeight;\n                var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);\n                var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;\n                var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);\n                var canOverlapVertically = !avoidVerticalOverlap;\n                var y = 0;\n                if (isBottomAligned) {\n                    y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom; // adjust for when menu can overlap anchor, but too tall to be aligned to bottom\n                    // anchor corner. Bottom margin is ignored in such cases.\n                    if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {\n                        y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));\n                    }\n                }\n                else {\n                    y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top; // adjust for when menu can overlap anchor, but too tall to be aligned to top\n                    // anchor corners. Top margin is ignored in that case.\n                    if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {\n                        y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));\n                    }\n                }\n                return y;\n            }\n            /**\n             * @param {Corner} corner Origin corner of the menu.\n             * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.\n             * @private\n             */\n        }, {\n            key: \"getMenuMaxHeight_\",\n            value: function getMenuMaxHeight_(corner) {\n                var maxHeight = 0;\n                var viewportDistance = this.measures_.viewportDistance;\n                var isBottomAligned = Boolean(corner & CornerBit.BOTTOM); // When maximum height is not specified, it is handled from css.\n                if (this.anchorCorner_ & CornerBit.BOTTOM) {\n                    if (isBottomAligned) {\n                        maxHeight = viewportDistance.top + this.anchorMargin_.top;\n                    }\n                    else {\n                        maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;\n                    }\n                }\n                return maxHeight;\n            }\n            /** @private */\n        }, {\n            key: \"autoPosition_\",\n            value: function autoPosition_() {\n                var _position;\n                if (!this.adapter_.hasAnchor()) {\n                    return;\n                } // Compute measurements for autoposition methods reuse.\n                this.measures_ = this.getAutoLayoutMeasurements_();\n                var corner = this.getOriginCorner_();\n                var maxMenuHeight = this.getMenuMaxHeight_(corner);\n                var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';\n                var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';\n                var horizontalOffset = this.getHorizontalOriginOffset_(corner);\n                var verticalOffset = this.getVerticalOriginOffset_(corner);\n                var position = (_position = {}, _defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), _defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);\n                var _measures_3 = this.measures_, anchorWidth = _measures_3.anchorWidth, menuHeight = _measures_3.menuHeight, menuWidth = _measures_3.menuWidth; // Center align when anchor width is comparable or greater than menu, otherwise keep corner.\n                if (anchorWidth / menuWidth > numbers.ANCHOR_TO_MENU_WIDTH_RATIO) {\n                    horizontalAlignment = 'center';\n                } // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that\n                // scale animation is \"anchored\" on the anchor.\n                if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers.OFFSET_TO_MENU_HEIGHT_RATIO) {\n                    var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;\n                    var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;\n                    verticalAlignment = Math.round(originPercent * 100) / 100 + '%';\n                }\n                this.adapter_.setTransformOrigin(\"\".concat(horizontalAlignment, \" \").concat(verticalAlignment));\n                this.adapter_.setPosition(position);\n                this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : ''); // Clear measures after positioning is complete.\n                this.measures_ = null;\n            }\n            /**\n             * Open the menu.\n             * @param {{focusIndex: ?number}=} options\n             */\n        }, {\n            key: \"open\",\n            value: function open() {\n                var _this3 = this;\n                var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$focusIndex = _ref.focusIndex, focusIndex = _ref$focusIndex === void 0 ? null : _ref$focusIndex;\n                this.adapter_.saveFocus();\n                if (!this.quickOpen_) {\n                    this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);\n                }\n                this.animationRequestId_ = requestAnimationFrame(function () {\n                    _this3.dimensions_ = _this3.adapter_.getInnerDimensions();\n                    _this3.autoPosition_();\n                    _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);\n                    _this3.focusOnOpen_(focusIndex);\n                    _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);\n                    if (!_this3.quickOpen_) {\n                        _this3.openAnimationEndTimerId_ = setTimeout(function () {\n                            _this3.openAnimationEndTimerId_ = 0;\n                            _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);\n                        }, numbers.TRANSITION_OPEN_DURATION);\n                    }\n                });\n                this.isOpen_ = true;\n            }\n            /**\n             * Closes the menu.\n             * @param {Event=} evt\n             */\n        }, {\n            key: \"close\",\n            value: function close() {\n                var _this4 = this;\n                var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n                var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings.ARIA_DISABLED_ATTR) === 'true' : false;\n                if (targetIsDisabled) {\n                    return;\n                }\n                this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);\n                if (!this.quickOpen_) {\n                    this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);\n                }\n                requestAnimationFrame(function () {\n                    _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);\n                    if (!_this4.quickOpen_) {\n                        _this4.closeAnimationEndTimerId_ = setTimeout(function () {\n                            _this4.closeAnimationEndTimerId_ = 0;\n                            _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);\n                        }, numbers.TRANSITION_CLOSE_DURATION);\n                    }\n                });\n                this.isOpen_ = false;\n                this.adapter_.restoreFocus();\n            }\n            /** @return {boolean} */\n        }, {\n            key: \"isOpen\",\n            value: function isOpen() {\n                return this.isOpen_;\n            }\n            /** @return {number} */\n        }, {\n            key: \"getSelectedIndex\",\n            value: function getSelectedIndex() {\n                return this.selectedIndex_;\n            }\n            /**\n             * @param {number} index Index of the item to set as selected.\n             */\n        }, {\n            key: \"setSelectedIndex\",\n            value: function setSelectedIndex(index) {\n                if (index === this.selectedIndex_) {\n                    return;\n                }\n                var prevSelectedIndex = this.selectedIndex_;\n                if (prevSelectedIndex >= 0) {\n                    this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');\n                    this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses.SELECTED_LIST_ITEM);\n                }\n                this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;\n                if (this.selectedIndex_ >= 0) {\n                    this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');\n                    this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses.SELECTED_LIST_ITEM);\n                }\n            }\n        }]);\n    return MDCMenuFoundation;\n}(MDCFoundation);\n/**\n * @extends MDCComponent<!MDCMenuFoundation>\n */\nvar MDCMenu = \n/*#__PURE__*/\nfunction (_MDCComponent) {\n    _inherits(MDCMenu, _MDCComponent);\n    /** @param {...?} args */\n    function MDCMenu() {\n        var _ref;\n        var _this;\n        _classCallCheck(this, MDCMenu);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _possibleConstructorReturn(this, (_ref = MDCMenu.__proto__ || Object.getPrototypeOf(MDCMenu)).call.apply(_ref, [this].concat(args)));\n        /** @private {!Element} */\n        _this.previousFocus_;\n        return _this;\n    }\n    /**\n     * @param {!Element} root\n     * @return {!MDCMenu}\n     */\n    _createClass(MDCMenu, [{\n            key: \"show\",\n            /** @param {{focusIndex: ?number}=} options */\n            value: function show() {\n                var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref2$focusIndex = _ref2.focusIndex, focusIndex = _ref2$focusIndex === void 0 ? null : _ref2$focusIndex;\n                this.foundation_.open({\n                    focusIndex: focusIndex\n                });\n            }\n        }, {\n            key: \"hide\",\n            value: function hide() {\n                this.foundation_.close();\n            }\n            /**\n             * @param {Corner} corner Default anchor corner alignment of top-left\n             *     menu corner.\n             */\n        }, {\n            key: \"setAnchorCorner\",\n            value: function setAnchorCorner(corner) {\n                this.foundation_.setAnchorCorner(corner);\n            }\n            /**\n             * @param {AnchorMargin} margin\n             */\n        }, {\n            key: \"setAnchorMargin\",\n            value: function setAnchorMargin(margin) {\n                this.foundation_.setAnchorMargin(margin);\n            }\n            /**\n             * Return the item container element inside the component.\n             * @return {?Element}\n             */\n        }, {\n            key: \"getOptionByIndex\",\n            /**\n             * Return the item within the menu that is selected.\n             * @param {number} index\n             * @return {?Element}\n             */\n            value: function getOptionByIndex(index) {\n                var items = this.items;\n                if (index < items.length) {\n                    return this.items[index];\n                }\n                else {\n                    return null;\n                }\n            }\n            /** @param {number} index */\n        }, {\n            key: \"getDefaultFoundation\",\n            /** @return {!MDCMenuFoundation} */\n            value: function getDefaultFoundation() {\n                var _this2 = this;\n                return new MDCMenuFoundation({\n                    addClass: function addClass(className) {\n                        return _this2.root_.classList.add(className);\n                    },\n                    removeClass: function removeClass(className) {\n                        return _this2.root_.classList.remove(className);\n                    },\n                    hasClass: function hasClass(className) {\n                        return _this2.root_.classList.contains(className);\n                    },\n                    hasNecessaryDom: function hasNecessaryDom() {\n                        return Boolean(_this2.itemsContainer_);\n                    },\n                    getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {\n                        return target.getAttribute(attributeName);\n                    },\n                    getInnerDimensions: function getInnerDimensions() {\n                        var itemsContainer = _this2.itemsContainer_;\n                        return {\n                            width: itemsContainer.offsetWidth,\n                            height: itemsContainer.offsetHeight\n                        };\n                    },\n                    hasAnchor: function hasAnchor() {\n                        return _this2.root_.parentElement && _this2.root_.parentElement.classList.contains('mdc-menu-anchor');\n                    },\n                    getAnchorDimensions: function getAnchorDimensions() {\n                        return _this2.root_.parentElement.getBoundingClientRect();\n                    },\n                    getWindowDimensions: function getWindowDimensions() {\n                        return {\n                            width: window.innerWidth,\n                            height: window.innerHeight\n                        };\n                    },\n                    getNumberOfItems: function getNumberOfItems() {\n                        return _this2.items.length;\n                    },\n                    registerInteractionHandler: function registerInteractionHandler(type, handler) {\n                        return _this2.root_.addEventListener(type, handler);\n                    },\n                    deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {\n                        return _this2.root_.removeEventListener(type, handler);\n                    },\n                    registerBodyClickHandler: function registerBodyClickHandler(handler) {\n                        return document.body.addEventListener('click', handler);\n                    },\n                    deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {\n                        return document.body.removeEventListener('click', handler);\n                    },\n                    getIndexForEventTarget: function getIndexForEventTarget(target) {\n                        return _this2.items.indexOf(target);\n                    },\n                    notifySelected: function notifySelected(evtData) {\n                        return _this2.emit(MDCMenuFoundation.strings.SELECTED_EVENT, {\n                            index: evtData.index,\n                            item: _this2.items[evtData.index]\n                        });\n                    },\n                    notifyCancel: function notifyCancel() {\n                        return _this2.emit(MDCMenuFoundation.strings.CANCEL_EVENT, {});\n                    },\n                    saveFocus: function saveFocus() {\n                        _this2.previousFocus_ = document.activeElement;\n                    },\n                    restoreFocus: function restoreFocus() {\n                        if (_this2.previousFocus_) {\n                            _this2.previousFocus_.focus();\n                        }\n                    },\n                    isFocused: function isFocused() {\n                        return document.activeElement === _this2.root_;\n                    },\n                    focus: function focus() {\n                        return _this2.root_.focus();\n                    },\n                    getFocusedItemIndex: function getFocusedItemIndex() {\n                        return _this2.items.indexOf(document.activeElement);\n                    },\n                    focusItemAtIndex: function focusItemAtIndex(index) {\n                        return _this2.items[index].focus();\n                    },\n                    isRtl: function isRtl() {\n                        return getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';\n                    },\n                    setTransformOrigin: function setTransformOrigin(origin) {\n                        _this2.root_.style[\"\".concat(getTransformPropertyName(window), \"-origin\")] = origin;\n                    },\n                    setPosition: function setPosition(position) {\n                        _this2.root_.style.left = 'left' in position ? position.left : null;\n                        _this2.root_.style.right = 'right' in position ? position.right : null;\n                        _this2.root_.style.top = 'top' in position ? position.top : null;\n                        _this2.root_.style.bottom = 'bottom' in position ? position.bottom : null;\n                    },\n                    setMaxHeight: function setMaxHeight(height) {\n                        _this2.root_.style.maxHeight = height;\n                    },\n                    setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {\n                        return _this2.items[index].setAttribute(attr, value);\n                    },\n                    rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {\n                        return _this2.items[index].removeAttribute(attr);\n                    },\n                    addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {\n                        return _this2.items[index].classList.add(className);\n                    },\n                    rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {\n                        return _this2.items[index].classList.remove(className);\n                    }\n                });\n            }\n        }, {\n            key: \"open\",\n            /** @return {boolean} */\n            get: function get() {\n                return this.foundation_.isOpen();\n            }\n            /** @param {boolean} value */\n            ,\n            set: function set(value) {\n                if (value) {\n                    this.foundation_.open();\n                }\n                else {\n                    this.foundation_.close();\n                }\n            }\n        }, {\n            key: \"itemsContainer_\",\n            get: function get() {\n                return this.root_.querySelector(MDCMenuFoundation.strings.ITEMS_SELECTOR);\n            }\n            /**\n             * Return the items within the menu. Note that this only contains the set of elements within\n             * the items container that are proper list items, and not supplemental / presentational DOM\n             * elements.\n             * @return {!Array<!Element>}\n             */\n        }, {\n            key: \"items\",\n            get: function get() {\n                var itemsContainer = this.itemsContainer_;\n                return [].slice.call(itemsContainer.querySelectorAll('.mdc-list-item[role]'));\n            }\n        }, {\n            key: \"selectedItemIndex\",\n            set: function set(index) {\n                this.foundation_.setSelectedIndex(index);\n            }\n            /** @return {number} */\n            ,\n            get: function get() {\n                return this.foundation_.getSelectedIndex();\n            }\n            /** @param {!boolean} rememberSelection */\n        }, {\n            key: \"rememberSelection\",\n            set: function set(rememberSelection) {\n                this.foundation_.setRememberSelection(rememberSelection);\n            }\n            /** @param {boolean} quickOpen */\n        }, {\n            key: \"quickOpen\",\n            set: function set(quickOpen) {\n                this.foundation_.setQuickOpen(quickOpen);\n            }\n        }], [{\n            key: \"attachTo\",\n            value: function attachTo(root) {\n                return new MDCMenu(root);\n            }\n        }]);\n    return MDCMenu;\n}(MDCComponent);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MdcMenuChange = /** @class */ /*@__PURE__*/ (function () {\n    function MdcMenuChange(index, source) {\n        this.index = index;\n        this.source = source;\n    }\n    return MdcMenuChange;\n}());\nvar /** @type {?} */ nextUniqueId = 0;\nvar /** @type {?} */ uniqueIdCounter = 0;\nvar MdcMenuAnchor = /** @class */ /*@__PURE__*/ (function () {\n    function MdcMenuAnchor(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n    }\n    return MdcMenuAnchor;\n}());\nvar MdcMenuDivider = /** @class */ /*@__PURE__*/ (function () {\n    function MdcMenuDivider(elementRef) {\n        this.elementRef = elementRef;\n    }\n    return MdcMenuDivider;\n}());\nvar MdcMenuItems = /** @class */ /*@__PURE__*/ (function () {\n    function MdcMenuItems(elementRef) {\n        this.elementRef = elementRef;\n        this.isHostClass = true;\n        this.isSelectClass = true;\n        this.role = 'menu';\n        this.ariaHidden = 'true';\n    }\n    return MdcMenuItems;\n}());\nvar MdcMenuItem = /** @class */ /*@__PURE__*/ (function () {\n    function MdcMenuItem(_renderer, elementRef) {\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this.id = \"mdc-menu-item-\" + uniqueIdCounter++;\n        this._disabled = false;\n        this.isHostClass = true;\n        this.role = 'menuitem';\n    }\n    Object.defineProperty(MdcMenuItem.prototype, \"disabled\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._disabled = toBoolean(value);\n            value ? this._renderer.setAttribute(this.elementRef.nativeElement, 'aria-disabled', 'true')\n                : this._renderer.removeAttribute(this.elementRef.nativeElement, 'aria-disabled');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Used to set the `tabindex`. */\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n    MdcMenuItem.prototype._getTabIndex = /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n        function () {\n            return this.disabled ? '-1' : '0';\n        };\n    return MdcMenuItem;\n}());\nvar MdcMenu = /** @class */ /*@__PURE__*/ (function () {\n    function MdcMenu(_changeDetectorRef, _renderer, elementRef, _registry) {\n        var _this = this;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._renderer = _renderer;\n        this.elementRef = elementRef;\n        this._registry = _registry;\n        this._uniqueId = \"mdc-menu-\" + ++nextUniqueId;\n        this.id = this._uniqueId;\n        this._anchorCorner = 'top-start';\n        this._rememberSelection = false;\n        this._quickOpen = false;\n        this.cancel = new EventEmitter();\n        this.select = new EventEmitter();\n        this.isHostClass = true;\n        this.tabindex = -1;\n        this._mdcAdapter = {\n            addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },\n            removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },\n            hasClass: function (className) { return _this._getHostElement().classList.contains(className); },\n            hasNecessaryDom: function () { return _this.menuContainer; },\n            getAttributeForEventTarget: function (target, attributeName) { return target.getAttribute(attributeName); },\n            getInnerDimensions: function () {\n                return {\n                    width: _this.menuContainer.elementRef.nativeElement.offsetWidth,\n                    height: _this.menuContainer.elementRef.nativeElement.offsetHeight\n                };\n            },\n            hasAnchor: function () { return _this.anchor; },\n            getAnchorDimensions: function () { return _this.anchor.elementRef.nativeElement.getBoundingClientRect(); },\n            getWindowDimensions: function () {\n                return {\n                    width: isBrowser() ? window.innerWidth : 0,\n                    height: isBrowser() ? window.innerHeight : 0\n                };\n            },\n            getNumberOfItems: function () { return _this.options ? _this.options.length : 0; },\n            registerInteractionHandler: function (type, handler) { return _this._registry.listen(type, handler, _this._getHostElement()); },\n            deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },\n            registerBodyClickHandler: function (handler) { return _this._registry.listen('click', handler, document.body); },\n            deregisterBodyClickHandler: function (handler) { return _this._registry.unlisten('click', handler); },\n            getIndexForEventTarget: function (target) { return _this.options.toArray().findIndex(function (_) { return _.elementRef.nativeElement === target; }); },\n            notifySelected: function (evtData) {\n                return _this.select.emit(new MdcMenuChange(evtData.index, _this.options.toArray()[evtData.index]));\n            },\n            notifyCancel: function () { return _this.cancel.emit(); },\n            saveFocus: function () {\n                if (isBrowser()) {\n                    _this._previousFocus = document.activeElement;\n                }\n            },\n            restoreFocus: function () {\n                if (_this._previousFocus) {\n                    _this._previousFocus.focus();\n                }\n            },\n            isFocused: function () { return document.activeElement === _this._getHostElement(); },\n            focus: function () { return _this._getHostElement().focus(); },\n            getFocusedItemIndex: function () { return _this.options.toArray().map(function (_) { return _.elementRef.nativeElement; }).indexOf(document.activeElement); },\n            focusItemAtIndex: function (index) { return _this.options.toArray()[index].elementRef.nativeElement.focus(); },\n            isRtl: function () { return getComputedStyle(_this._getHostElement()).getPropertyValue('direction') === 'rtl'; },\n            setTransformOrigin: function (origin) {\n                if (isBrowser()) {\n                    _this._renderer.setStyle(_this._getHostElement(), getTransformPropertyName(window) + \"-origin\", origin);\n                }\n            },\n            setPosition: function (position) {\n                position.left ? _this._setStyle('left', position.left) : _this._setStyle('left');\n                position.right ? _this._setStyle('right', position.right) : _this._setStyle('right');\n                position.top ? _this._setStyle('top', position.top) : _this._setStyle('top');\n                position.bottom ? _this._setStyle('bottom', position.bottom) : _this._setStyle('bottom');\n            },\n            setMaxHeight: function (height) { return _this._renderer.setStyle(_this._getHostElement(), 'maxHeight', height); },\n            setAttrForOptionAtIndex: function (index, attr, value) {\n                return _this._renderer.setAttribute(_this.options.toArray()[index].elementRef.nativeElement, attr, value);\n            },\n            rmAttrForOptionAtIndex: function (index, attr) {\n                return _this._renderer.removeAttribute(_this.options.toArray()[index].elementRef.nativeElement, attr);\n            },\n            addClassForOptionAtIndex: function (index, className) {\n                return _this._renderer.addClass(_this.options.toArray()[index].elementRef.nativeElement, className);\n            },\n            rmClassForOptionAtIndex: function (index, className) {\n                return _this._renderer.removeClass(_this.options.toArray()[index].elementRef.nativeElement, className);\n            },\n        };\n        this._foundation = new MDCMenuFoundation(this._mdcAdapter);\n    }\n    Object.defineProperty(MdcMenu.prototype, \"anchorCorner\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._anchorCorner; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setAnchorCorner(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcMenu.prototype, \"rememberSelection\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._rememberSelection; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setRememberSelection(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdcMenu.prototype, \"quickOpen\", {\n        get: /**\n         * @return {?}\n         */ function () { return this._quickOpen; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.setQuickOpen(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdcMenu.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            this._foundation.init();\n        };\n    /**\n     * @return {?}\n     */\n    MdcMenu.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._foundation.destroy();\n        };\n    /**\n     * @param {?} rememberSelection\n     * @return {?}\n     */\n    MdcMenu.prototype.setRememberSelection = /**\n     * @param {?} rememberSelection\n     * @return {?}\n     */\n        function (rememberSelection) {\n            this._rememberSelection = rememberSelection;\n            this._foundation.setRememberSelection(rememberSelection);\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MdcMenu.prototype.setSelectedIndex = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            this._foundation.setSelectedIndex(index);\n        };\n    /**\n     * @return {?}\n     */\n    MdcMenu.prototype.getSelectedIndex = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation.getSelectedIndex();\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdcMenu.prototype.setAnchorCorner = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this._anchorCorner = value;\n            if (this._foundation) {\n                var /** @type {?} */ corner = this._parseAnchorCorner(value);\n                this._foundation.setAnchorCorner(corner);\n            }\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} quickOpen\n     * @return {?}\n     */\n    MdcMenu.prototype.setQuickOpen = /**\n     * @param {?} quickOpen\n     * @return {?}\n     */\n        function (quickOpen) {\n            this._quickOpen = quickOpen;\n            this._foundation.setQuickOpen(quickOpen);\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * @param {?} height\n     * @return {?}\n     */\n    MdcMenu.prototype.setMaxHeight = /**\n     * @param {?} height\n     * @return {?}\n     */\n        function (height) {\n            this._mdcAdapter.setMaxHeight(height);\n        };\n    /**\n     * @return {?}\n     */\n    MdcMenu.prototype.isOpen = /**\n     * @return {?}\n     */\n        function () {\n            return this._foundation.isOpen();\n        };\n    /**\n     * @return {?}\n     */\n    MdcMenu.prototype.open = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.isOpen()) {\n                this._foundation.open();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdcMenu.prototype.toggle = /**\n     * @return {?}\n     */\n        function () {\n            this.isOpen() ? this.close() : this.open();\n        };\n    /**\n     * @return {?}\n     */\n    MdcMenu.prototype.close = /**\n     * @return {?}\n     */\n        function () {\n            this._foundation.close();\n        };\n    /**\n     * @return {?}\n     */\n    MdcMenu.prototype.focus = /**\n     * @return {?}\n     */\n        function () {\n            this._getHostElement().focus();\n        };\n    /**\n     * @param {?} anchorPoint\n     * @param {?=} position\n     * @return {?}\n     */\n    MdcMenu.prototype._setStyle = /**\n     * @param {?} anchorPoint\n     * @param {?=} position\n     * @return {?}\n     */\n        function (anchorPoint, position) {\n            position ? this._renderer.setStyle(this._getHostElement(), anchorPoint, position)\n                : this._renderer.removeStyle(this._getHostElement(), anchorPoint);\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdcMenu.prototype._parseAnchorCorner = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            switch (value) {\n                case 'top-end': {\n                    return Corner.TOP_END;\n                }\n                case 'bottom-start': {\n                    return Corner.BOTTOM_START;\n                }\n                case 'bottom-end': {\n                    return Corner.BOTTOM_END;\n                }\n                default: {\n                    return Corner.TOP_START;\n                }\n            }\n        };\n    /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n    MdcMenu.prototype._getHostElement = /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n        function () {\n            return this.elementRef.nativeElement;\n        };\n    return MdcMenu;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ MENU_DECLARATIONS = [\n    MdcMenu,\n    MdcMenuAnchor,\n    MdcMenuDivider,\n    MdcMenuItem,\n    MdcMenuItems,\n];\nvar MdcMenuModule = /** @class */ /*@__PURE__*/ (function () {\n    function MdcMenuModule() {\n    }\n    return MdcMenuModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MdcMenuModule, MdcMenuChange, MdcMenuAnchor, MdcMenuDivider, MdcMenuItems, MdcMenuItem, MdcMenu };\n",null]}