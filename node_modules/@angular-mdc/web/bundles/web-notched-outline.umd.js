/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/notchedOutline', ['exports', '@angular/core'], factory) :
  (factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.notchedOutline = {}),global.ng.core));
}(this, (function (exports,core) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Notched Outline.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Notched Outline into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCNotchedOutlineAdapter =
  /*#__PURE__*/
  function () {
    function MDCNotchedOutlineAdapter() {
      _classCallCheck(this, MDCNotchedOutlineAdapter);
    }

    _createClass(MDCNotchedOutlineAdapter, [{
      key: "getWidth",

      /**
       * Returns the width of the root element.
       * @return {number}
       */
      value: function getWidth() {}
      /**
       * Returns the height of the root element.
       * @return {number}
       */

    }, {
      key: "getHeight",
      value: function getHeight() {}
      /**
       * Adds a class to the root element.
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}
      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Sets the "d" attribute of the outline element's SVG path.
       * @param {string} value
       */

    }, {
      key: "setOutlinePathAttr",
      value: function setOutlinePathAttr(value) {}
      /**
       * Returns the idle outline element's computed style value of the given css property `propertyName`.
       * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getIdleOutlineStyleValue",
      value: function getIdleOutlineStyleValue(propertyName) {}
    }]);

    return MDCNotchedOutlineAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings = {
    PATH_SELECTOR: '.mdc-notched-outline__path',
    IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
  };
  /** @enum {string} */

  var cssClasses = {
    OUTLINE_NOTCHED: 'mdc-notched-outline--notched'
  };

  /**
   * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
   * @final
   */

  var MDCNotchedOutlineFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCNotchedOutlineFoundation, _MDCFoundation);

    _createClass(MDCNotchedOutlineFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses;
      }
      /**
       * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCNotchedOutlineAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCNotchedOutlineAdapter} */
          {
            getWidth: function getWidth() {},
            getHeight: function getHeight() {},
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            setOutlinePathAttr: function setOutlinePathAttr() {},
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
          }
        );
      }
      /**
       * @param {!MDCNotchedOutlineAdapter} adapter
       */

    }]);

    function MDCNotchedOutlineFoundation(adapter) {
      _classCallCheck(this, MDCNotchedOutlineFoundation);

      return _possibleConstructorReturn(this, (MDCNotchedOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCNotchedOutlineFoundation)).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
    }
    /**
     * Adds the outline notched selector and updates the notch width
     * calculated based off of notchWidth and isRtl.
     * @param {number} notchWidth
     * @param {boolean=} isRtl
     */


    _createClass(MDCNotchedOutlineFoundation, [{
      key: "notch",
      value: function notch(notchWidth) {
        var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
        this.adapter_.addClass(OUTLINE_NOTCHED);
        this.updateSvgPath_(notchWidth, isRtl);
      }
      /**
       * Removes notched outline selector to close the notch in the outline.
       */

    }, {
      key: "closeNotch",
      value: function closeNotch() {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
        this.adapter_.removeClass(OUTLINE_NOTCHED);
      }
      /**
       * Updates the SVG path of the focus outline element based on the notchWidth
       * and the RTL context.
       * @param {number} notchWidth
       * @param {boolean=} isRtl
       * @private
       */

    }, {
      key: "updateSvgPath_",
      value: function updateSvgPath_(notchWidth, isRtl) {
        // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
        var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
        var radius = parseFloat(radiusStyleValue);
        var width = this.adapter_.getWidth();
        var height = this.adapter_.getHeight();
        var cornerWidth = radius + 1.2;
        var leadingStrokeLength = Math.abs(11 - cornerWidth);
        var paddedNotchWidth = notchWidth + 8; // The right, bottom, and left sides of the outline follow the same SVG path.

        var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;
        var path;

        if (!isRtl) {
          path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
        } else {
          path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
        }

        this.adapter_.setOutlinePathAttr(path);
      }
    }]);

    return MDCNotchedOutlineFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}
   * @final
   */

  var MDCNotchedOutline =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCNotchedOutline, _MDCComponent);

    function MDCNotchedOutline() {
      _classCallCheck(this, MDCNotchedOutline);

      return _possibleConstructorReturn(this, (MDCNotchedOutline.__proto__ || Object.getPrototypeOf(MDCNotchedOutline)).apply(this, arguments));
    }

    _createClass(MDCNotchedOutline, [{
      key: "notch",

      /**
        * Updates outline selectors and SVG path to open notch.
        * @param {number} notchWidth The notch width in the outline.
        * @param {boolean=} isRtl Determines if outline is rtl. If rtl is true, notch
        * will be right justified in outline path, otherwise left justified.
        */
      value: function notch(notchWidth, isRtl) {
        this.foundation_.notch(notchWidth, isRtl);
      }
      /**
       * Updates the outline selectors to close notch and return it to idle state.
       */

    }, {
      key: "closeNotch",
      value: function closeNotch() {
        this.foundation_.closeNotch();
      }
      /**
       * @return {!MDCNotchedOutlineFoundation}
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCNotchedOutlineFoundation({
          getWidth: function getWidth() {
            return _this.root_.offsetWidth;
          },
          getHeight: function getHeight() {
            return _this.root_.offsetHeight;
          },
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          setOutlinePathAttr: function setOutlinePathAttr(value) {
            var path = _this.root_.querySelector(strings.PATH_SELECTOR);

            path.setAttribute('d', value);
          },
          getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
            var idleOutlineElement = _this.root_.parentNode.querySelector(strings.IDLE_OUTLINE_SELECTOR);

            return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
          }
        });
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCNotchedOutline}
       */
      value: function attachTo(root) {
        return new MDCNotchedOutline(root);
      }
    }]);

    return MDCNotchedOutline;
  }(MDCComponent);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var MdcNotchedOutlineIdle = /** @class */ (function () {
      function MdcNotchedOutlineIdle(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcNotchedOutlineIdle.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mdc-notched-outline-idle',
                  },] },
      ];
      /** @nocollapse */
      MdcNotchedOutlineIdle.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcNotchedOutlineIdle.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-notched-outline__idle',] }]
      };
      return MdcNotchedOutlineIdle;
  }());
  var MdcNotchedOutline = /** @class */ (function () {
      function MdcNotchedOutline(_changeDetectorRef, _renderer, elementRef) {
          var _this = this;
          this._changeDetectorRef = _changeDetectorRef;
          this._renderer = _renderer;
          this.elementRef = elementRef;
          this.isHostClass = true;
          this._mdcAdapter = {
              getWidth: function () { return _this.elementRef.nativeElement.offsetWidth; },
              getHeight: function () { return _this.elementRef.nativeElement.offsetHeight; },
              addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
              removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
              setOutlinePathAttr: function (value) { return _this._renderer.setAttribute(_this.svgpath.nativeElement, 'd', value); },
              getIdleOutlineStyleValue: function (propertyName) {
                  if (_this.outlineIdle) {
                      return window.getComputedStyle(_this.outlineIdle.elementRef.nativeElement).getPropertyValue(propertyName);
                  }
              }
          };
          this._foundation = new MDCNotchedOutlineFoundation(this._mdcAdapter);
      }
      Object.defineProperty(MdcNotchedOutline.prototype, "outlineIdle", {
          get: /**
           * @return {?}
           */
          function () { return this._outlineIdle; },
          set: /**
           * @param {?} outlineIdle
           * @return {?}
           */
          function (outlineIdle) {
              this._outlineIdle = outlineIdle;
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MdcNotchedOutline.prototype.ngOnInit = /**
       * @return {?}
       */
      function () {
          this._foundation.init();
      };
      /**
       * @return {?}
       */
      MdcNotchedOutline.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._foundation.destroy();
      };
      /**
       * Updates outline selectors and SVG path to open notch.
       */
      /**
       * Updates outline selectors and SVG path to open notch.
       * @param {?} notchWidth
       * @param {?} isRtl
       * @return {?}
       */
      MdcNotchedOutline.prototype.notch = /**
       * Updates outline selectors and SVG path to open notch.
       * @param {?} notchWidth
       * @param {?} isRtl
       * @return {?}
       */
      function (notchWidth, isRtl) {
          this._foundation.notch(notchWidth, isRtl);
      };
      /**
       * Updates the outline selectors to close notch and return it to idle state.
       */
      /**
       * Updates the outline selectors to close notch and return it to idle state.
       * @return {?}
       */
      MdcNotchedOutline.prototype.closeNotch = /**
       * Updates the outline selectors to close notch and return it to idle state.
       * @return {?}
       */
      function () {
          this._foundation.closeNotch();
      };
      /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      MdcNotchedOutline.prototype._getHostElement = /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      function () {
          return this.elementRef.nativeElement;
      };
      MdcNotchedOutline.decorators = [
          { type: core.Component, args: [{selector: '[mdc-notched-outline], mdc-notched-outline',
                      exportAs: 'mdcNotchedOutline',
                      template: "\n  <svg>\n    <path #svgpath class=\"mdc-notched-outline__path\"/>\n  </svg>\n  ",
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None
                  },] },
      ];
      /** @nocollapse */
      MdcNotchedOutline.ctorParameters = function () { return [
          { type: core.ChangeDetectorRef },
          { type: core.Renderer2 },
          { type: core.ElementRef }
      ]; };
      MdcNotchedOutline.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-notched-outline',] }],
          svgpath: [{ type: core.ViewChild, args: ['svgpath',] }]
      };
      return MdcNotchedOutline;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var MdcNotchedOutlineModule = /** @class */ (function () {
      function MdcNotchedOutlineModule() {
      }
      MdcNotchedOutlineModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: [MdcNotchedOutline, MdcNotchedOutlineIdle],
                      declarations: [MdcNotchedOutline, MdcNotchedOutlineIdle],
                  },] },
      ];
      return MdcNotchedOutlineModule;
  }());

  exports.MdcNotchedOutlineModule = MdcNotchedOutlineModule;
  exports.MdcNotchedOutlineIdle = MdcNotchedOutlineIdle;
  exports.MdcNotchedOutline = MdcNotchedOutline;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
