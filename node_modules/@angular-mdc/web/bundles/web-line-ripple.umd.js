/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular-mdc/web/common')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/lineRipple', ['exports', '@angular/core', '@angular-mdc/web/common'], factory) :
  (factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.lineRipple = {}),global.ng.core,global.ng.web.common));
}(this, (function (exports,core,common) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC TextField Line Ripple.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the line ripple into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCLineRippleAdapter =
  /*#__PURE__*/
  function () {
    function MDCLineRippleAdapter() {
      _classCallCheck(this, MDCLineRippleAdapter);
    }

    _createClass(MDCLineRippleAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the line ripple element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the line ripple element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Sets the style property with propertyName to value on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(propertyName, value) {}
      /**
       * Registers an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}
    }]);

    return MDCLineRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
  };

  /**
   * @extends {MDCFoundation<!MDCLineRippleAdapter>}
   * @final
   */

  var MDCLineRippleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCLineRippleFoundation, _MDCFoundation);

    _createClass(MDCLineRippleFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses;
      }
      /**
       * {@see MDCLineRippleAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCLineRippleAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCLineRippleAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setStyle: function setStyle() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {}
          }
        );
      }
      /**
       * @param {!MDCLineRippleAdapter=} adapter
       */

    }]);

    function MDCLineRippleFoundation() {
      var _this;

      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] :
      /** @type {!MDCLineRippleAdapter} */
      {};

      _classCallCheck(this, MDCLineRippleFoundation);

      _this = _possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));
      /** @private {function(!Event): undefined} */

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd(evt);
      };

      return _this;
    }

    _createClass(MDCLineRippleFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
      }
      /**
       * Activates the line ripple
       */

    }, {
      key: "activate",
      value: function activate() {
        this.adapter_.removeClass(cssClasses.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(cssClasses.LINE_RIPPLE_ACTIVE);
      }
      /**
       * Sets the center of the ripple animation to the given X coordinate.
       * @param {number} xCoordinate
       */

    }, {
      key: "setRippleCenter",
      value: function setRippleCenter(xCoordinate) {
        this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
      }
      /**
       * Deactivates the line ripple
       */

    }, {
      key: "deactivate",
      value: function deactivate() {
        this.adapter_.addClass(cssClasses.LINE_RIPPLE_DEACTIVATING);
      }
      /**
       * Handles a transition end event
       * @param {!Event} evt
       */

    }, {
      key: "handleTransitionEnd",
      value: function handleTransitionEnd(evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(cssClasses.LINE_RIPPLE_DEACTIVATING);

        if (evt.propertyName === 'opacity') {
          if (isDeactivating) {
            this.adapter_.removeClass(cssClasses.LINE_RIPPLE_ACTIVE);
            this.adapter_.removeClass(cssClasses.LINE_RIPPLE_DEACTIVATING);
          }
        }
      }
    }]);

    return MDCLineRippleFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCLineRippleFoundation>}
   * @final
   */

  var MDCLineRipple =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCLineRipple, _MDCComponent);

    function MDCLineRipple() {
      _classCallCheck(this, MDCLineRipple);

      return _possibleConstructorReturn(this, (MDCLineRipple.__proto__ || Object.getPrototypeOf(MDCLineRipple)).apply(this, arguments));
    }

    _createClass(MDCLineRipple, [{
      key: "activate",

      /**
       * Activates the line ripple
       */
      value: function activate() {
        this.foundation_.activate();
      }
      /**
       * Deactivates the line ripple
       */

    }, {
      key: "deactivate",
      value: function deactivate() {
        this.foundation_.deactivate();
      }
      /**
       * Sets the transform origin given a user's click location. The `rippleCenter` is the
       * x-coordinate of the middle of the ripple.
       * @param {number} xCoordinate
       */

    }, {
      key: "setRippleCenter",
      value: function setRippleCenter(xCoordinate) {
        this.foundation_.setRippleCenter(xCoordinate);
      }
      /**
       * @return {!MDCLineRippleFoundation}
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCLineRippleFoundation(
        /** @type {!MDCLineRippleAdapter} */
        Object.assign({
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this.root_.classList.contains(className);
          },
          setStyle: function setStyle(propertyName, value) {
            return _this.root_.style[propertyName] = value;
          },
          registerEventHandler: function registerEventHandler(evtType, handler) {
            return _this.root_.addEventListener(evtType, handler);
          },
          deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
            return _this.root_.removeEventListener(evtType, handler);
          }
        }));
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCLineRipple}
       */
      value: function attachTo(root) {
        return new MDCLineRipple(root);
      }
    }]);

    return MDCLineRipple;
  }(MDCComponent);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var MdcLineRipple = /** @class */ (function () {
      function MdcLineRipple(_renderer, elementRef, _registry) {
          var _this = this;
          this._renderer = _renderer;
          this.elementRef = elementRef;
          this._registry = _registry;
          this.isHostClass = true;
          this._mdcAdapter = {
              addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
              removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
              hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
              setStyle: function (propertyName, value) { return _this._renderer.setAttribute(_this._getHostElement(), propertyName, value); },
              registerEventHandler: function (evtType, handler) {
                  return _this._registry.listen(evtType, handler, _this._getHostElement());
              },
              deregisterEventHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },
          };
          this.foundation = new MDCLineRippleFoundation(this._mdcAdapter);
      }
      /**
       * @return {?}
       */
      MdcLineRipple.prototype.ngOnInit = /**
       * @return {?}
       */
      function () {
          this.foundation.init();
      };
      /**
       * @return {?}
       */
      MdcLineRipple.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this.foundation.destroy();
      };
      /**
       * @return {?}
       */
      MdcLineRipple.prototype.destroy = /**
       * @return {?}
       */
      function () {
          this.foundation.destroy();
      };
      /** Activates the line ripple */
      /**
       * Activates the line ripple
       * @return {?}
       */
      MdcLineRipple.prototype.activate = /**
       * Activates the line ripple
       * @return {?}
       */
      function () {
          this.foundation.activate();
      };
      /** Deactivates the line ripple */
      /**
       * Deactivates the line ripple
       * @return {?}
       */
      MdcLineRipple.prototype.deactivate = /**
       * Deactivates the line ripple
       * @return {?}
       */
      function () {
          this.foundation.deactivate();
      };
      /**
       * Sets the transform origin given a user's click location.
       * The `rippleCenter` is the x-coordinate of the middle of the ripple.
      */
      /**
       * Sets the transform origin given a user's click location.
       * The `rippleCenter` is the x-coordinate of the middle of the ripple.
       * @param {?} xCoordinate
       * @return {?}
       */
      MdcLineRipple.prototype.setRippleCenter = /**
       * Sets the transform origin given a user's click location.
       * The `rippleCenter` is the x-coordinate of the middle of the ripple.
       * @param {?} xCoordinate
       * @return {?}
       */
      function (xCoordinate) {
          this.foundation.setRippleCenter(xCoordinate);
      };
      /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      MdcLineRipple.prototype._getHostElement = /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      function () {
          return this.elementRef.nativeElement;
      };
      MdcLineRipple.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-line-ripple], mdc-line-ripple',
                      providers: [
                          common.EventRegistry,
                      ],
                  },] },
      ];
      /** @nocollapse */
      MdcLineRipple.ctorParameters = function () { return [
          { type: core.Renderer2 },
          { type: core.ElementRef },
          { type: common.EventRegistry }
      ]; };
      MdcLineRipple.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-line-ripple',] }]
      };
      return MdcLineRipple;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var MdcLineRippleModule = /** @class */ (function () {
      function MdcLineRippleModule() {
      }
      MdcLineRippleModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: [MdcLineRipple],
                      declarations: [MdcLineRipple],
                  },] },
      ];
      return MdcLineRippleModule;
  }());

  exports.MdcLineRippleModule = MdcLineRippleModule;
  exports.MdcLineRipple = MdcLineRipple;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
