/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@angular-mdc/web/common'), require('@angular/common')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/slider', ['exports', '@angular/core', '@angular/forms', '@angular-mdc/web/common', '@angular/common'], factory) :
  (factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.slider = {}),global.ng.core,global.ng.forms,global.ng.web.common,global.ng.common));
}(this, (function (exports,core,forms,common,common$1) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses = {
    ACTIVE: 'mdc-slider--active',
    DISABLED: 'mdc-slider--disabled',
    DISCRETE: 'mdc-slider--discrete',
    FOCUS: 'mdc-slider--focus',
    IN_TRANSIT: 'mdc-slider--in-transit',
    IS_DISCRETE: 'mdc-slider--discrete',
    HAS_TRACK_MARKER: 'mdc-slider--display-markers'
  };
  /** @enum {string} */

  var strings = {
    TRACK_SELECTOR: '.mdc-slider__track',
    TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
    LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
    THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
    PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
    ARIA_VALUEMIN: 'aria-valuemin',
    ARIA_VALUEMAX: 'aria-valuemax',
    ARIA_VALUENOW: 'aria-valuenow',
    ARIA_DISABLED: 'aria-disabled',
    STEP_DATA_ATTR: 'data-step',
    CHANGE_EVENT: 'MDCSlider:change',
    INPUT_EVENT: 'MDCSlider:input'
  };
  /** @enum {number} */

  var numbers = {
    PAGE_FACTOR: 4
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint-disable no-unused-vars */

  /**
   * Adapter for MDC Slider.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Slider into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSliderAdapter =
  /*#__PURE__*/
  function () {
    function MDCSliderAdapter() {
      _classCallCheck(this, MDCSliderAdapter);
    }

    _createClass(MDCSliderAdapter, [{
      key: "hasClass",

      /**
       * Returns true if className exists for the slider Element
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}
      /**
       * Adds a class to the slider Element
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}
      /**
       * Removes a class from the slider Element
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns a string if attribute name exists on the slider Element,
       * otherwise returns null
       * @param {string} name
       * @return {?string}
       */

    }, {
      key: "getAttribute",
      value: function getAttribute(name) {}
      /**
       * Sets attribute name on slider Element to value
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttribute",
      value: function setAttribute(name, value) {}
      /**
       * Removes attribute name from slider Element
       * @param {string} name
       */

    }, {
      key: "removeAttribute",
      value: function removeAttribute(name) {}
      /**
       * Returns the bounding client rect for the slider Element
       * @return {?ClientRect}
       */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}
      /**
       * Returns the tab index of the slider Element
       * @return {number}
       */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}
      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}
      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}
      /**
       * Registers an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerThumbContainerInteractionHandler",
      value: function registerThumbContainerInteractionHandler(type, handler) {}
      /**
       * Deregisters an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterThumbContainerInteractionHandler",
      value: function deregisterThumbContainerInteractionHandler(type, handler) {}
      /**
       * Registers an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerBodyInteractionHandler",
      value: function registerBodyInteractionHandler(type, handler) {}
      /**
       * Deregisters an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterBodyInteractionHandler",
      value: function deregisterBodyInteractionHandler(type, handler) {}
      /**
       * Registers an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}
      /**
       * Deregisters an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}
      /**
       * Emits a custom event MDCSlider:input from the root
       */

    }, {
      key: "notifyInput",
      value: function notifyInput() {}
      /**
       * Emits a custom event MDCSlider:change from the root
       */

    }, {
      key: "notifyChange",
      value: function notifyChange() {}
      /**
       * Sets a style property of the thumb container element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setThumbContainerStyleProperty",
      value: function setThumbContainerStyleProperty(propertyName, value) {}
      /**
       * Sets a style property of the track element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setTrackStyleProperty",
      value: function setTrackStyleProperty(propertyName, value) {}
      /**
       * Sets the inner text of the pin marker to the passed value
       * @param {number} value
       */

    }, {
      key: "setMarkerValue",
      value: function setMarkerValue(value) {}
      /**
       * Appends the passed number of track markers to the track mark container element
       * @param {number} numMarkers
       */

    }, {
      key: "appendTrackMarkers",
      value: function appendTrackMarkers(numMarkers) {}
      /**
       * Removes all track markers fromt he track mark container element
       */

    }, {
      key: "removeTrackMarkers",
      value: function removeTrackMarkers() {}
      /**
       * Sets a style property of the last track marker to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setLastTrackMarkersStyleProperty",
      value: function setLastTrackMarkersStyleProperty(propertyName, value) {}
      /**
       * Returns true if the root element is RTL, otherwise false
       * @return {boolean}
       */

    }, {
      key: "isRTL",
      value: function isRTL() {}
    }]);

    return MDCSliderAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /** @const {Object<string, !VendorPropertyMapType>} */

  var eventTypeMap = {
    'animationstart': {
      noPrefix: 'animationstart',
      webkitPrefix: 'webkitAnimationStart',
      styleProperty: 'animation'
    },
    'animationend': {
      noPrefix: 'animationend',
      webkitPrefix: 'webkitAnimationEnd',
      styleProperty: 'animation'
    },
    'animationiteration': {
      noPrefix: 'animationiteration',
      webkitPrefix: 'webkitAnimationIteration',
      styleProperty: 'animation'
    },
    'transitionend': {
      noPrefix: 'transitionend',
      webkitPrefix: 'webkitTransitionEnd',
      styleProperty: 'transition'
    }
  };
  /** @const {Object<string, !VendorPropertyMapType>} */

  var cssPropertyMap = {
    'animation': {
      noPrefix: 'animation',
      webkitPrefix: '-webkit-animation'
    },
    'transform': {
      noPrefix: 'transform',
      webkitPrefix: '-webkit-transform'
    },
    'transition': {
      noPrefix: 'transition',
      webkitPrefix: '-webkit-transition'
    }
  };
  /**
   * @param {!Object} windowObj
   * @return {boolean}
   */

  function hasProperShape(windowObj) {
    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
  }
  /**
   * @param {string} eventType
   * @return {boolean}
   */


  function eventFoundInMaps(eventType) {
    return eventType in eventTypeMap || eventType in cssPropertyMap;
  }
  /**
   * @param {string} eventType
   * @param {!Object<string, !VendorPropertyMapType>} map
   * @param {!Element} el
   * @return {string}
   */


  function getJavaScriptEventName(eventType, map, el) {
    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }
  /**
   * Helper function to determine browser prefix for CSS3 animation events
   * and property names.
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */


  function getAnimationName(windowObj, eventType) {
    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
      return eventType;
    }

    var map =
    /** @type {!Object<string, !VendorPropertyMapType>} */
    eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
    var el = windowObj['document']['createElement']('div');
    var eventName = '';

    if (map === eventTypeMap) {
      eventName = getJavaScriptEventName(eventType, map, el);
    } else {
      eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }

    return eventName;
  } // Public functions to access getAnimationName() for JavaScript events or CSS
  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */

  function getCorrectEventName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }
  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */


  function getCorrectPropertyName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  /** @enum {string} */

  var KEY_IDS = {
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    ARROW_DOWN: 'ArrowDown',
    HOME: 'Home',
    END: 'End',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown'
  };
  /** @enum {string} */

  var MOVE_EVENT_MAP = {
    'mousedown': 'mousemove',
    'touchstart': 'touchmove',
    'pointerdown': 'pointermove'
  };
  var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
  var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];
  /**
   * @extends {MDCFoundation<!MDCSliderAdapter>}
   */

  var MDCSliderFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSliderFoundation, _MDCFoundation);

    _createClass(MDCSliderFoundation, null, [{
      key: "cssClasses",

      /** @return enum {cssClasses} */
      get: function get() {
        return cssClasses;
      }
      /** @return enum {strings} */

    }, {
      key: "strings",
      get: function get() {
        return strings;
      }
      /** @return enum {numbers} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers;
      }
      /** @return {!MDCSliderAdapter} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSliderAdapter} */
          {
            hasClass: function hasClass() {
              return (
                /* className: string */

                /* boolean */
                false
              );
            },
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            getAttribute: function getAttribute() {
              return (
                /* name: string */

                /* string|null */
                null
              );
            },
            setAttribute: function setAttribute()
            /* name: string, value: string */
            {},
            removeAttribute: function removeAttribute()
            /* name: string */
            {},
            computeBoundingRect: function computeBoundingRect() {
              return (
                /* ClientRect */
                {
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0,
                  width: 0,
                  height: 0
                }
              );
            },
            getTabIndex: function getTabIndex() {
              return (
                /* number */
                0
              );
            },
            registerInteractionHandler: function registerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            registerBodyInteractionHandler: function registerBodyInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            notifyInput: function notifyInput() {},
            notifyChange: function notifyChange() {},
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty()
            /* propertyName: string, value: string */
            {},
            setTrackStyleProperty: function setTrackStyleProperty()
            /* propertyName: string, value: string */
            {},
            setMarkerValue: function setMarkerValue()
            /* value: number */
            {},
            appendTrackMarkers: function appendTrackMarkers()
            /* numMarkers: number */
            {},
            removeTrackMarkers: function removeTrackMarkers() {},
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty()
            /* propertyName: string, value: string */
            {},
            isRTL: function isRTL() {
              return (
                /* boolean */
                false
              );
            }
          }
        );
      }
      /**
       * Creates a new instance of MDCSliderFoundation
       * @param {?MDCSliderAdapter} adapter
       */

    }]);

    function MDCSliderFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCSliderFoundation);

      _this = _possibleConstructorReturn(this, (MDCSliderFoundation.__proto__ || Object.getPrototypeOf(MDCSliderFoundation)).call(this, Object.assign(MDCSliderFoundation.defaultAdapter, adapter)));
      /** @private {?ClientRect} */

      _this.rect_ = null; // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
      // because those could be valid tabindices set by the client code.

      _this.savedTabIndex_ = NaN;
      _this.active_ = false;
      _this.inTransit_ = false;
      _this.isDiscrete_ = false;
      _this.hasTrackMarker_ = false;
      _this.handlingThumbTargetEvt_ = false;
      _this.min_ = 0;
      _this.max_ = 100;
      _this.step_ = 0;
      _this.value_ = 0;
      _this.disabled_ = false;
      _this.preventFocusState_ = false;
      _this.updateUIFrame_ = 0;

      _this.thumbContainerPointerHandler_ = function () {
        _this.handlingThumbTargetEvt_ = true;
      };

      _this.interactionStartHandler_ = function (evt) {
        return _this.handleDown_(evt);
      };

      _this.keydownHandler_ = function (evt) {
        return _this.handleKeydown_(evt);
      };

      _this.focusHandler_ = function () {
        return _this.handleFocus_();
      };

      _this.blurHandler_ = function () {
        return _this.handleBlur_();
      };

      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      return _this;
    }

    _createClass(MDCSliderFoundation, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        this.isDiscrete_ = this.adapter_.hasClass(cssClasses.IS_DISCRETE);
        this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses.HAS_TRACK_MARKER);
        DOWN_EVENTS.forEach(function (evtName) {
          return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
        });
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
        });
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.layout(); // At last step, provide a reasonable default value to discrete slider

        if (this.isDiscrete_ && this.getStep() == 0) {
          this.step_ = 1;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
        });
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
        });
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: "setupTrackMarker",
      value: function setupTrackMarker() {
        if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
          var min = this.getMin();
          var max = this.getMax();
          var step = this.getStep();
          var numMarkers = (max - min) / step; // In case distance between max & min is indivisible to step,
          // we place the secondary to last marker proportionally at where thumb
          // could reach and place the last marker at max value

          var indivisible = Math.ceil(numMarkers) !== numMarkers;

          if (indivisible) {
            numMarkers = Math.ceil(numMarkers);
          }

          this.adapter_.removeTrackMarkers();
          this.adapter_.appendTrackMarkers(numMarkers);

          if (indivisible) {
            var lastStepRatio = (max - numMarkers * step) / step + 1;
            var flex = getCorrectPropertyName(window, 'flex');
            this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
          }
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        this.rect_ = this.adapter_.computeBoundingRect();
        this.updateUIForCurrentValue_();
      }
      /** @return {number} */

    }, {
      key: "getValue",
      value: function getValue() {
        return this.value_;
      }
      /** @param {number} value */

    }, {
      key: "setValue",
      value: function setValue(value) {
        this.setValue_(value, false);
      }
      /** @return {number} */

    }, {
      key: "getMax",
      value: function getMax() {
        return this.max_;
      }
      /** @param {number} max */

    }, {
      key: "setMax",
      value: function setMax(max) {
        if (max < this.min_) {
          throw new Error('Cannot set max to be less than the slider\'s minimum value');
        }

        this.max_ = max;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings.ARIA_VALUEMAX, String(this.max_));
        this.setupTrackMarker();
      }
      /** @return {number} */

    }, {
      key: "getMin",
      value: function getMin() {
        return this.min_;
      }
      /** @param {number} min */

    }, {
      key: "setMin",
      value: function setMin(min) {
        if (min > this.max_) {
          throw new Error('Cannot set min to be greater than the slider\'s maximum value');
        }

        this.min_ = min;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings.ARIA_VALUEMIN, String(this.min_));
        this.setupTrackMarker();
      }
      /** @return {number} */

    }, {
      key: "getStep",
      value: function getStep() {
        return this.step_;
      }
      /** @param {number} step */

    }, {
      key: "setStep",
      value: function setStep(step) {
        if (step < 0) {
          throw new Error('Step cannot be set to a negative number');
        }

        if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
          step = 1;
        }

        this.step_ = step;
        this.setValue_(this.value_, false, true);
        this.setupTrackMarker();
      }
      /** @return {boolean} */

    }, {
      key: "isDisabled",
      value: function isDisabled() {
        return this.disabled_;
      }
      /** @param {boolean} disabled */

    }, {
      key: "setDisabled",
      value: function setDisabled(disabled) {
        this.disabled_ = disabled;
        this.toggleClass_(cssClasses.DISABLED, this.disabled_);

        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setAttribute(strings.ARIA_DISABLED, 'true');
          this.adapter_.removeAttribute('tabindex');
        } else {
          this.adapter_.removeAttribute(strings.ARIA_DISABLED);

          if (!isNaN(this.savedTabIndex_)) {
            this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
          }
        }
      }
      /**
       * Called when the user starts interacting with the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "handleDown_",
      value: function handleDown_(evt) {
        var _this4 = this;

        if (this.disabled_) {
          return;
        }

        this.preventFocusState_ = true;
        this.setInTransit_(!this.handlingThumbTargetEvt_);
        this.handlingThumbTargetEvt_ = false;
        this.setActive_(true);

        var moveHandler = function moveHandler(evt) {
          _this4.handleMove_(evt);
        }; // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
        // do not always fire these consistently in pairs.
        // (See https://github.com/material-components/material-components-web/issues/1192)


        var upHandler = function upHandler() {
          _this4.handleUp_();

          _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);

          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
          });
        };

        this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
        });
        this.setValueFromEvt_(evt);
      }
      /**
       * Called when the user moves the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "handleMove_",
      value: function handleMove_(evt) {
        evt.preventDefault();
        this.setValueFromEvt_(evt);
      }
      /**
       * Called when the user's interaction with the slider ends
       * @private
       */

    }, {
      key: "handleUp_",
      value: function handleUp_() {
        this.setActive_(false);
        this.adapter_.notifyChange();
      }
      /**
       * Returns the pageX of the event
       * @param {!Event} evt
       * @return {number}
       * @private
       */

    }, {
      key: "getPageX_",
      value: function getPageX_(evt) {
        if (evt.targetTouches && evt.targetTouches.length > 0) {
          return evt.targetTouches[0].pageX;
        }

        return evt.pageX;
      }
      /**
       * Sets the slider value from an event
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "setValueFromEvt_",
      value: function setValueFromEvt_(evt) {
        var pageX = this.getPageX_(evt);
        var value = this.computeValueFromPageX_(pageX);
        this.setValue_(value, true);
      }
      /**
       * Computes the new value from the pageX position
       * @param {number} pageX
       * @return {number}
       */

    }, {
      key: "computeValueFromPageX_",
      value: function computeValueFromPageX_(pageX) {
        var max = this.max_,
            min = this.min_;
        var xPos = pageX - this.rect_.left;
        var pctComplete = xPos / this.rect_.width;

        if (this.adapter_.isRTL()) {
          pctComplete = 1 - pctComplete;
        } // Fit the percentage complete between the range [min,max]
        // by remapping from [0, 1] to [min, min+(max-min)].


        return min + pctComplete * (max - min);
      }
      /**
       * Handles keydown events
       * @param {!Event} evt
       */

    }, {
      key: "handleKeydown_",
      value: function handleKeydown_(evt) {
        var keyId = this.getKeyId_(evt);
        var value = this.getValueForKeyId_(keyId);

        if (isNaN(value)) {
          return;
        } // Prevent page from scrolling due to key presses that would normally scroll the page


        evt.preventDefault();
        this.adapter_.addClass(cssClasses.FOCUS);
        this.setValue_(value, true);
        this.adapter_.notifyChange();
      }
      /**
       * Returns the computed name of the event
       * @param {!Event} kbdEvt
       * @return {string}
       */

    }, {
      key: "getKeyId_",
      value: function getKeyId_(kbdEvt) {
        if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
          return KEY_IDS.ARROW_LEFT;
        }

        if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
          return KEY_IDS.ARROW_RIGHT;
        }

        if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
          return KEY_IDS.ARROW_UP;
        }

        if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
          return KEY_IDS.ARROW_DOWN;
        }

        if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
          return KEY_IDS.HOME;
        }

        if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
          return KEY_IDS.END;
        }

        if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
          return KEY_IDS.PAGE_UP;
        }

        if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
          return KEY_IDS.PAGE_DOWN;
        }

        return '';
      }
      /**
       * Computes the value given a keyboard key ID
       * @param {string} keyId
       * @return {number}
       */

    }, {
      key: "getValueForKeyId_",
      value: function getValueForKeyId_(keyId) {
        var max = this.max_,
            min = this.min_,
            step = this.step_;
        var delta = step || (max - min) / 100;
        var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);

        if (valueNeedsToBeFlipped) {
          delta = -delta;
        }

        switch (keyId) {
          case KEY_IDS.ARROW_LEFT:
          case KEY_IDS.ARROW_DOWN:
            return this.value_ - delta;

          case KEY_IDS.ARROW_RIGHT:
          case KEY_IDS.ARROW_UP:
            return this.value_ + delta;

          case KEY_IDS.HOME:
            return this.min_;

          case KEY_IDS.END:
            return this.max_;

          case KEY_IDS.PAGE_UP:
            return this.value_ + delta * numbers.PAGE_FACTOR;

          case KEY_IDS.PAGE_DOWN:
            return this.value_ - delta * numbers.PAGE_FACTOR;

          default:
            return NaN;
        }
      }
    }, {
      key: "handleFocus_",
      value: function handleFocus_() {
        if (this.preventFocusState_) {
          return;
        }

        this.adapter_.addClass(cssClasses.FOCUS);
      }
    }, {
      key: "handleBlur_",
      value: function handleBlur_() {
        this.preventFocusState_ = false;
        this.adapter_.removeClass(cssClasses.FOCUS);
      }
      /**
       * Sets the value of the slider
       * @param {number} value
       * @param {boolean} shouldFireInput
       * @param {boolean=} force
       */

    }, {
      key: "setValue_",
      value: function setValue_(value, shouldFireInput) {
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (value === this.value_ && !force) {
          return;
        }

        var min = this.min_,
            max = this.max_;
        var valueSetToBoundary = value === min || value === max;

        if (this.step_ && !valueSetToBoundary) {
          value = this.quantize_(value);
        }

        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        }

        this.value_ = value;
        this.adapter_.setAttribute(strings.ARIA_VALUENOW, String(this.value_));
        this.updateUIForCurrentValue_();

        if (shouldFireInput) {
          this.adapter_.notifyInput();

          if (this.isDiscrete_) {
            this.adapter_.setMarkerValue(value);
          }
        }
      }
      /**
       * Calculates the quantized value
       * @param {number} value
       * @return {number}
       */

    }, {
      key: "quantize_",
      value: function quantize_(value) {
        var numSteps = Math.round(value / this.step_);
        var quantizedVal = numSteps * this.step_;
        return quantizedVal;
      }
    }, {
      key: "updateUIForCurrentValue_",
      value: function updateUIForCurrentValue_() {
        var _this5 = this;

        var max = this.max_,
            min = this.min_,
            value = this.value_;
        var pctComplete = (value - min) / (max - min);
        var translatePx = pctComplete * this.rect_.width;

        if (this.adapter_.isRTL()) {
          translatePx = this.rect_.width - translatePx;
        }

        var transformProp = getCorrectPropertyName(window, 'transform');
        var transitionendEvtName = getCorrectEventName(window, 'transitionend');

        if (this.inTransit_) {
          var onTransitionEnd = function onTransitionEnd() {
            _this5.setInTransit_(false);

            _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          };

          this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        }

        this.updateUIFrame_ = requestAnimationFrame(function () {
          // NOTE(traviskaufman): It would be nice to use calc() here,
          // but IE cannot handle calcs in transforms correctly.
          // See: https://goo.gl/NC2itk
          // Also note that the -50% offset is used to center the slider thumb.
          _this5.adapter_.setThumbContainerStyleProperty(transformProp, "translateX(".concat(translatePx, "px) translateX(-50%)"));

          _this5.adapter_.setTrackStyleProperty(transformProp, "scaleX(".concat(pctComplete, ")"));
        });
      }
      /**
       * Toggles the active state of the slider
       * @param {boolean} active
       */

    }, {
      key: "setActive_",
      value: function setActive_(active) {
        this.active_ = active;
        this.toggleClass_(cssClasses.ACTIVE, this.active_);
      }
      /**
       * Toggles the inTransit state of the slider
       * @param {boolean} inTransit
       */

    }, {
      key: "setInTransit_",
      value: function setInTransit_(inTransit) {
        this.inTransit_ = inTransit;
        this.toggleClass_(cssClasses.IN_TRANSIT, this.inTransit_);
      }
      /**
       * Conditionally adds or removes a class based on shouldBePresent
       * @param {string} className
       * @param {boolean} shouldBePresent
       */

    }, {
      key: "toggleClass_",
      value: function toggleClass_(className, shouldBePresent) {
        if (shouldBePresent) {
          this.adapter_.addClass(className);
        } else {
          this.adapter_.removeClass(className);
        }
      }
    }]);

    return MDCSliderFoundation;
  }(MDCFoundation);

  /**
   * @extends MDCComponent<!MDCSliderFoundation>
   */

  var MDCSlider =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCSlider, _MDCComponent);

    _createClass(MDCSlider, null, [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCSlider(root);
      }
    }]);

    function MDCSlider() {
      var _ref;

      var _this;

      _classCallCheck(this, MDCSlider);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_ref = MDCSlider.__proto__ || Object.getPrototypeOf(MDCSlider)).call.apply(_ref, [this].concat(args)));
      /** @type {?Element} */

      _this.thumbContainer_;
      /** @type {?Element} */

      _this.track_;
      /** @type {?Element} */

      _this.pinValueMarker_;
      /** @type {?Element} */

      _this.trackMarkerContainer_;
      return _this;
    }
    /** @return {number} */


    _createClass(MDCSlider, [{
      key: "initialize",
      value: function initialize() {
        this.thumbContainer_ = this.root_.querySelector(strings.THUMB_CONTAINER_SELECTOR);
        this.track_ = this.root_.querySelector(strings.TRACK_SELECTOR);
        this.pinValueMarker_ = this.root_.querySelector(strings.PIN_VALUE_MARKER_SELECTOR);
        this.trackMarkerContainer_ = this.root_.querySelector(strings.TRACK_MARKER_CONTAINER_SELECTOR);
      }
      /**
       * @return {!MDCSliderFoundation}
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this2 = this;

        return new MDCSliderFoundation(
        /** @type {!MDCSliderAdapter} */
        {
          hasClass: function hasClass(className) {
            return _this2.root_.classList.contains(className);
          },
          addClass: function addClass(className) {
            return _this2.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this2.root_.classList.remove(className);
          },
          getAttribute: function getAttribute(name) {
            return _this2.root_.getAttribute(name);
          },
          setAttribute: function setAttribute(name, value) {
            return _this2.root_.setAttribute(name, value);
          },
          removeAttribute: function removeAttribute(name) {
            return _this2.root_.removeAttribute(name);
          },
          computeBoundingRect: function computeBoundingRect() {
            return _this2.root_.getBoundingClientRect();
          },
          getTabIndex: function getTabIndex() {
            return _this2.root_.tabIndex;
          },
          registerInteractionHandler: function registerInteractionHandler(type, handler) {
            _this2.root_.addEventListener(type, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
            _this2.root_.removeEventListener(type, handler);
          },
          registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
            _this2.thumbContainer_.addEventListener(type, handler);
          },
          deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
            _this2.thumbContainer_.removeEventListener(type, handler);
          },
          registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
            document.body.addEventListener(type, handler);
          },
          deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
            document.body.removeEventListener(type, handler);
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            window.removeEventListener('resize', handler);
          },
          notifyInput: function notifyInput() {
            _this2.emit(strings.INPUT_EVENT, _this2);
          },
          notifyChange: function notifyChange() {
            _this2.emit(strings.CHANGE_EVENT, _this2);
          },
          setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
            _this2.thumbContainer_.style.setProperty(propertyName, value);
          },
          setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
            _this2.track_.style.setProperty(propertyName, value);
          },
          setMarkerValue: function setMarkerValue(value) {
            _this2.pinValueMarker_.innerText = value;
          },
          appendTrackMarkers: function appendTrackMarkers(numMarkers) {
            var frag = document.createDocumentFragment();

            for (var i = 0; i < numMarkers; i++) {
              var marker = document.createElement('div');
              marker.classList.add('mdc-slider__track-marker');
              frag.appendChild(marker);
            }

            _this2.trackMarkerContainer_.appendChild(frag);
          },
          removeTrackMarkers: function removeTrackMarkers() {
            while (_this2.trackMarkerContainer_.firstChild) {
              _this2.trackMarkerContainer_.removeChild(_this2.trackMarkerContainer_.firstChild);
            }
          },
          setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
            // We remove and append new nodes, thus, the last track marker must be dynamically found.
            var lastTrackMarker = _this2.root_.querySelector(strings.LAST_TRACK_MARKER_SELECTOR);

            lastTrackMarker.style.setProperty(propertyName, value);
          },
          isRTL: function isRTL() {
            return getComputedStyle(_this2.root_).direction === 'rtl';
          }
        });
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        var origValueNow = parseFloat(this.root_.getAttribute(strings.ARIA_VALUENOW));
        this.min = parseFloat(this.root_.getAttribute(strings.ARIA_VALUEMIN)) || this.min;
        this.max = parseFloat(this.root_.getAttribute(strings.ARIA_VALUEMAX)) || this.max;
        this.step = parseFloat(this.root_.getAttribute(strings.STEP_DATA_ATTR)) || this.step;
        this.value = origValueNow || this.value;
        this.disabled = this.root_.hasAttribute(strings.ARIA_DISABLED) && this.root_.getAttribute(strings.ARIA_DISABLED) !== 'false';
        this.foundation_.setupTrackMarker();
      }
    }, {
      key: "layout",
      value: function layout() {
        this.foundation_.layout();
      }
      /** @param {number=} amount */

    }, {
      key: "stepUp",
      value: function stepUp() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.step || 1;
        this.value += amount;
      }
      /** @param {number=} amount */

    }, {
      key: "stepDown",
      value: function stepDown() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.step || 1;
        this.value -= amount;
      }
    }, {
      key: "value",
      get: function get() {
        return this.foundation_.getValue();
      }
      /** @param {number} value */
      ,
      set: function set(value) {
        this.foundation_.setValue(value);
      }
      /** @return {number} */

    }, {
      key: "min",
      get: function get() {
        return this.foundation_.getMin();
      }
      /** @param {number} min */
      ,
      set: function set(min) {
        this.foundation_.setMin(min);
      }
      /** @return {number} */

    }, {
      key: "max",
      get: function get() {
        return this.foundation_.getMax();
      }
      /** @param {number} max */
      ,
      set: function set(max) {
        this.foundation_.setMax(max);
      }
      /** @return {number} */

    }, {
      key: "step",
      get: function get() {
        return this.foundation_.getStep();
      }
      /** @param {number} step */
      ,
      set: function set(step) {
        this.foundation_.setStep(step);
      }
      /** @return {boolean} */

    }, {
      key: "disabled",
      get: function get() {
        return this.foundation_.isDisabled();
      }
      /** @param {boolean} disabled */
      ,
      set: function set(disabled) {
        this.foundation_.setDisabled(disabled);
      }
    }]);

    return MDCSlider;
  }(MDCComponent);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var /** @type {?} */ MDC_SLIDER_CONTROL_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MdcSlider; }),
      multi: true
  };
  var MdcSliderChange = /** @class */ (function () {
      function MdcSliderChange(source, value) {
          this.source = source;
          this.value = value;
      }
      return MdcSliderChange;
  }());
  var MdcSlider = /** @class */ (function () {
      function MdcSlider(_changeDetectorRef, _renderer, elementRef, _registry) {
          var _this = this;
          this._changeDetectorRef = _changeDetectorRef;
          this._renderer = _renderer;
          this.elementRef = elementRef;
          this._registry = _registry;
          this.tabIndex = 0;
          this.name = null;
          this._discrete = false;
          this._markers = false;
          this._min = 0;
          this._max = 100;
          this._step = 0;
          this._value = 0;
          this._disabled = false;
          this.change = new core.EventEmitter();
          this.input = new core.EventEmitter();
          this.isHostClass = true;
          this.role = 'slider';
          /**
           * View -> model callback called when value changes
           */
          this._onChange = function () { };
          /**
           * View -> model callback called when radio has been touched
           */
          this._onTouched = function () { };
          this._mdcAdapter = {
              hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
              addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
              removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
              getAttribute: function (name) { return _this._getHostElement().getAttribute(name); },
              setAttribute: function (name, value) { return _this._renderer.setAttribute(_this._getHostElement(), name, value); },
              removeAttribute: function (name) { return _this._renderer.removeAttribute(_this._getHostElement(), name); },
              computeBoundingRect: function () { return _this._getHostElement().getBoundingClientRect(); },
              getTabIndex: function () { return _this._getHostElement().tabIndex; },
              registerInteractionHandler: function (type, handler) {
                  return _this._registry.listen(type, handler, _this._getHostElement());
              },
              deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
              registerThumbContainerInteractionHandler: function (type, handler) {
                  if (_this.thumbContainer) {
                      _this._registry.listen(type, handler, _this.thumbContainer.nativeElement);
                  }
              },
              deregisterThumbContainerInteractionHandler: function (type, handler) {
                  return _this._registry.unlisten(type, handler);
              },
              registerBodyInteractionHandler: function (type, handler) {
                  if (common.isBrowser()) {
                      _this._registry.listen(type, handler, document.body);
                  }
              },
              deregisterBodyInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
              registerResizeHandler: function (handler) {
                  if (common.isBrowser()) {
                      _this._registry.listen('resize', handler, window);
                  }
              },
              deregisterResizeHandler: function (handler) { return _this._registry.unlisten('resize', handler); },
              notifyInput: function () {
                  _this.input.emit(new MdcSliderChange(_this, _this.getValue()));
                  _this._onTouched();
              },
              notifyChange: function () {
                  _this.change.emit(new MdcSliderChange(_this, _this.getValue()));
                  _this.setValue(_this.getValue());
              },
              setThumbContainerStyleProperty: function (propertyName, value) {
                  return _this._renderer.setStyle(_this.thumbContainer.nativeElement, propertyName, value);
              },
              setTrackStyleProperty: function (propertyName, value) {
                  return _this._renderer.setStyle(_this.track.nativeElement, propertyName, value);
              },
              setMarkerValue: function (value) { return _this.pinValueMarker.nativeElement.innerText = value; },
              appendTrackMarkers: function (numMarkers) {
                  for (var /** @type {?} */ i = 0; i < numMarkers; i++) {
                      var /** @type {?} */ marker = _this._renderer.createElement('div');
                      _this._renderer.addClass(marker, 'mdc-slider__track-marker');
                      _this._renderer.appendChild(_this.trackMarkerContainer.nativeElement, marker);
                  }
              },
              removeTrackMarkers: function () {
                  while (_this.trackMarkerContainer.nativeElement.firstChild) {
                      _this._renderer.removeChild(_this.trackMarkerContainer.nativeElement, _this.trackMarkerContainer.nativeElement.firstChild);
                  }
              },
              setLastTrackMarkersStyleProperty: function (propertyName, value) {
                  return _this._renderer.setStyle(_this.trackMarkerContainer.nativeElement.lastChild, propertyName, value);
              },
              isRTL: function () { return getComputedStyle(_this._getHostElement()).direction === 'rtl'; }
          };
      }
      Object.defineProperty(MdcSlider.prototype, "discrete", {
          get: /**
           * @return {?}
           */
          function () { return this._discrete; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setDiscrete(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSlider.prototype, "markers", {
          get: /**
           * @return {?}
           */
          function () { return this._markers; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setMarkers(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSlider.prototype, "min", {
          get: /**
           * @return {?}
           */
          function () { return this._min; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setMin(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSlider.prototype, "max", {
          get: /**
           * @return {?}
           */
          function () { return this._max; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setMax(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSlider.prototype, "step", {
          get: /**
           * @return {?}
           */
          function () { return this._step; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setStep(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSlider.prototype, "value", {
          get: /**
           * @return {?}
           */
          function () { return this._value; },
          set: /**
           * @param {?} newValue
           * @return {?}
           */
          function (newValue) {
              this.setValue(newValue);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSlider.prototype, "disabled", {
          get: /**
           * @return {?}
           */
          function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setDisabled(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSlider.prototype, "classDiscrete", {
          get: /**
           * @return {?}
           */
          function () {
              return this.discrete ? 'mdc-slider--discrete' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSlider.prototype, "classDisplayMarkers", {
          get: /**
           * @return {?}
           */
          function () {
              return this.markers && this.discrete ? 'mdc-slider--display-markers' : '';
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MdcSlider.prototype.ngAfterViewInit = /**
       * @return {?}
       */
      function () {
          this._foundation = new MDCSliderFoundation(this._mdcAdapter);
          this._foundation.init();
          this.setMin(this.min);
          this.setMax(this.max);
          this.setStep(this.step);
          this.setValue(this.value);
          this._foundation.setupTrackMarker();
      };
      /**
       * @return {?}
       */
      MdcSlider.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._foundation.destroy();
      };
      /**
       * @param {?} value
       * @return {?}
       */
      MdcSlider.prototype.writeValue = /**
       * @param {?} value
       * @return {?}
       */
      function (value) {
          if (value) {
              if (value !== this.value) {
                  this.setValue(value);
              }
          }
      };
      /**
       * @param {?} fn
       * @return {?}
       */
      MdcSlider.prototype.registerOnChange = /**
       * @param {?} fn
       * @return {?}
       */
      function (fn) {
          this._onChange = fn;
      };
      /**
       * @param {?} fn
       * @return {?}
       */
      MdcSlider.prototype.registerOnTouched = /**
       * @param {?} fn
       * @return {?}
       */
      function (fn) {
          this._onTouched = fn;
      };
      /**
       * @param {?} discrete
       * @return {?}
       */
      MdcSlider.prototype.setDiscrete = /**
       * @param {?} discrete
       * @return {?}
       */
      function (discrete) {
          this._discrete = discrete;
      };
      /**
       * @param {?} markers
       * @return {?}
       */
      MdcSlider.prototype.setMarkers = /**
       * @param {?} markers
       * @return {?}
       */
      function (markers) {
          this._markers = markers;
      };
      /**
       * @param {?} value
       * @return {?}
       */
      MdcSlider.prototype.setValue = /**
       * @param {?} value
       * @return {?}
       */
      function (value) {
          if (this.disabled) {
              return;
          }
          var /** @type {?} */ previousValue = this.value;
          this._value = value;
          if (!this._foundation) {
              return;
          }
          this._foundation.setValue(value);
          if (value !== previousValue) {
              this._onChange(value);
          }
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @return {?}
       */
      MdcSlider.prototype.getValue = /**
       * @return {?}
       */
      function () {
          return this._foundation.getValue();
      };
      /**
       * @return {?}
       */
      MdcSlider.prototype.layout = /**
       * @return {?}
       */
      function () {
          this._foundation.layout();
      };
      /**
       * @param {?} min
       * @return {?}
       */
      MdcSlider.prototype.setMin = /**
       * @param {?} min
       * @return {?}
       */
      function (min) {
          if (min > this.max) {
              return;
          }
          this._min = min;
          if (!this._foundation) {
              return;
          }
          this._foundation.setMin(common.toNumber(min, 0));
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @return {?}
       */
      MdcSlider.prototype.getMin = /**
       * @return {?}
       */
      function () {
          return this._foundation.getMin();
      };
      /**
       * @param {?} max
       * @return {?}
       */
      MdcSlider.prototype.setMax = /**
       * @param {?} max
       * @return {?}
       */
      function (max) {
          if (this.min > max) {
              return;
          }
          this._max = max;
          if (!this._foundation) {
              return;
          }
          this._foundation.setMax(common.toNumber(max, 100));
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @return {?}
       */
      MdcSlider.prototype.getMax = /**
       * @return {?}
       */
      function () {
          return this._foundation.getMax();
      };
      /**
       * @param {?} step
       * @return {?}
       */
      MdcSlider.prototype.setStep = /**
       * @param {?} step
       * @return {?}
       */
      function (step) {
          this._step = step;
          if (!this._foundation) {
              return;
          }
          this._foundation.setStep(step);
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @return {?}
       */
      MdcSlider.prototype.getStep = /**
       * @return {?}
       */
      function () {
          return this._foundation.getStep();
      };
      /**
       * @param {?} disabled
       * @return {?}
       */
      MdcSlider.prototype.setDisabled = /**
       * @param {?} disabled
       * @return {?}
       */
      function (disabled) {
          this.setDisabledState(disabled);
      };
      /**
       * @param {?} disabled
       * @return {?}
       */
      MdcSlider.prototype.setDisabledState = /**
       * @param {?} disabled
       * @return {?}
       */
      function (disabled) {
          this._disabled = disabled;
          if (!this._foundation) {
              return;
          }
          this._foundation.setDisabled(disabled);
          this._changeDetectorRef.markForCheck();
      };
      /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      MdcSlider.prototype._getHostElement = /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      function () {
          return this.elementRef.nativeElement;
      };
      MdcSlider.decorators = [
          { type: core.Component, args: [{selector: 'mdc-slider',
                      exportAs: 'mdcSlider',
                      template: "\n    <div class=\"mdc-slider__track-container\">\n      <div #track class=\"mdc-slider__track\"></div>\n      <div #markercontainer *ngIf=\"markers\" class=\"mdc-slider__track-marker-container\"></div>\n    </div>\n    <div #thumbcontainer class=\"mdc-slider__thumb-container\">\n      <div *ngIf=\"discrete\" class=\"mdc-slider__pin\">\n        <span #pin class=\"mdc-slider__pin-value-marker\"></span>\n      </div>\n      <svg class=\"mdc-slider__thumb\" width=\"21\" height=\"21\">\n        <circle cx=\"10.5\" cy=\"10.5\" r=\"7.875\"></circle>\n      </svg>\n      <div class=\"mdc-slider__focus-ring\"></div>\n    </div>\n  ",
                      providers: [
                          MDC_SLIDER_CONTROL_VALUE_ACCESSOR,
                          common.EventRegistry,
                      ],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None
                  },] },
      ];
      /** @nocollapse */
      MdcSlider.ctorParameters = function () { return [
          { type: core.ChangeDetectorRef },
          { type: core.Renderer2 },
          { type: core.ElementRef },
          { type: common.EventRegistry }
      ]; };
      MdcSlider.propDecorators = {
          tabIndex: [{ type: core.Input }],
          name: [{ type: core.Input }],
          discrete: [{ type: core.Input }],
          markers: [{ type: core.Input }],
          min: [{ type: core.Input }],
          max: [{ type: core.Input }],
          step: [{ type: core.Input }],
          value: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          change: [{ type: core.Output }],
          input: [{ type: core.Output }],
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-slider',] }],
          role: [{ type: core.HostBinding, args: ['attr.role',] }],
          classDiscrete: [{ type: core.HostBinding, args: ['class.mdc-slider--discrete',] }],
          classDisplayMarkers: [{ type: core.HostBinding, args: ['class.mdc-slider--display-markers',] }],
          thumbContainer: [{ type: core.ViewChild, args: ['thumbcontainer',] }],
          track: [{ type: core.ViewChild, args: ['track',] }],
          pinValueMarker: [{ type: core.ViewChild, args: ['pin',] }],
          trackMarkerContainer: [{ type: core.ViewChild, args: ['markercontainer',] }]
      };
      return MdcSlider;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var MdcSliderModule = /** @class */ (function () {
      function MdcSliderModule() {
      }
      MdcSliderModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common$1.CommonModule],
                      exports: [MdcSlider],
                      declarations: [MdcSlider]
                  },] },
      ];
      return MdcSliderModule;
  }());

  exports.MdcSliderModule = MdcSliderModule;
  exports.MDC_SLIDER_CONTROL_VALUE_ACCESSOR = MDC_SLIDER_CONTROL_VALUE_ACCESSOR;
  exports.MdcSliderChange = MdcSliderChange;
  exports.MdcSlider = MdcSlider;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
