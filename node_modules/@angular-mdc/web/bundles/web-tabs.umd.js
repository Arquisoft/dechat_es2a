/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular-mdc/web/common'), require('@angular-mdc/web/ripple'), require('@angular-mdc/web/icon')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/tabs', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular-mdc/web/common', '@angular-mdc/web/ripple', '@angular-mdc/web/icon'], factory) :
  (factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.tabs = {}),global.ng.core,global.Rx,global.Rx.operators,global.ng.web.common,global.ng.web.ripple,global.ng.web.icon));
}(this, (function (exports,core,rxjs,operators,common,ripple,icon) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return _get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter =
  /*#__PURE__*/
  function () {
    function MDCRippleAdapter() {
      _classCallCheck(this, MDCRippleAdapter);
    }

    _createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}
      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}
      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}
      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}
      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}
      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}
      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}
      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}
      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}
      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);

    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };
  var strings = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };
  var numbers = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225,
    // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150,
    // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_;
  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */

  var supportsPassive_;
  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */

  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }
  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */


  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var supportsCssVariables = supportsCssVariables_;

    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari

    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVariables;
    }

    return supportsCssVariables;
  } //

  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */


  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;

      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = true;
          }

        });
      } catch (e) {}

      supportsPassive_ = isSupported;
    }

    return supportsPassive_ ? {
      passive: true
    } : false;
  }
  /**
   * @param {!Object} HTMLElementPrototype
   * @return {!Array<string>}
   */


  function getMatchesProperty(HTMLElementPrototype) {
    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
      return p in HTMLElementPrototype;
    }).pop();
  }
  /**
   * @param {!Event} ev
   * @param {{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {{x: number, y: number}}
   */


  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY; // Determine touch point relative to the ripple container.

    if (ev.type === 'touchstart') {
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return {
      x: normalizedX,
      y: normalizedY
    };
  }

  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

  /** @type {!Array<!EventTarget>} */

  var activatedTargets = [];
  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCRippleFoundation, _MDCFoundation);

    _createClass(MDCRippleFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars()
          /* boolean - cached */
          {},
          isUnbounded: function isUnbounded()
          /* boolean */
          {},
          isSurfaceActive: function isSurfaceActive()
          /* boolean */
          {},
          isSurfaceDisabled: function isSurfaceDisabled()
          /* boolean */
          {},
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          containsEventTarget: function containsEventTarget()
          /* target: !EventTarget */
          {},
          registerInteractionHandler: function registerInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          deregisterInteractionHandler: function deregisterInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          registerResizeHandler: function registerResizeHandler()
          /* handler: EventListener */
          {},
          deregisterResizeHandler: function deregisterResizeHandler()
          /* handler: EventListener */
          {},
          updateCssVariable: function updateCssVariable()
          /* varName: string, value: string */
          {},
          computeBoundingRect: function computeBoundingRect()
          /* ClientRect */
          {},
          getWindowPageOffset: function getWindowPageOffset()
          /* {x: number, y: number} */
          {}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCRippleFoundation);

      _this = _possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
      /** @private {number} */

      _this.layoutFrame_ = 0;
      /** @private {!ClientRect} */

      _this.frame_ =
      /** @type {!ClientRect} */
      {
        width: 0,
        height: 0
      };
      /** @private {!ActivationStateType} */

      _this.activationState_ = _this.defaultActivationState_();
      /** @private {number} */

      _this.initialSize_ = 0;
      /** @private {number} */

      _this.maxRadius_ = 0;
      /** @private {function(!Event)} */

      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };
      /** @private {function(!Event)} */


      _this.deactivateHandler_ = function (e) {
        return _this.deactivate_(e);
      };
      /** @private {function(?Event=)} */


      _this.focusHandler_ = function () {
        return requestAnimationFrame(function () {
          return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      };
      /** @private {function(?Event=)} */


      _this.blurHandler_ = function () {
        return requestAnimationFrame(function () {
          return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      };
      /** @private {!Function} */


      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      /** @private {{left: number, top:number}} */


      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };
      /** @private {number} */

      _this.fgScale_ = 0;
      /** @private {number} */

      _this.activationTimer_ = 0;
      /** @private {number} */

      _this.fgDeactivationRemovalTimer_ = 0;
      /** @private {boolean} */

      _this.activationAnimationHasEnded_ = false;
      /** @private {!Function} */

      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;

        _this.runDeactivationUXLogicIfReady_();
      };
      /** @private {?Event} */


      _this.previousActivationEvent_ = null;
      return _this;
    }
    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    _createClass(MDCRippleFoundation, [{
      key: "isSupported_",
      value: function isSupported_() {
        return this.adapter_.browserSupportsCssVars();
      }
      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: "defaultActivationState_",
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: null,
          isProgrammatic: false
        };
      }
    }, {
      key: "init",
      value: function init() {
        var _this2 = this;

        if (!this.isSupported_()) {
          return;
        }

        this.registerRootHandlers_();
        var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$.ROOT,
            UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
        requestAnimationFrame(function () {
          _this2.adapter_.addClass(ROOT);

          if (_this2.adapter_.isUnbounded()) {
            _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


            _this2.layoutInternal_();
          }
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        if (!this.isSupported_()) {
          return;
        }

        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();
        var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$2.ROOT,
            UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(ROOT);

          _this3.adapter_.removeClass(UNBOUNDED);

          _this3.removeCssVars_();
        });
      }
      /** @private */

    }, {
      key: "registerRootHandlers_",
      value: function registerRootHandlers_() {
        var _this4 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
        });
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }
      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: "registerDeactivationHandlers_",
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }
      /** @private */

    }, {
      key: "deregisterRootHandlers_",
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }
      /** @private */

    }, {
      key: "deregisterDeactivationHandlers_",
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }
      /** @private */

    }, {
      key: "removeCssVars_",
      value: function removeCssVars_() {
        var _this8 = this;

        var strings$$1 = MDCRippleFoundation.strings;
        Object.keys(strings$$1).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings$$1[k], null);
          }
        });
      }
      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: "activate_",
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;

        if (activationState.isActivated) {
          return;
        } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === null;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
        var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });

        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e) {
          activatedTargets.push(
          /** @type {!EventTarget} */
          e.target);
          this.registerDeactivationHandlers_(e);
        }

        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }

        requestAnimationFrame(function () {
          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];

          if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
            // If space was pressed, try again within an rAF call to detect :active, because different UAs report
            // active states inconsistently when they're called within event handling code:
            // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
            // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
            // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
            // variable is set within a rAF callback for a submit button interaction (#2241).
            activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

            if (activationState.wasElementMadeActive) {
              _this9.animateActivation_();
            }
          }

          if (!activationState.wasElementMadeActive) {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }
        });
      }
      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: "checkElementMadeActive_",
      value: function checkElementMadeActive_(e) {
        return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
      }
      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: "activate",
      value: function activate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        this.activate_(event);
      }
      /** @private */

    }, {
      key: "animateActivation_",
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
        this.layoutInternal_();
        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
              startPoint = _getFgTranslationCoor.startPoint,
              endPoint = _getFgTranslationCoor.endPoint;

          translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
          translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }
      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: "getFgTranslationCoordinates_",
      value: function getFgTranslationCoordinates_() {
        var _activationState_ = this.activationState_,
            activationEvent = _activationState_.activationEvent,
            wasActivatedByPointer = _activationState_.wasActivatedByPointer;
        var startPoint;

        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */
          activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        } // Center the element around the start point.


        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };
        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };
        return {
          startPoint: startPoint,
          endPoint: endPoint
        };
      }
      /** @private */

    }, {
      key: "runDeactivationUXLogicIfReady_",
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _activationState_2 = this.activationState_,
            hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
            isActivated = _activationState_2.isActivated;
        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers.FG_DEACTIVATION_MS);
        }
      }
      /** @private */

    }, {
      key: "rmBoundedActivationClasses_",
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: "resetActivationState_",
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.

        setTimeout(function () {
          return _this12.previousActivationEvent_ = null;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }
      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: "deactivate_",
      value: function deactivate_(e) {
        var _this13 = this;

        var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

        if (!activationState.isActivated) {
          return;
        }

        var state =
        /** @type {!ActivationStateType} */
        Object.assign({}, activationState);

        if (activationState.isProgrammatic) {
          var evtObject = null;
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(evtObject, state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;

            _this13.animateDeactivation_(e, state);

            _this13.resetActivationState_();
          });
        }
      }
      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: "deactivate",
      value: function deactivate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        this.deactivate_(event);
      }
      /**
       * @param {Event} e
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: "animateDeactivation_",
      value: function animateDeactivation_(e, _ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();

          _this14.layoutFrame_ = 0;
        });
      }
      /** @private */

    }, {
      key: "layoutInternal_",
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.

        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

        this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
        this.fgScale_ = this.maxRadius_ / this.initialSize_;
        this.updateLayoutCssVars_();
      }
      /** @private */

    }, {
      key: "updateLayoutCssVars_",
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
        this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };
          this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
          this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
        }
      }
      /** @param {boolean} unbounded */

    }, {
      key: "setUnbounded",
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }]);

    return MDCRippleFoundation;
  }(MDCFoundation);

  /**
   * @extends MDCComponent<!MDCRippleFoundation>
   */

  var MDCRipple =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCRipple, _MDCComponent);

    /** @param {...?} args */
    function MDCRipple() {
      var _ref;

      var _this;

      _classCallCheck(this, MDCRipple);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));
      /** @type {boolean} */

      _this.disabled = false;
      /** @private {boolean} */

      _this.unbounded_;
      return _this;
    }
    /**
     * @param {!Element} root
     * @param {{isUnbounded: (boolean|undefined)}=} options
     * @return {!MDCRipple}
     */


    _createClass(MDCRipple, [{
      key: "setUnbounded_",

      /**
       * Closure Compiler throws an access control error when directly accessing a
       * protected or private property inside a getter/setter, like unbounded above.
       * By accessing the protected property inside a method, we solve that problem.
       * That's why this function exists.
       * @private
       */
      value: function setUnbounded_() {
        this.foundation_.setUnbounded(this.unbounded_);
      }
    }, {
      key: "activate",
      value: function activate() {
        this.foundation_.activate();
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.foundation_.deactivate();
      }
    }, {
      key: "layout",
      value: function layout() {
        this.foundation_.layout();
      }
      /** @return {!MDCRippleFoundation} */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        return new MDCRippleFoundation(MDCRipple.createAdapter(this));
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
      }
    }, {
      key: "unbounded",

      /** @return {boolean} */
      get: function get() {
        return this.unbounded_;
      }
      /** @param {boolean} unbounded */
      ,
      set: function set(unbounded) {
        this.unbounded_ = Boolean(unbounded);
        this.setUnbounded_();
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref2$isUnbounded = _ref2.isUnbounded,
            isUnbounded = _ref2$isUnbounded === void 0 ? undefined : _ref2$isUnbounded;

        var ripple$$1 = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

        if (isUnbounded !== undefined) {
          ripple$$1.unbounded =
          /** @type {boolean} */
          isUnbounded;
        }

        return ripple$$1;
      }
      /**
       * @param {!RippleCapableSurface} instance
       * @return {!MDCRippleAdapter}
       */

    }, {
      key: "createAdapter",
      value: function createAdapter(instance) {
        var MATCHES = getMatchesProperty(HTMLElement.prototype);
        return {
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return instance.unbounded;
          },
          isSurfaceActive: function isSurfaceActive() {
            return instance.root_[MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return instance.disabled;
          },
          addClass: function addClass(className) {
            return instance.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return instance.root_.classList.remove(className);
          },
          containsEventTarget: function containsEventTarget(target) {
            return instance.root_.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return instance.root_.addEventListener(evtType, handler, applyPassive());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return instance.root_.removeEventListener(evtType, handler, applyPassive());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            return instance.root_.style.setProperty(varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return instance.root_.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return {
              x: window.pageXOffset,
              y: window.pageYOffset
            };
          }
        };
      }
    }]);

    return MDCRipple;
  }(MDCComponent);

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$1 = {
    ACTIVE: 'mdc-tab--active'
  };
  var strings$1 = {
    SELECTED_EVENT: 'MDCTab:selected'
  };

  var MDCTabFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTabFoundation, _MDCFoundation);

    _createClass(MDCTabFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$1;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$1;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          registerInteractionHandler: function registerInteractionHandler()
          /* type: string, handler: EventListener */
          {},
          deregisterInteractionHandler: function deregisterInteractionHandler()
          /* type: string, handler: EventListener */
          {},
          getOffsetWidth: function getOffsetWidth() {
            return (
              /* number */
              0
            );
          },
          getOffsetLeft: function getOffsetLeft() {
            return (
              /* number */
              0
            );
          },
          notifySelected: function notifySelected() {}
        };
      }
    }]);

    function MDCTabFoundation() {
      var _this;

      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCTabFoundation);

      _this = _possibleConstructorReturn(this, (MDCTabFoundation.__proto__ || Object.getPrototypeOf(MDCTabFoundation)).call(this, Object.assign(MDCTabFoundation.defaultAdapter, adapter)));
      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.isActive_ = false;
      _this.preventDefaultOnClick_ = false;

      _this.clickHandler_ = function (evt) {
        if (_this.preventDefaultOnClick_) {
          evt.preventDefault();
        }

        _this.adapter_.notifySelected();
      };

      _this.keydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
          _this.adapter_.notifySelected();
        }
      };

      return _this;
    }

    _createClass(MDCTabFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: "getComputedWidth",
      value: function getComputedWidth() {
        return this.computedWidth_;
      }
    }, {
      key: "getComputedLeft",
      value: function getComputedLeft() {
        return this.computedLeft_;
      }
    }, {
      key: "isActive",
      value: function isActive() {
        return this.isActive_;
      }
    }, {
      key: "setActive",
      value: function setActive(isActive) {
        this.isActive_ = isActive;

        if (this.isActive_) {
          this.adapter_.addClass(cssClasses$1.ACTIVE);
        } else {
          this.adapter_.removeClass(cssClasses$1.ACTIVE);
        }
      }
    }, {
      key: "preventsDefaultOnClick",
      value: function preventsDefaultOnClick() {
        return this.preventDefaultOnClick_;
      }
    }, {
      key: "setPreventDefaultOnClick",
      value: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.preventDefaultOnClick_ = preventDefaultOnClick;
      }
    }, {
      key: "measureSelf",
      value: function measureSelf() {
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.computedLeft_ = this.adapter_.getOffsetLeft();
      }
    }]);

    return MDCTabFoundation;
  }(MDCFoundation);

  var MDCTab =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCTab, _MDCComponent);

    _createClass(MDCTab, [{
      key: "computedWidth",
      get: function get$$1() {
        return this.foundation_.getComputedWidth();
      }
    }, {
      key: "computedLeft",
      get: function get$$1() {
        return this.foundation_.getComputedLeft();
      }
    }, {
      key: "isActive",
      get: function get$$1() {
        return this.foundation_.isActive();
      },
      set: function set(isActive) {
        this.foundation_.setActive(isActive);
      }
    }, {
      key: "preventDefaultOnClick",
      get: function get$$1() {
        return this.foundation_.preventsDefaultOnClick();
      },
      set: function set(preventDefaultOnClick) {
        this.foundation_.setPreventDefaultOnClick(preventDefaultOnClick);
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCTab(root);
      }
    }]);

    function MDCTab() {
      var _ref;

      var _this;

      _classCallCheck(this, MDCTab);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_ref = MDCTab.__proto__ || Object.getPrototypeOf(MDCTab)).call.apply(_ref, [this].concat(args)));
      _this.ripple_ = MDCRipple.attachTo(_this.root_);
      return _this;
    }

    _createClass(MDCTab, [{
      key: "destroy",
      value: function destroy() {
        this.ripple_.destroy();

        _get(MDCTab.prototype.__proto__ || Object.getPrototypeOf(MDCTab.prototype), "destroy", this).call(this);
      }
    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this2 = this;

        return new MDCTabFoundation({
          addClass: function addClass(className) {
            return _this2.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this2.root_.classList.remove(className);
          },
          registerInteractionHandler: function registerInteractionHandler(type, handler) {
            return _this2.root_.addEventListener(type, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
            return _this2.root_.removeEventListener(type, handler);
          },
          getOffsetWidth: function getOffsetWidth() {
            return _this2.root_.offsetWidth;
          },
          getOffsetLeft: function getOffsetLeft() {
            return _this2.root_.offsetLeft;
          },
          notifySelected: function notifySelected() {
            return _this2.emit(MDCTabFoundation.strings.SELECTED_EVENT, {
              tab: _this2
            }, true);
          }
        });
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        this.isActive = this.root_.classList.contains(cssClasses$1.ACTIVE);
      }
    }, {
      key: "measureSelf",
      value: function measureSelf() {
        this.foundation_.measureSelf();
      }
    }]);

    return MDCTab;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /** @const {Object<string, !VendorPropertyMapType>} */

  var eventTypeMap = {
    'animationstart': {
      noPrefix: 'animationstart',
      webkitPrefix: 'webkitAnimationStart',
      styleProperty: 'animation'
    },
    'animationend': {
      noPrefix: 'animationend',
      webkitPrefix: 'webkitAnimationEnd',
      styleProperty: 'animation'
    },
    'animationiteration': {
      noPrefix: 'animationiteration',
      webkitPrefix: 'webkitAnimationIteration',
      styleProperty: 'animation'
    },
    'transitionend': {
      noPrefix: 'transitionend',
      webkitPrefix: 'webkitTransitionEnd',
      styleProperty: 'transition'
    }
  };
  /** @const {Object<string, !VendorPropertyMapType>} */

  var cssPropertyMap = {
    'animation': {
      noPrefix: 'animation',
      webkitPrefix: '-webkit-animation'
    },
    'transform': {
      noPrefix: 'transform',
      webkitPrefix: '-webkit-transform'
    },
    'transition': {
      noPrefix: 'transition',
      webkitPrefix: '-webkit-transition'
    }
  };
  /**
   * @param {!Object} windowObj
   * @return {boolean}
   */

  function hasProperShape(windowObj) {
    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
  }
  /**
   * @param {string} eventType
   * @return {boolean}
   */


  function eventFoundInMaps(eventType) {
    return eventType in eventTypeMap || eventType in cssPropertyMap;
  }
  /**
   * @param {string} eventType
   * @param {!Object<string, !VendorPropertyMapType>} map
   * @param {!Element} el
   * @return {string}
   */


  function getJavaScriptEventName(eventType, map, el) {
    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }
  /**
   * Helper function to determine browser prefix for CSS3 animation events
   * and property names.
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */


  function getAnimationName(windowObj, eventType) {
    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
      return eventType;
    }

    var map =
    /** @type {!Object<string, !VendorPropertyMapType>} */
    eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
    var el = windowObj['document']['createElement']('div');
    var eventName = '';

    if (map === eventTypeMap) {
      eventName = getJavaScriptEventName(eventType, map, el);
    } else {
      eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }

    return eventName;
  } // Public functions to access getAnimationName() for JavaScript events or CSS
  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */


  function getCorrectPropertyName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$2 = {
    UPGRADED: 'mdc-tab-bar-upgraded'
  };
  var strings$2 = {
    TAB_SELECTOR: '.mdc-tab',
    INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
    CHANGE_EVENT: 'MDCTabBar:change'
  };

  var MDCTabBarFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTabBarFoundation, _MDCFoundation);

    _createClass(MDCTabBarFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$2;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$2;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {},
          unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {},
          registerResizeHandler: function registerResizeHandler()
          /* handler: EventListener */
          {},
          deregisterResizeHandler: function deregisterResizeHandler()
          /* handler: EventListener */
          {},
          getOffsetWidth: function getOffsetWidth() {
            return (
              /* number */
              0
            );
          },
          setStyleForIndicator: function setStyleForIndicator()
          /* propertyName: string, value: string */
          {},
          getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
            return (
              /* number */
              0
            );
          },
          notifyChange: function notifyChange()
          /* evtData: {activeTabIndex: number} */
          {},
          getNumberOfTabs: function getNumberOfTabs() {
            return (
              /* number */
              0
            );
          },
          isTabActiveAtIndex: function isTabActiveAtIndex() {
            return (
              /* index: number */

              /* boolean */
              false
            );
          },
          setTabActiveAtIndex: function setTabActiveAtIndex()
          /* index: number, isActive: true */
          {},
          isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {
            return (
              /* index: number */

              /* boolean */
              false
            );
          },
          setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex()
          /* index: number, preventDefaultOnClick: boolean */
          {},
          measureTabAtIndex: function measureTabAtIndex()
          /* index: number */
          {},
          getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
            return (
              /* index: number */

              /* number */
              0
            );
          },
          getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
            return (
              /* index: number */

              /* number */
              0
            );
          }
        };
      }
    }]);

    function MDCTabBarFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCTabBarFoundation);

      _this = _possibleConstructorReturn(this, (MDCTabBarFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarFoundation)).call(this, Object.assign(MDCTabBarFoundation.defaultAdapter, adapter)));
      _this.isIndicatorShown_ = false;
      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.activeTabIndex_ = 0;
      _this.layoutFrame_ = 0;

      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      return _this;
    }

    _createClass(MDCTabBarFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.addClass(cssClasses$2.UPGRADED);
        this.adapter_.bindOnMDCTabSelectedEvent();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        var activeTabIndex = this.findActiveTabIndex_();

        if (activeTabIndex >= 0) {
          this.activeTabIndex_ = activeTabIndex;
        }

        this.layout();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.removeClass(cssClasses$2.UPGRADED);
        this.adapter_.unbindOnMDCTabSelectedEvent();
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: "layoutInternal_",
      value: function layoutInternal_() {
        var _this2 = this;

        this.forEachTabIndex_(function (index) {
          return _this2.adapter_.measureTabAtIndex(index);
        });
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.layoutIndicator_();
      }
    }, {
      key: "layoutIndicator_",
      value: function layoutIndicator_() {
        var isIndicatorFirstRender = !this.isIndicatorShown_; // Ensure that indicator appears in the right position immediately for correct first render.

        if (isIndicatorFirstRender) {
          this.adapter_.setStyleForIndicator('transition', 'none');
        }

        var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
        var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();
        var transformValue = "translateX(".concat(translateAmtForActiveTabLeft, "px) scale(").concat(scaleAmtForActiveTabWidth, ", 1)");
        this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);

        if (isIndicatorFirstRender) {
          // Force layout so that transform styles to take effect.
          this.adapter_.getOffsetWidthForIndicator();
          this.adapter_.setStyleForIndicator('transition', '');
          this.adapter_.setStyleForIndicator('visibility', 'visible');
          this.isIndicatorShown_ = true;
        }
      }
    }, {
      key: "findActiveTabIndex_",
      value: function findActiveTabIndex_() {
        var _this3 = this;

        var activeTabIndex = -1;
        this.forEachTabIndex_(function (index) {
          if (_this3.adapter_.isTabActiveAtIndex(index)) {
            activeTabIndex = index;
            return true;
          }
        });
        return activeTabIndex;
      }
    }, {
      key: "forEachTabIndex_",
      value: function forEachTabIndex_(iterator) {
        var numTabs = this.adapter_.getNumberOfTabs();

        for (var index = 0; index < numTabs; index++) {
          var shouldBreak = iterator(index);

          if (shouldBreak) {
            break;
          }
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        var _this4 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this4.layoutInternal_();

          _this4.layoutFrame_ = 0;
        });
      }
    }, {
      key: "switchToTabAtIndex",
      value: function switchToTabAtIndex(index, shouldNotify) {
        var _this5 = this;

        if (index === this.activeTabIndex_) {
          return;
        }

        if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
          throw new Error("Out of bounds index specified for tab: ".concat(index));
        }

        var prevActiveTabIndex = this.activeTabIndex_;
        this.activeTabIndex_ = index;
        requestAnimationFrame(function () {
          if (prevActiveTabIndex >= 0) {
            _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
          }

          _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);

          _this5.layoutIndicator_();

          if (shouldNotify) {
            _this5.adapter_.notifyChange({
              activeTabIndex: _this5.activeTabIndex_
            });
          }
        });
      }
    }, {
      key: "getActiveTabIndex",
      value: function getActiveTabIndex() {
        return this.findActiveTabIndex_();
      }
    }]);

    return MDCTabBarFoundation;
  }(MDCFoundation);

  var MDCTabBar =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCTabBar, _MDCComponent);

    function MDCTabBar() {
      _classCallCheck(this, MDCTabBar);

      return _possibleConstructorReturn(this, (MDCTabBar.__proto__ || Object.getPrototypeOf(MDCTabBar)).apply(this, arguments));
    }

    _createClass(MDCTabBar, [{
      key: "initialize",
      value: function initialize() {
        var _this = this;

        var tabFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
          return new MDCTab(el);
        };
        this.indicator_ = this.root_.querySelector(MDCTabBarFoundation.strings.INDICATOR_SELECTOR);
        this.tabs_ = this.gatherTabs_(tabFactory);

        this.tabSelectedHandler_ = function (_ref) {
          var detail = _ref.detail;
          var tab = detail.tab;

          _this.setActiveTab_(tab, true);
        };
      }
    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this2 = this;

        return new MDCTabBarFoundation({
          addClass: function addClass(className) {
            return _this2.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this2.root_.classList.remove(className);
          },
          bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {
            return _this2.listen(MDCTabFoundation.strings.SELECTED_EVENT, _this2.tabSelectedHandler_);
          },
          unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {
            return _this2.unlisten(MDCTabFoundation.strings.SELECTED_EVENT, _this2.tabSelectedHandler_);
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          getOffsetWidth: function getOffsetWidth() {
            return _this2.root_.offsetWidth;
          },
          setStyleForIndicator: function setStyleForIndicator(propertyName, value) {
            return _this2.indicator_.style.setProperty(propertyName, value);
          },
          getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
            return _this2.indicator_.offsetWidth;
          },
          notifyChange: function notifyChange(evtData) {
            return _this2.emit(MDCTabBarFoundation.strings.CHANGE_EVENT, evtData);
          },
          getNumberOfTabs: function getNumberOfTabs() {
            return _this2.tabs.length;
          },
          isTabActiveAtIndex: function isTabActiveAtIndex(index) {
            return _this2.tabs[index].isActive;
          },
          setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {
            _this2.tabs[index].isActive = isActive;
          },
          isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {
            return _this2.tabs[index].preventDefaultOnClick;
          },
          setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
            _this2.tabs[index].preventDefaultOnClick = preventDefaultOnClick;
          },
          measureTabAtIndex: function measureTabAtIndex(index) {
            return _this2.tabs[index].measureSelf();
          },
          getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
            return _this2.tabs[index].computedWidth;
          },
          getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
            return _this2.tabs[index].computedLeft;
          }
        });
      }
    }, {
      key: "gatherTabs_",
      value: function gatherTabs_(tabFactory) {
        var tabElements = [].slice.call(this.root_.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
        return tabElements.map(function (el) {
          return tabFactory(el);
        });
      }
    }, {
      key: "setActiveTabIndex_",
      value: function setActiveTabIndex_(activeTabIndex, notifyChange) {
        this.foundation_.switchToTabAtIndex(activeTabIndex, notifyChange);
      }
    }, {
      key: "layout",
      value: function layout() {
        this.foundation_.layout();
      }
    }, {
      key: "setActiveTab_",
      value: function setActiveTab_(activeTab, notifyChange) {
        var indexOfTab = this.tabs.indexOf(activeTab);

        if (indexOfTab < 0) {
          throw new Error('Invalid tab component given as activeTab: Tab not found within this component\'s tab list');
        }

        this.setActiveTabIndex_(indexOfTab, notifyChange);
      }
    }, {
      key: "tabs",
      get: function get() {
        return this.tabs_;
      }
    }, {
      key: "activeTab",
      get: function get() {
        var activeIndex = this.foundation_.getActiveTabIndex();
        return this.tabs[activeIndex];
      },
      set: function set(tab) {
        this.setActiveTab_(tab, false);
      }
    }, {
      key: "activeTabIndex",
      get: function get() {
        return this.foundation_.getActiveTabIndex();
      },
      set: function set(index) {
        this.setActiveTabIndex_(index, false);
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCTabBar(root);
      }
    }]);

    return MDCTabBar;
  }(MDCComponent);

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$3 = {
    INDICATOR_FORWARD: 'mdc-tab-bar-scroller__indicator--forward',
    INDICATOR_BACK: 'mdc-tab-bar-scroller__indicator--back',
    INDICATOR_ENABLED: 'mdc-tab-bar-scroller__indicator--enabled',
    TAB: 'mdc-tab'
  };
  var strings$3 = {
    FRAME_SELECTOR: '.mdc-tab-bar-scroller__scroll-frame',
    TABS_SELECTOR: '.mdc-tab-bar-scroller__scroll-frame__tabs',
    TAB_SELECTOR: '.mdc-tab',
    INDICATOR_FORWARD_SELECTOR: '.mdc-tab-bar-scroller__indicator--forward',
    INDICATOR_BACK_SELECTOR: '.mdc-tab-bar-scroller__indicator--back'
  };

  var MDCTabBarScrollerFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTabBarScrollerFoundation, _MDCFoundation);

    _createClass(MDCTabBarScrollerFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$3;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$3;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          eventTargetHasClass: function eventTargetHasClass() {
            return (
              /* target: EventTarget, className: string */

              /* boolean */
              false
            );
          },
          addClassToForwardIndicator: function addClassToForwardIndicator()
          /* className: string */
          {},
          removeClassFromForwardIndicator: function removeClassFromForwardIndicator()
          /* className: string */
          {},
          addClassToBackIndicator: function addClassToBackIndicator()
          /* className: string */
          {},
          removeClassFromBackIndicator: function removeClassFromBackIndicator()
          /* className: string */
          {},
          isRTL: function isRTL() {
            return (
              /* boolean */
              false
            );
          },
          registerBackIndicatorClickHandler: function registerBackIndicatorClickHandler()
          /* handler: EventListener */
          {},
          deregisterBackIndicatorClickHandler: function deregisterBackIndicatorClickHandler()
          /* handler: EventListener */
          {},
          registerForwardIndicatorClickHandler: function registerForwardIndicatorClickHandler()
          /* handler: EventListener */
          {},
          deregisterForwardIndicatorClickHandler: function deregisterForwardIndicatorClickHandler()
          /* handler: EventListener */
          {},
          registerCapturedInteractionHandler: function registerCapturedInteractionHandler()
          /* evt: string, handler: EventListener */
          {},
          deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler()
          /* evt: string, handler: EventListener */
          {},
          registerWindowResizeHandler: function registerWindowResizeHandler()
          /* handler: EventListener */
          {},
          deregisterWindowResizeHandler: function deregisterWindowResizeHandler()
          /* handler: EventListener */
          {},
          getNumberOfTabs: function getNumberOfTabs() {
            return (
              /* number */
              0
            );
          },
          getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
            return (
              /* number */
              0
            );
          },
          getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
            return (
              /* number */
              0
            );
          },
          getOffsetWidthForScrollFrame: function getOffsetWidthForScrollFrame() {
            return (
              /* number */
              0
            );
          },
          getScrollLeftForScrollFrame: function getScrollLeftForScrollFrame() {
            return (
              /* number */
              0
            );
          },
          setScrollLeftForScrollFrame: function setScrollLeftForScrollFrame()
          /* scrollLeftAmount: number */
          {},
          getOffsetWidthForTabBar: function getOffsetWidthForTabBar() {
            return (
              /* number */
              0
            );
          },
          setTransformStyleForTabBar: function setTransformStyleForTabBar()
          /* value: string */
          {},
          getOffsetLeftForEventTarget: function getOffsetLeftForEventTarget() {
            return (
              /* target: EventTarget */

              /* number */
              0
            );
          },
          getOffsetWidthForEventTarget: function getOffsetWidthForEventTarget() {
            return (
              /* target: EventTarget */

              /* number */
              0
            );
          }
        };
      }
    }]);

    function MDCTabBarScrollerFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCTabBarScrollerFoundation);

      _this = _possibleConstructorReturn(this, (MDCTabBarScrollerFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarScrollerFoundation)).call(this, Object.assign(MDCTabBarScrollerFoundation.defaultAdapter, adapter)));
      _this.pointerDownRecognized_ = false;
      _this.currentTranslateOffset_ = 0;
      _this.focusedTarget_ = null;
      _this.layoutFrame_ = 0;
      _this.scrollFrameScrollLeft_ = 0;

      _this.forwardIndicatorClickHandler_ = function (evt) {
        return _this.scrollForward(evt);
      };

      _this.backIndicatorClickHandler_ = function (evt) {
        return _this.scrollBack(evt);
      };

      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      _this.interactionHandler_ = function (evt) {
        if (evt.type == 'touchstart' || evt.type == 'mousedown') {
          _this.pointerDownRecognized_ = true;
        }

        _this.handlePossibleTabKeyboardFocus_(evt);

        if (evt.type == 'focus') {
          _this.pointerDownRecognized_ = false;
        }
      };

      return _this;
    }

    _createClass(MDCTabBarScrollerFoundation, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        this.adapter_.registerBackIndicatorClickHandler(this.backIndicatorClickHandler_);
        this.adapter_.registerForwardIndicatorClickHandler(this.forwardIndicatorClickHandler_);
        this.adapter_.registerWindowResizeHandler(this.resizeHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this2.adapter_.registerCapturedInteractionHandler(evtType, _this2.interactionHandler_);
        });
        this.layout();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        this.adapter_.deregisterBackIndicatorClickHandler(this.backIndicatorClickHandler_);
        this.adapter_.deregisterForwardIndicatorClickHandler(this.forwardIndicatorClickHandler_);
        this.adapter_.deregisterWindowResizeHandler(this.resizeHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this3.adapter_.deregisterCapturedInteractionHandler(evtType, _this3.interactionHandler_);
        });
      }
    }, {
      key: "scrollBack",
      value: function scrollBack() {
        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (evt) {
          evt.preventDefault();
        }

        var tabWidthAccumulator = 0;
        var scrollTargetIndex = 0;

        for (var i = this.adapter_.getNumberOfTabs() - 1; i > 0; i--) {
          var tabOffsetLeft = this.adapter_.getComputedLeftForTabAtIndex(i);
          var tabBarWidthLessTabOffsetLeft = this.adapter_.getOffsetWidthForTabBar() - tabOffsetLeft;
          var tabIsNotOccluded = tabOffsetLeft > this.currentTranslateOffset_;

          if (this.isRTL_()) {
            tabIsNotOccluded = tabBarWidthLessTabOffsetLeft > this.currentTranslateOffset_;
          }

          if (tabIsNotOccluded) {
            continue;
          }

          tabWidthAccumulator += this.adapter_.getComputedWidthForTabAtIndex(i);
          var scrollTargetDetermined = tabWidthAccumulator > this.adapter_.getOffsetWidthForScrollFrame();

          if (scrollTargetDetermined) {
            scrollTargetIndex = this.isRTL_() ? i + 1 : i;
            break;
          }
        }

        this.scrollToTabAtIndex(scrollTargetIndex);
      }
    }, {
      key: "scrollForward",
      value: function scrollForward() {
        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (evt) {
          evt.preventDefault();
        }

        var scrollFrameOffsetWidth = this.adapter_.getOffsetWidthForScrollFrame() + this.currentTranslateOffset_;
        var scrollTargetIndex = 0;

        for (var i = 0; i < this.adapter_.getNumberOfTabs(); i++) {
          var tabOffsetLeftAndWidth = this.adapter_.getComputedLeftForTabAtIndex(i) + this.adapter_.getComputedWidthForTabAtIndex(i);
          var scrollTargetDetermined = tabOffsetLeftAndWidth > scrollFrameOffsetWidth;

          if (this.isRTL_()) {
            var frameOffsetAndTabWidth = scrollFrameOffsetWidth - this.adapter_.getComputedWidthForTabAtIndex(i);

            var _tabOffsetLeftAndWidth = this.adapter_.getComputedLeftForTabAtIndex(i) + this.adapter_.getComputedWidthForTabAtIndex(i);

            var tabRightOffset = this.adapter_.getOffsetWidthForTabBar() - _tabOffsetLeftAndWidth;

            scrollTargetDetermined = tabRightOffset > frameOffsetAndTabWidth;
          }

          if (scrollTargetDetermined) {
            scrollTargetIndex = i;
            break;
          }
        }

        this.scrollToTabAtIndex(scrollTargetIndex);
      }
    }, {
      key: "layout",
      value: function layout() {
        var _this4 = this;

        cancelAnimationFrame(this.layoutFrame_);
        this.scrollFrameScrollLeft_ = this.adapter_.getScrollLeftForScrollFrame();
        this.layoutFrame_ = requestAnimationFrame(function () {
          return _this4.layout_();
        });
      }
    }, {
      key: "isRTL_",
      value: function isRTL_() {
        return this.adapter_.isRTL();
      }
    }, {
      key: "handlePossibleTabKeyboardFocus_",
      value: function handlePossibleTabKeyboardFocus_(evt) {
        if (!this.adapter_.eventTargetHasClass(evt.target, cssClasses$3.TAB) || this.pointerDownRecognized_) {
          return;
        }

        var resetAmt = this.isRTL_() ? this.scrollFrameScrollLeft_ : 0;
        this.adapter_.setScrollLeftForScrollFrame(resetAmt);
        this.focusedTarget_ = evt.target;
        var scrollFrameWidth = this.adapter_.getOffsetWidthForScrollFrame();
        var tabBarWidth = this.adapter_.getOffsetWidthForTabBar();
        var leftEdge = this.adapter_.getOffsetLeftForEventTarget(this.focusedTarget_);
        var rightEdge = leftEdge + this.adapter_.getOffsetWidthForEventTarget(this.focusedTarget_);
        var shouldScrollBack = rightEdge <= this.currentTranslateOffset_;
        var shouldScrollForward = rightEdge > this.currentTranslateOffset_ + scrollFrameWidth;

        if (this.isRTL_()) {
          var normalizedLeftOffset = tabBarWidth - leftEdge;
          shouldScrollBack = leftEdge >= tabBarWidth - this.currentTranslateOffset_;
          shouldScrollForward = normalizedLeftOffset > scrollFrameWidth + this.currentTranslateOffset_;
        }

        if (shouldScrollForward) {
          this.scrollForward();
        } else if (shouldScrollBack) {
          this.scrollBack();
        }

        this.pointerDownRecognized_ = false;
      }
    }, {
      key: "layout_",
      value: function layout_() {
        var frameWidth = this.adapter_.getOffsetWidthForScrollFrame();
        var isOverflowing = this.adapter_.getOffsetWidthForTabBar() > frameWidth;

        if (!isOverflowing) {
          this.currentTranslateOffset_ = 0;
        }

        this.shiftFrame_();
        this.updateIndicatorEnabledStates_();
      }
    }, {
      key: "scrollToTabAtIndex",
      value: function scrollToTabAtIndex(index) {
        var _this5 = this;

        var scrollTargetOffsetLeft = this.adapter_.getComputedLeftForTabAtIndex(index);
        var scrollTargetOffsetWidth = this.adapter_.getComputedWidthForTabAtIndex(index);
        this.currentTranslateOffset_ = this.normalizeForRTL_(scrollTargetOffsetLeft, scrollTargetOffsetWidth);
        requestAnimationFrame(function () {
          return _this5.shiftFrame_();
        });
      }
    }, {
      key: "normalizeForRTL_",
      value: function normalizeForRTL_(left, width) {
        return this.isRTL_() ? this.adapter_.getOffsetWidthForTabBar() - (left + width) : left;
      }
    }, {
      key: "shiftFrame_",
      value: function shiftFrame_() {
        var shiftAmount = this.isRTL_() ? this.currentTranslateOffset_ : -this.currentTranslateOffset_;
        this.adapter_.setTransformStyleForTabBar("translateX(".concat(shiftAmount, "px)"));
        this.updateIndicatorEnabledStates_();
      }
    }, {
      key: "updateIndicatorEnabledStates_",
      value: function updateIndicatorEnabledStates_() {
        var INDICATOR_ENABLED = cssClasses$3.INDICATOR_ENABLED;

        if (this.currentTranslateOffset_ === 0) {
          this.adapter_.removeClassFromBackIndicator(INDICATOR_ENABLED);
        } else {
          this.adapter_.addClassToBackIndicator(INDICATOR_ENABLED);
        }

        var remainingTabBarWidth = this.adapter_.getOffsetWidthForTabBar() - this.currentTranslateOffset_;

        if (remainingTabBarWidth > this.adapter_.getOffsetWidthForScrollFrame()) {
          this.adapter_.addClassToForwardIndicator(INDICATOR_ENABLED);
        } else {
          this.adapter_.removeClassFromForwardIndicator(INDICATOR_ENABLED);
        }
      }
    }]);

    return MDCTabBarScrollerFoundation;
  }(MDCFoundation);

  var MDCTabBarScroller =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCTabBarScroller, _MDCComponent);

    function MDCTabBarScroller() {
      _classCallCheck(this, MDCTabBarScroller);

      return _possibleConstructorReturn(this, (MDCTabBarScroller.__proto__ || Object.getPrototypeOf(MDCTabBarScroller)).apply(this, arguments));
    }

    _createClass(MDCTabBarScroller, [{
      key: "initialize",
      value: function initialize() {
        var tabBarFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (root) {
          return new MDCTabBar(root);
        };
        this.scrollFrame_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.FRAME_SELECTOR);
        this.tabBarEl_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.TABS_SELECTOR);
        this.forwardIndicator_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.INDICATOR_FORWARD_SELECTOR);
        this.backIndicator_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.INDICATOR_BACK_SELECTOR);
        this.tabBar_ = tabBarFactory(this.tabBarEl_);
      }
    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCTabBarScrollerFoundation({
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          eventTargetHasClass: function eventTargetHasClass(target, className) {
            return target.classList.contains(className);
          },
          addClassToForwardIndicator: function addClassToForwardIndicator(className) {
            return _this.forwardIndicator_.classList.add(className);
          },
          removeClassFromForwardIndicator: function removeClassFromForwardIndicator(className) {
            return _this.forwardIndicator_.classList.remove(className);
          },
          addClassToBackIndicator: function addClassToBackIndicator(className) {
            return _this.backIndicator_.classList.add(className);
          },
          removeClassFromBackIndicator: function removeClassFromBackIndicator(className) {
            return _this.backIndicator_.classList.remove(className);
          },
          isRTL: function isRTL() {
            return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
          },
          registerBackIndicatorClickHandler: function registerBackIndicatorClickHandler(handler) {
            return _this.backIndicator_.addEventListener('click', handler);
          },
          deregisterBackIndicatorClickHandler: function deregisterBackIndicatorClickHandler(handler) {
            return _this.backIndicator_.removeEventListener('click', handler);
          },
          registerForwardIndicatorClickHandler: function registerForwardIndicatorClickHandler(handler) {
            return _this.forwardIndicator_.addEventListener('click', handler);
          },
          deregisterForwardIndicatorClickHandler: function deregisterForwardIndicatorClickHandler(handler) {
            return _this.forwardIndicator_.removeEventListener('click', handler);
          },
          registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
            return _this.root_.addEventListener(evt, handler, true);
          },
          deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
            return _this.root_.removeEventListener(evt, handler, true);
          },
          registerWindowResizeHandler: function registerWindowResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterWindowResizeHandler: function deregisterWindowResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          getNumberOfTabs: function getNumberOfTabs() {
            return _this.tabBar.tabs.length;
          },
          getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
            return _this.tabBar.tabs[index].computedWidth;
          },
          getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
            return _this.tabBar.tabs[index].computedLeft;
          },
          getOffsetWidthForScrollFrame: function getOffsetWidthForScrollFrame() {
            return _this.scrollFrame_.offsetWidth;
          },
          getScrollLeftForScrollFrame: function getScrollLeftForScrollFrame() {
            return _this.scrollFrame_.scrollLeft;
          },
          setScrollLeftForScrollFrame: function setScrollLeftForScrollFrame(scrollLeftAmount) {
            return _this.scrollFrame_.scrollLeft = scrollLeftAmount;
          },
          getOffsetWidthForTabBar: function getOffsetWidthForTabBar() {
            return _this.tabBarEl_.offsetWidth;
          },
          setTransformStyleForTabBar: function setTransformStyleForTabBar(value) {
            _this.tabBarEl_.style.setProperty(getCorrectPropertyName(window, 'transform'), value);
          },
          getOffsetLeftForEventTarget: function getOffsetLeftForEventTarget(target) {
            return target.offsetLeft;
          },
          getOffsetWidthForEventTarget: function getOffsetWidthForEventTarget(target) {
            return target.offsetWidth;
          }
        });
      }
    }, {
      key: "layout",
      value: function layout() {
        this.foundation_.layout();
      }
    }, {
      key: "tabBar",
      get: function get() {
        return this.tabBar_;
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCTabBarScroller(root);
      }
    }]);

    return MDCTabBarScroller;
  }(MDCComponent);

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var MdcTabIconText = /** @class */ (function () {
      function MdcTabIconText(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcTabIconText.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-tab-icon-text], mdc-tab-icon-text',
                      exportAs: 'mdcTabIconText'
                  },] },
      ];
      /** @nocollapse */
      MdcTabIconText.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcTabIconText.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab__icon-text',] }]
      };
      return MdcTabIconText;
  }());
  var MdcTab = /** @class */ (function () {
      function MdcTab(_changeDetectorRef, _renderer, elementRef, _registry, ripple$$1) {
          var _this = this;
          this._changeDetectorRef = _changeDetectorRef;
          this._renderer = _renderer;
          this.elementRef = elementRef;
          this._registry = _registry;
          this.ripple = ripple$$1;
          /**
           * Emits whenever the component is destroyed.
           */
          this._destroy = new rxjs.Subject();
          this._active = false;
          this._disabled = false;
          /**
           * Event emitted when the option is selected.
           */
          this.selected = new core.EventEmitter();
          this.isHostClass = true;
          this.role = 'tab';
          this._mdcAdapter = {
              addClass: function (className) {
                  _this._renderer.addClass(_this._getHostElement(), className);
              },
              removeClass: function (className) {
                  _this._renderer.removeClass(_this._getHostElement(), className);
              },
              registerInteractionHandler: function (type, handler) {
                  _this._registry.listen(type, handler, _this._getHostElement());
              },
              deregisterInteractionHandler: function (type, handler) {
                  _this._registry.unlisten(type, handler);
              },
              getOffsetWidth: function () { return _this._getHostElement().offsetWidth; },
              getOffsetLeft: function () { return _this._getHostElement().offsetLeft; },
              notifySelected: function () { return _this._emitSelectedEvent(); }
          };
          this._foundation = new MDCTabFoundation(this._mdcAdapter);
      }
      Object.defineProperty(MdcTab.prototype, "active", {
          get: /**
           * @return {?}
           */
          function () { return this._active; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setActive(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTab.prototype, "disabled", {
          get: /**
           * @return {?}
           */
          function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setDisabled(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTab.prototype, "classIconText", {
          get: /**
           * @return {?}
           */
          function () {
              return this.tabIcon != null && this.tabIconText != null;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTab.prototype, "classActive", {
          get: /**
           * @return {?}
           */
          function () {
              return this._active ? 'mdc-tab--active' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTab.prototype, "classDisabled", {
          get: /**
           * @return {?}
           */
          function () {
              return this._disabled ? 'ng-mdc-tab--disabled' : '';
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MdcTab.prototype.ngOnInit = /**
       * @return {?}
       */
      function () {
          var _this = this;
          this._foundation.init();
          this.setPreventDefaultOnClick(true);
          if (this.tabRouter) {
              this._routerChangeSubscription = this.tabRouter.routeChange
                  .pipe(operators.takeUntil(this._destroy))
                  .subscribe(function (_) {
                  _this.setActive(_.active);
                  _this._emitSelectedEvent();
              });
          }
      };
      /**
       * @return {?}
       */
      MdcTab.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._destroy.next();
          this._destroy.complete();
          this._foundation.destroy();
      };
      /**
       * @return {?}
       */
      MdcTab.prototype.isActive = /**
       * @return {?}
       */
      function () {
          return this._foundation.isActive();
      };
      /**
       * @param {?} active
       * @return {?}
       */
      MdcTab.prototype.setActive = /**
       * @param {?} active
       * @return {?}
       */
      function (active) {
          this._active = common.toBoolean(active);
          this._foundation.setActive(active);
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @param {?} disabled
       * @return {?}
       */
      MdcTab.prototype.setDisabled = /**
       * @param {?} disabled
       * @return {?}
       */
      function (disabled) {
          this._disabled = disabled;
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @return {?}
       */
      MdcTab.prototype.getComputedWidth = /**
       * @return {?}
       */
      function () {
          return this._foundation.getComputedWidth();
      };
      /**
       * @return {?}
       */
      MdcTab.prototype.getComputedLeft = /**
       * @return {?}
       */
      function () {
          return this._mdcAdapter.getOffsetLeft();
      };
      /**
       * @return {?}
       */
      MdcTab.prototype.getPreventDefaultOnClick = /**
       * @return {?}
       */
      function () {
          return this._foundation.preventsDefaultOnClick();
      };
      /**
       * @param {?} preventDefaultOnClick
       * @return {?}
       */
      MdcTab.prototype.setPreventDefaultOnClick = /**
       * @param {?} preventDefaultOnClick
       * @return {?}
       */
      function (preventDefaultOnClick) {
          this._foundation.setPreventDefaultOnClick(preventDefaultOnClick);
      };
      /**
       * @return {?}
       */
      MdcTab.prototype.measureSelf = /**
       * @return {?}
       */
      function () {
          this._foundation.measureSelf();
      };
      /**
       * Emits the tab selected event.
       * @return {?}
       */
      MdcTab.prototype._emitSelectedEvent = /**
       * Emits the tab selected event.
       * @return {?}
       */
      function () {
          this.selected.emit({ tab: this });
      };
      /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      MdcTab.prototype._getHostElement = /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      function () {
          return this.elementRef.nativeElement;
      };
      MdcTab.decorators = [
          { type: core.Component, args: [{selector: '[mdc-tab], mdc-tab',
                      exportAs: 'mdcTab',
                      template: '<ng-content></ng-content>',
                      providers: [
                          ripple.MdcRipple,
                          common.EventRegistry
                      ],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MdcTab.ctorParameters = function () { return [
          { type: core.ChangeDetectorRef },
          { type: core.Renderer2 },
          { type: core.ElementRef },
          { type: common.EventRegistry },
          { type: ripple.MdcRipple }
      ]; };
      MdcTab.propDecorators = {
          active: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          selected: [{ type: core.Output }],
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab',] }],
          role: [{ type: core.HostBinding, args: ['attr.role',] }],
          classIconText: [{ type: core.HostBinding, args: ['class.mdc-tab--with-icon-and-text',] }],
          classActive: [{ type: core.HostBinding, args: ['class.mdc-tab--active',] }],
          classDisabled: [{ type: core.HostBinding, args: ['class.ng-mdc-tab--disabled',] }],
          tabIcon: [{ type: core.ContentChild, args: [icon.MdcIcon,] }],
          tabIconText: [{ type: core.ContentChild, args: [MdcTabIconText,] }],
          tabRouter: [{ type: core.ContentChild, args: [common.MdcRouter,] }]
      };
      return MdcTab;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  /**
   * A simple change event emitted selection changes.
   */
  var   /**
   * A simple change event emitted selection changes.
   */
  MdcTabChangeEvent = /** @class */ (function () {
      function MdcTabChangeEvent(index, tab) {
          this.index = index;
          this.tab = tab;
      }
      return MdcTabChangeEvent;
  }());
  var MdcTabBarIndicator = /** @class */ (function () {
      function MdcTabBarIndicator(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcTabBarIndicator.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-tab-bar-indicator], mdc-tab-bar-indicator',
                      exportAs: 'mdcTabBarIndicator'
                  },] },
      ];
      /** @nocollapse */
      MdcTabBarIndicator.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcTabBarIndicator.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar__indicator',] }]
      };
      return MdcTabBarIndicator;
  }());
  var MdcTabBar = /** @class */ (function () {
      function MdcTabBar(_ngZone, _changeDetectorRef, _renderer, elementRef, _registry) {
          var _this = this;
          this._ngZone = _ngZone;
          this._changeDetectorRef = _changeDetectorRef;
          this._renderer = _renderer;
          this.elementRef = elementRef;
          this._registry = _registry;
          /**
           * Emits whenever the component is destroyed.
           */
          this._destroy = new rxjs.Subject();
          this._disableRipple = false;
          this._primary = false;
          this._secondary = false;
          /**
           * The tab index that should be selected after the content has been checked.
           */
          this._indexToSelect = 0;
          this._selectedIndex = null;
          /**
           * Event emitted when the tab selection has changed.
           */
          this.selectedTabChange = new core.EventEmitter(true);
          /**
           * Event emitted when tabs are added or removed.
           */
          this.tabsChangeEvent = new core.EventEmitter();
          this.isHostClass = true;
          this.scrollFrameContent = false;
          this.role = 'tablist';
          /**
           * Combined stream of all of the tab change events.
           */
          this.optionSelectionChanges = rxjs.defer(function () {
              if (_this.tabs) {
                  return rxjs.merge.apply(void 0, _this.tabs.map(function (option) { return option.selected; }));
              }
              return _this._ngZone.onStable
                  .asObservable()
                  .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelectionChanges; }));
          });
          this._mdcAdapter = {
              addClass: function (className) {
                  _this._renderer.addClass(_this.elementRef.nativeElement, className);
              },
              removeClass: function (className) {
                  _this._renderer.removeClass(_this.elementRef.nativeElement, className);
              },
              bindOnMDCTabSelectedEvent: function () {
                  var /** @type {?} */ changedOrDestroyed = rxjs.merge(_this.tabs.changes, _this._destroy);
                  _this.optionSelectionChanges
                      .pipe(operators.takeUntil(changedOrDestroyed)).subscribe(function (event) {
                      if (event.tab.disabled) {
                          return;
                      }
                      _this.setActiveTab(event.tab, true);
                      _this._foundation.switchToTabAtIndex(_this.getActiveTabIndex(), true);
                      _this.selectedTabChange.emit(new MdcTabChangeEvent(_this.getActiveTabIndex(), event.tab));
                  });
              },
              unbindOnMDCTabSelectedEvent: function () {
                  /* not needed */
              },
              registerResizeHandler: function (handler) {
                  if (common.isBrowser()) {
                      _this._registry.listen('resize', handler, window);
                  }
              },
              deregisterResizeHandler: function (handler) {
                  if (common.isBrowser()) {
                      _this._registry.unlisten('resize', handler);
                  }
              },
              getOffsetWidth: function () { return _this.elementRef.nativeElement.offsetWidth; },
              setStyleForIndicator: function (propertyName, value) {
                  return _this._renderer.setStyle(_this.indicator.elementRef.nativeElement, propertyName, value);
              },
              getOffsetWidthForIndicator: function () { return _this.indicator.elementRef.nativeElement.offsetWidth; },
              notifyChange: function (evtData) {
                  _this.selectedTabChange.emit(new MdcTabChangeEvent(evtData.activeTabIndex, _this.getActiveTab()));
              },
              getNumberOfTabs: function () { return _this.tabs.length; },
              isTabActiveAtIndex: function (index) { return _this.tabs.toArray()[index].isActive(); },
              setTabActiveAtIndex: function (index, isActive) { return _this.tabs.toArray()[index].setActive(isActive); },
              isDefaultPreventedOnClickForTabAtIndex: function (index) { return !!_this.tabs.toArray()[index].getPreventDefaultOnClick(); },
              setPreventDefaultOnClickForTabAtIndex: function (index, preventDefaultOnClick) {
                  return _this.tabs.toArray()[index].setPreventDefaultOnClick(preventDefaultOnClick);
              },
              measureTabAtIndex: function (index) { return _this.tabs.toArray()[index].measureSelf(); },
              getComputedWidthForTabAtIndex: function (index) {
                  return _this.tabs.length ? _this.tabs.toArray()[index].getComputedWidth() : -1;
              },
              getComputedLeftForTabAtIndex: function (index) {
                  return _this.tabs.length ? _this.tabs.toArray()[index].getComputedLeft() : -1;
              }
          };
          this._foundation = new MDCTabBarFoundation(this._mdcAdapter);
      }
      Object.defineProperty(MdcTabBar.prototype, "selectedIndex", {
          get: /**
           * @return {?}
           */
          function () { return this._selectedIndex; },
          /** The index of the active tab. */
          set: /**
           * The index of the active tab.
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._indexToSelect = common.toNumber(value, null);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTabBar.prototype, "primary", {
          get: /**
           * @return {?}
           */
          function () { return this._primary; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._primary = common.toBoolean(value);
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTabBar.prototype, "secondary", {
          get: /**
           * @return {?}
           */
          function () { return this._secondary; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._secondary = common.toBoolean(value);
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTabBar.prototype, "disableRipple", {
          get: /**
           * @return {?}
           */
          function () { return this._disableRipple; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setDisableRipple(value);
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTabBar.prototype, "classTabIcon", {
          get: /**
           * @return {?}
           */
          function () {
              return this.tabs.length > 0
                  && this.tabs.first.tabIcon != null
                  && this.tabs.first.tabIconText == null ? 'mdc-tab-bar--icon-tab-bar' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTabBar.prototype, "classTabIconText", {
          get: /**
           * @return {?}
           */
          function () {
              return this.tabs.length > 0
                  && this.tabs.first.tabIcon != null
                  && this.tabs.first.tabIconText != null ? 'mdc-tab-bar--icons-with-text' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTabBar.prototype, "classPrimary", {
          get: /**
           * @return {?}
           */
          function () {
              return this.primary ? 'ng-mdc-tab--primary' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcTabBar.prototype, "classSecondary", {
          get: /**
           * @return {?}
           */
          function () {
              return this.secondary ? 'ng-mdc-tab--secondary' : '';
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MdcTabBar.prototype.ngAfterContentInit = /**
       * @return {?}
       */
      function () {
          var _this = this;
          // Subscribe to changes in the amount of tabs, in order to be
          // able to re-render the content as new tabs are added or removed.
          this.tabs.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
              _this._foundation.init();
              _this._initializeSelection();
              _this.setDisableRipple(_this.disableRipple);
              _this._foundation.layout();
              _this.tabsChangeEvent.emit();
          });
      };
      /**
       * @return {?}
       */
      MdcTabBar.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._destroy.next();
          this._destroy.complete();
          this._foundation.destroy();
      };
      /**
       * @return {?}
       */
      MdcTabBar.prototype._initializeSelection = /**
       * @return {?}
       */
      function () {
          var _this = this;
          // Defer setting the value in order to avoid the "Expression
          // has changed after it was checked" errors from Angular.
          Promise.resolve().then(function () {
              if (_this.getActiveTabIndex() < 0 && _this.tabs.first) {
                  _this.tabs.first.setActive(true);
              }
          });
      };
      /**
       * @param {?} disabled
       * @return {?}
       */
      MdcTabBar.prototype.setDisableRipple = /**
       * @param {?} disabled
       * @return {?}
       */
      function (disabled) {
          if (!this.tabs) {
              return;
          }
          if (this._disableRipple !== disabled) {
              this._disableRipple = disabled;
          }
          this.tabs.forEach(function (tab) {
              disabled ? tab.ripple.destroy() : tab.ripple.attachTo(tab.elementRef.nativeElement);
          });
      };
      /**
       * @param {?} index
       * @return {?}
       */
      MdcTabBar.prototype.setTabActiveAtIndex = /**
       * @param {?} index
       * @return {?}
       */
      function (index) {
          if (this.tabs.toArray()[index].disabled) {
              return;
          }
          this._foundation.switchToTabAtIndex(index, true);
          this._mdcAdapter.setTabActiveAtIndex(index, true);
      };
      /**
       * @return {?}
       */
      MdcTabBar.prototype.getActiveTabIndex = /**
       * @return {?}
       */
      function () {
          return this._foundation.getActiveTabIndex();
      };
      /**
       * @return {?}
       */
      MdcTabBar.prototype.getActiveTab = /**
       * @return {?}
       */
      function () {
          var /** @type {?} */ tab = this.tabs.find(function (_) { return _.isActive(); });
          return tab ? tab[0] : null;
      };
      /**
       * @param {?} tab
       * @param {?} active
       * @return {?}
       */
      MdcTabBar.prototype.setActiveTab = /**
       * @param {?} tab
       * @param {?} active
       * @return {?}
       */
      function (tab, active) {
          this.tabs.forEach(function (_) {
              _.setActive(false);
          }); /** @type {?} */
          ((this.tabs.find(function (_) { return _ === tab; }))).setActive(active);
      };
      /**
       * @return {?}
       */
      MdcTabBar.prototype.layout = /**
       * @return {?}
       */
      function () {
          this._foundation.layout();
      };
      /**
       * @return {?}
       */
      MdcTabBar.prototype.getNumberOfTabs = /**
       * @return {?}
       */
      function () {
          return this._mdcAdapter.getNumberOfTabs();
      };
      /**
       * @return {?}
       */
      MdcTabBar.prototype.getComputedWidth = /**
       * @return {?}
       */
      function () {
          return this._mdcAdapter.getOffsetWidth();
      };
      /**
       * @param {?} index
       * @param {?} preventDefaultOnClick
       * @return {?}
       */
      MdcTabBar.prototype.setPreventDefaultOnClickForTabAtIndex = /**
       * @param {?} index
       * @param {?} preventDefaultOnClick
       * @return {?}
       */
      function (index, preventDefaultOnClick) {
          this._mdcAdapter.setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick);
      };
      /**
       * @param {?} index
       * @return {?}
       */
      MdcTabBar.prototype.isDefaultPreventedOnClickForTabAtIndex = /**
       * @param {?} index
       * @return {?}
       */
      function (index) {
          return this._mdcAdapter.isDefaultPreventedOnClickForTabAtIndex(index);
      };
      MdcTabBar.decorators = [
          { type: core.Component, args: [{selector: '[mdc-tab-bar], mdc-tab-bar',
                      exportAs: 'mdcTabBar',
                      template: "\n  <ng-content></ng-content>\n  <mdc-tab-bar-indicator></mdc-tab-bar-indicator>\n  ",
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      providers: [common.EventRegistry]
                  },] },
      ];
      /** @nocollapse */
      MdcTabBar.ctorParameters = function () { return [
          { type: core.NgZone },
          { type: core.ChangeDetectorRef },
          { type: core.Renderer2 },
          { type: core.ElementRef },
          { type: common.EventRegistry }
      ]; };
      MdcTabBar.propDecorators = {
          selectedIndex: [{ type: core.Input }],
          primary: [{ type: core.Input }],
          secondary: [{ type: core.Input }],
          disableRipple: [{ type: core.Input }],
          selectedTabChange: [{ type: core.Output }],
          tabsChangeEvent: [{ type: core.Output }],
          tabs: [{ type: core.ContentChildren, args: [MdcTab,] }],
          indicator: [{ type: core.ViewChild, args: [MdcTabBarIndicator,] }],
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar',] }],
          scrollFrameContent: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__scroll-frame__tabs',] }],
          role: [{ type: core.HostBinding, args: ['attr.role',] }],
          classTabIcon: [{ type: core.HostBinding, args: ['class.mdc-tab-bar--icon-tab-bar',] }],
          classTabIconText: [{ type: core.HostBinding, args: ['class.mdc-tab-bar--icons-with-text',] }],
          classPrimary: [{ type: core.HostBinding, args: ['class.ng-mdc-tab--primary',] }],
          classSecondary: [{ type: core.HostBinding, args: ['class.ng-mdc-tab--secondary',] }]
      };
      return MdcTabBar;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var MdcTabBarScrollBack = /** @class */ (function () {
      function MdcTabBarScrollBack(_renderer, elementRef) {
          this._renderer = _renderer;
          this.elementRef = elementRef;
          this.isHostClass = true;
          this.isBackClass = true;
      }
      /**
       * @return {?}
       */
      MdcTabBarScrollBack.prototype.ngAfterContentInit = /**
       * @return {?}
       */
      function () {
          if (this.icon) {
              this._renderer.addClass(this.icon.elementRef.nativeElement, 'mdc-tab-bar-scroller__indicator__inner');
          }
      };
      MdcTabBarScrollBack.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-tab-bar-scroll-back], mdc-tab-bar-scroll-back',
                      exportAs: 'mdcTabBarScrollBack'
                  },] },
      ];
      /** @nocollapse */
      MdcTabBarScrollBack.ctorParameters = function () { return [
          { type: core.Renderer2 },
          { type: core.ElementRef }
      ]; };
      MdcTabBarScrollBack.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__indicator',] }],
          isBackClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__indicator--back',] }],
          icon: [{ type: core.ContentChild, args: [icon.MdcIcon,] }]
      };
      return MdcTabBarScrollBack;
  }());
  var MdcTabBarScrollForward = /** @class */ (function () {
      function MdcTabBarScrollForward(_renderer, elementRef) {
          this._renderer = _renderer;
          this.elementRef = elementRef;
          this.isHostClass = true;
          this.isForwardClass = true;
      }
      /**
       * @return {?}
       */
      MdcTabBarScrollForward.prototype.ngAfterContentInit = /**
       * @return {?}
       */
      function () {
          if (this.icon) {
              this._renderer.addClass(this.icon.elementRef.nativeElement, 'mdc-tab-bar-scroller__indicator__inner');
          }
      };
      MdcTabBarScrollForward.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-tab-bar-scroll-forward], mdc-tab-bar-scroll-forward',
                      exportAs: 'mdcTabBarScrollForward'
                  },] },
      ];
      /** @nocollapse */
      MdcTabBarScrollForward.ctorParameters = function () { return [
          { type: core.Renderer2 },
          { type: core.ElementRef }
      ]; };
      MdcTabBarScrollForward.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__indicator',] }],
          isForwardClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__indicator--forward',] }],
          icon: [{ type: core.ContentChild, args: [icon.MdcIcon,] }]
      };
      return MdcTabBarScrollForward;
  }());
  var MdcTabBarScrollFrame = /** @class */ (function () {
      function MdcTabBarScrollFrame(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      /**
       * @return {?}
       */
      MdcTabBarScrollFrame.prototype.ngAfterContentInit = /**
       * @return {?}
       */
      function () {
          if (this.tabBar) {
              this.tabBar.scrollFrameContent = true;
          }
      };
      /**
       * @param {?} index
       * @return {?}
       */
      MdcTabBarScrollFrame.prototype.findTab = /**
       * @param {?} index
       * @return {?}
       */
      function (index) {
          return this.tabBar.tabs.toArray()[index];
      };
      MdcTabBarScrollFrame.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-tab-bar-scroll-frame], mdc-tab-bar-scroll-frame',
                      exportAs: 'mdcTabBarScrollFrame'
                  },] },
      ];
      /** @nocollapse */
      MdcTabBarScrollFrame.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcTabBarScrollFrame.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__scroll-frame',] }],
          tabBar: [{ type: core.ContentChild, args: [MdcTabBar,] }]
      };
      return MdcTabBarScrollFrame;
  }());
  var MdcTabBarScroller = /** @class */ (function () {
      function MdcTabBarScroller(_renderer, elementRef, _registry) {
          var _this = this;
          this._renderer = _renderer;
          this.elementRef = elementRef;
          this._registry = _registry;
          this.direction = 'ltr';
          this.isHostClass = true;
          this._mdcAdapter = {
              addClass: function (className) {
                  _this._renderer.addClass(_this.elementRef.nativeElement, className);
              },
              removeClass: function (className) {
                  _this._renderer.removeClass(_this.elementRef.nativeElement, className);
              },
              eventTargetHasClass: function (target, className) { return target.classList.contains(className); },
              addClassToForwardIndicator: function (className) {
                  if (_this.scrollForward) {
                      _this._renderer.addClass(_this.forward.elementRef.nativeElement, className);
                  }
              },
              removeClassFromForwardIndicator: function (className) {
                  if (_this.scrollForward) {
                      _this._renderer.removeClass(_this.forward.elementRef.nativeElement, className);
                  }
              },
              addClassToBackIndicator: function (className) {
                  if (_this.scrollBack) {
                      _this._renderer.addClass(_this.back.elementRef.nativeElement, className);
                  }
              },
              removeClassFromBackIndicator: function (className) {
                  if (_this.scrollBack) {
                      _this._renderer.removeClass(_this.back.elementRef.nativeElement, className);
                  }
              },
              isRTL: function () { return _this.direction === 'rtl'; },
              registerBackIndicatorClickHandler: function (handler) {
                  if (_this.scrollBack) {
                      _this._registry.listen('click', handler, _this.back.elementRef.nativeElement);
                  }
              },
              deregisterBackIndicatorClickHandler: function (handler) {
                  if (_this.scrollBack) {
                      _this._registry.unlisten('click', handler);
                  }
              },
              registerForwardIndicatorClickHandler: function (handler) {
                  if (_this.scrollForward) {
                      _this._registry.listen('click', handler, _this.forward.elementRef.nativeElement);
                  }
              },
              deregisterForwardIndicatorClickHandler: function (handler) {
                  if (_this.scrollForward) {
                      _this._registry.unlisten('click', handler);
                  }
              },
              registerCapturedInteractionHandler: function (evt, handler) {
                  _this._registry.listen(evt, handler, _this.elementRef.nativeElement);
              },
              deregisterCapturedInteractionHandler: function (evt, handler) {
                  _this._registry.unlisten(evt, handler);
              },
              registerWindowResizeHandler: function (handler) {
                  if (common.isBrowser()) {
                      _this._registry.listen('resize', handler, window);
                  }
              },
              deregisterWindowResizeHandler: function (handler) {
                  if (common.isBrowser()) {
                      _this._registry.unlisten('resize', handler);
                  }
              },
              getNumberOfTabs: function () {
                  return (_this.scrollFrame && _this.scrollFrame.tabBar) ? _this.scrollFrame.tabBar.tabs.length : 0;
              },
              getComputedWidthForTabAtIndex: function (index) { return _this.scrollFrame.findTab(index).getComputedWidth(); },
              getComputedLeftForTabAtIndex: function (index) { return _this.scrollFrame.findTab(index).getComputedLeft(); },
              getOffsetWidthForScrollFrame: function () {
                  return _this.scrollFrame ? _this.scrollFrame.elementRef.nativeElement.offsetWidth : 0;
              },
              getScrollLeftForScrollFrame: function () {
                  return _this.scrollFrame ? _this.scrollFrame.elementRef.nativeElement.scrollLeft : 0;
              },
              setScrollLeftForScrollFrame: function (scrollLeftAmount) {
                  if (_this.scrollFrame) {
                      _this._renderer.setProperty(_this.scrollFrame.elementRef.nativeElement, 'scrollLeft', scrollLeftAmount);
                  }
              },
              getOffsetWidthForTabBar: function () {
                  return (_this.scrollFrame && _this.scrollFrame.tabBar) ? _this.scrollFrame.tabBar.elementRef.nativeElement.offsetWidth : 0;
              },
              setTransformStyleForTabBar: function (value) {
                  if (_this.scrollFrame && _this.scrollFrame.tabBar) {
                      _this._renderer.setStyle(_this.scrollFrame.tabBar.elementRef.nativeElement, getCorrectPropertyName(window, 'transform'), value);
                  }
              },
              getOffsetLeftForEventTarget: function (target) { return target.offsetLeft; },
              getOffsetWidthForEventTarget: function (target) { return target.offsetWidth; }
          };
          this._foundation = new MDCTabBarScrollerFoundation(this._mdcAdapter);
      }
      /**
       * @return {?}
       */
      MdcTabBarScroller.prototype.ngAfterViewInit = /**
       * @return {?}
       */
      function () {
          this._foundation.init();
      };
      /**
       * @return {?}
       */
      MdcTabBarScroller.prototype.ngAfterContentInit = /**
       * @return {?}
       */
      function () {
          var _this = this;
          this._tabBarChangeSubscription = this.scrollFrame.tabBar.tabsChangeEvent.subscribe(function () {
              _this.layout();
          });
      };
      /**
       * @return {?}
       */
      MdcTabBarScroller.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          if (this._tabBarChangeSubscription) {
              this._tabBarChangeSubscription.unsubscribe();
              this._tabBarChangeSubscription = null;
          }
          this._foundation.destroy();
      };
      /**
       * @param {?} index
       * @return {?}
       */
      MdcTabBarScroller.prototype.scrollToTabAtIndex = /**
       * @param {?} index
       * @return {?}
       */
      function (index) {
          this._foundation.scrollToTabAtIndex(index);
      };
      /**
       * @return {?}
       */
      MdcTabBarScroller.prototype.layout = /**
       * @return {?}
       */
      function () {
          this._foundation.layout();
      };
      /**
       * @param {?=} event
       * @return {?}
       */
      MdcTabBarScroller.prototype.scrollBack = /**
       * @param {?=} event
       * @return {?}
       */
      function (event) {
          this._foundation.scrollBack(event);
      };
      /**
       * @param {?=} event
       * @return {?}
       */
      MdcTabBarScroller.prototype.scrollForward = /**
       * @param {?=} event
       * @return {?}
       */
      function (event) {
          this._foundation.scrollForward(event);
      };
      MdcTabBarScroller.decorators = [
          { type: core.Component, args: [{selector: '[mdc-tab-bar-scroller], mdc-tab-bar-scroller',
                      exportAs: 'mdcTabBarScroller',
                      template: '<ng-content></ng-content>',
                      providers: [common.EventRegistry],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MdcTabBarScroller.ctorParameters = function () { return [
          { type: core.Renderer2 },
          { type: core.ElementRef },
          { type: common.EventRegistry }
      ]; };
      MdcTabBarScroller.propDecorators = {
          direction: [{ type: core.Input }],
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller',] }],
          scrollFrame: [{ type: core.ContentChild, args: [MdcTabBarScrollFrame,] }],
          back: [{ type: core.ContentChild, args: [MdcTabBarScrollBack,] }],
          forward: [{ type: core.ContentChild, args: [MdcTabBarScrollForward,] }]
      };
      return MdcTabBarScroller;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var /** @type {?} */ TAB_DECLARATIONS = [
      MdcTab,
      MdcTabIconText,
      MdcTabBar,
      MdcTabBarIndicator,
      MdcTabBarScroller,
      MdcTabBarScrollBack,
      MdcTabBarScrollForward,
      MdcTabBarScrollFrame,
  ];
  var MdcTabModule = /** @class */ (function () {
      function MdcTabModule() {
      }
      MdcTabModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.MdcRouterModule],
                      exports: [
                          common.MdcRouterModule,
                          TAB_DECLARATIONS
                      ],
                      declarations: [
                          TAB_DECLARATIONS
                      ]
                  },] },
      ];
      return MdcTabModule;
  }());

  exports.MdcTabModule = MdcTabModule;
  exports.MdcTabIconText = MdcTabIconText;
  exports.MdcTab = MdcTab;
  exports.MdcTabChangeEvent = MdcTabChangeEvent;
  exports.MdcTabBarIndicator = MdcTabBarIndicator;
  exports.MdcTabBar = MdcTabBar;
  exports.MdcTabBarScrollBack = MdcTabBarScrollBack;
  exports.MdcTabBarScrollForward = MdcTabBarScrollForward;
  exports.MdcTabBarScrollFrame = MdcTabBarScrollFrame;
  exports.MdcTabBarScroller = MdcTabBarScroller;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
