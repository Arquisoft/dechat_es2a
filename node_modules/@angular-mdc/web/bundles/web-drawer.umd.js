/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular-mdc/web/common')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/drawer', ['exports', '@angular/core', '@angular-mdc/web/common'], factory) :
  (factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.drawer = {}),global.ng.core,global.ng.web.common));
}(this, (function (exports,core,common) { 'use strict';

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var MdcDrawerSpacer = /** @class */ (function () {
      function MdcDrawerSpacer(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcDrawerSpacer.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-drawer-spacer], mdc-drawer-spacer',
                      exportAs: 'mdcDrawerSpace'
                  },] },
      ];
      /** @nocollapse */
      MdcDrawerSpacer.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcDrawerSpacer.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__toolbar-spacer',] }]
      };
      return MdcDrawerSpacer;
  }());
  var MdcDrawerHeader = /** @class */ (function () {
      function MdcDrawerHeader(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcDrawerHeader.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-drawer-header], mdc-drawer-header',
                      exportAs: 'mdcDrawerHeader'
                  },] },
      ];
      /** @nocollapse */
      MdcDrawerHeader.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcDrawerHeader.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__header',] }]
      };
      return MdcDrawerHeader;
  }());
  var MdcDrawerHeaderContent = /** @class */ (function () {
      function MdcDrawerHeaderContent(elementRef) {
          this.elementRef = elementRef;
          this.primary = true;
          this.isHostClass = true;
      }
      Object.defineProperty(MdcDrawerHeaderContent.prototype, "classPrimaryBackground", {
          get: /**
           * @return {?}
           */
          function () {
              return this.primary ? 'mdc-theme--primary-bg' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcDrawerHeaderContent.prototype, "classPrimaryOnPrimary", {
          get: /**
           * @return {?}
           */
          function () {
              return this.primary ? 'mdc-theme--text-primary-on-primary' : '';
          },
          enumerable: true,
          configurable: true
      });
      MdcDrawerHeaderContent.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-drawer-header-content], mdc-drawer-header-content',
                      exportAs: 'mdcDrawerHeaderContent'
                  },] },
      ];
      /** @nocollapse */
      MdcDrawerHeaderContent.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcDrawerHeaderContent.propDecorators = {
          primary: [{ type: core.Input }],
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__header-content',] }],
          classPrimaryBackground: [{ type: core.HostBinding, args: ['class.mdc-theme--primary-bg',] }],
          classPrimaryOnPrimary: [{ type: core.HostBinding, args: ['class.mdc-theme--text-primary-on-primary',] }]
      };
      return MdcDrawerHeaderContent;
  }());
  var MdcDrawerContent = /** @class */ (function () {
      function MdcDrawerContent(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcDrawerContent.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdc-drawer-content], mdc-drawer-content',
                      exportAs: 'mdcDrawerContent'
                  },] },
      ];
      /** @nocollapse */
      MdcDrawerContent.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcDrawerContent.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__content',] }]
      };
      return MdcDrawerContent;
  }());
  var MdcDrawerNavigation = /** @class */ (function () {
      function MdcDrawerNavigation(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
          this.role = 'navigation';
      }
      MdcDrawerNavigation.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mdc-drawer-navigation',
                      exportAs: 'mdcDrawerNavigation'
                  },] },
      ];
      /** @nocollapse */
      MdcDrawerNavigation.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcDrawerNavigation.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__drawer',] }],
          role: [{ type: core.HostBinding, args: ['attr.role',] }]
      };
      return MdcDrawerNavigation;
  }());

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var TAB_DATA = 'data-mdc-tabindex';
  var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';
  var storedTransformPropertyName_;
  var supportsPassive_; // Remap touch events to pointer events, if the browser doesn't support touch events.

  function remapEvent(eventName) {
    var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

    if (!('ontouchstart' in globalObj.document)) {
      switch (eventName) {
        case 'touchstart':
          return 'pointerdown';

        case 'touchmove':
          return 'pointermove';

        case 'touchend':
          return 'pointerup';

        default:
          return eventName;
      }
    }

    return eventName;
  } // Choose the correct transform property to use on the current browser.

  function getTransformPropertyName() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_ === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
      storedTransformPropertyName_ = transformPropertyName;
    }

    return storedTransformPropertyName_;
  } // Determine whether the current browser supports CSS properties.

  function supportsCssCustomProperties() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

    if ('CSS' in globalObj) {
      return globalObj.CSS.supports('(--color: red)');
    }

    return false;
  } // Determine whether the current browser supports passive event listeners, and if so, use them.

  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;

      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = true;
          }

        });
      } catch (e) {}

      supportsPassive_ = isSupported;
    }

    return supportsPassive_ ? {
      passive: true
    } : false;
  } // Save the tab state for an element.

  function saveElementTabState(el) {
    if (el.hasAttribute('tabindex')) {
      el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
    }

    el.setAttribute(TAB_DATA_HANDLED, true);
  } // Restore the tab state for an element, if it was saved.

  function restoreElementTabState(el) {
    // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
    if (el.hasAttribute(TAB_DATA_HANDLED)) {
      if (el.hasAttribute(TAB_DATA)) {
        el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
        el.removeAttribute(TAB_DATA);
      } else {
        el.removeAttribute('tabindex');
      }

      el.removeAttribute(TAB_DATA_HANDLED);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return _get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

  var MDCSlidableDrawerFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSlidableDrawerFoundation, _MDCFoundation);

    _createClass(MDCSlidableDrawerFoundation, null, [{
      key: "defaultAdapter",
      get: function get() {
        return {
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          hasClass: function hasClass()
          /* className: string */
          {},
          hasNecessaryDom: function hasNecessaryDom() {
            return (
              /* boolean */
              false
            );
          },
          registerInteractionHandler: function registerInteractionHandler()
          /* evt: string, handler: EventListener */
          {},
          deregisterInteractionHandler: function deregisterInteractionHandler()
          /* evt: string, handler: EventListener */
          {},
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler()
          /* evt: string, handler: EventListener */
          {},
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler()
          /* evt: string, handler: EventListener */
          {},
          registerTransitionEndHandler: function registerTransitionEndHandler()
          /* handler: EventListener */
          {},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler()
          /* handler: EventListener */
          {},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler()
          /* handler: EventListener */
          {},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler()
          /* handler: EventListener */
          {},
          setTranslateX: function setTranslateX()
          /* value: number | null */
          {},
          getFocusableElements: function getFocusableElements()
          /* NodeList */
          {},
          saveElementTabState: function saveElementTabState()
          /* el: Element */
          {},
          restoreElementTabState: function restoreElementTabState()
          /* el: Element */
          {},
          makeElementUntabbable: function makeElementUntabbable()
          /* el: Element */
          {},
          notifyOpen: function notifyOpen() {},
          notifyClose: function notifyClose() {},
          isRtl: function isRtl() {
            return (
              /* boolean */
              false
            );
          },
          getDrawerWidth: function getDrawerWidth() {
            return (
              /* number */
              0
            );
          }
        };
      }
    }]);

    function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
      var _this;

      _classCallCheck(this, MDCSlidableDrawerFoundation);

      _this = _possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));
      _this.rootCssClass_ = rootCssClass;
      _this.animatingCssClass_ = animatingCssClass;
      _this.openCssClass_ = openCssClass;

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };

      _this.inert_ = false;

      _this.componentTouchStartHandler_ = function (evt) {
        return _this.handleTouchStart_(evt);
      };

      _this.componentTouchMoveHandler_ = function (evt) {
        return _this.handleTouchMove_(evt);
      };

      _this.componentTouchEndHandler_ = function (evt) {
        return _this.handleTouchEnd_(evt);
      };

      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.close();
        }
      };

      return _this;
    }

    _createClass(MDCSlidableDrawerFoundation, [{
      key: "init",
      value: function init() {
        var ROOT = this.rootCssClass_;
        var OPEN = this.openCssClass_;

        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error("".concat(ROOT, " class required in root element."));
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error("Required DOM nodes missing in ".concat(ROOT, " component."));
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        } else {
          this.detabinate_();
          this.isOpen_ = false;
        }

        this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_); // Deregister the document keydown handler just in case the component is destroyed while the menu is open.

        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      }
    }, {
      key: "open",
      value: function open() {
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.addClass(this.openCssClass_);
        this.retabinate_(); // Debounce multiple calls

        if (!this.isOpen_) {
          this.adapter_.notifyOpen();
        }

        this.isOpen_ = true;
      }
    }, {
      key: "close",
      value: function close() {
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.removeClass(this.openCssClass_);
        this.detabinate_(); // Debounce multiple calls

        if (this.isOpen_) {
          this.adapter_.notifyClose();
        }

        this.isOpen_ = false;
      }
    }, {
      key: "isOpen",
      value: function isOpen() {
        return this.isOpen_;
      }
      /**
       *  Render all children of the drawer inert when it's closed.
       */

    }, {
      key: "detabinate_",
      value: function detabinate_() {
        if (this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();

        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.saveElementTabState(elements[i]);
            this.adapter_.makeElementUntabbable(elements[i]);
          }
        }

        this.inert_ = true;
      }
      /**
       *  Make all children of the drawer tabbable again when it's open.
       */

    }, {
      key: "retabinate_",
      value: function retabinate_() {
        if (!this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();

        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.restoreElementTabState(elements[i]);
          }
        }

        this.inert_ = false;
      }
    }, {
      key: "handleTouchStart_",
      value: function handleTouchStart_(evt) {
        if (!this.adapter_.hasClass(this.openCssClass_)) {
          return;
        }

        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.direction_ = this.adapter_.isRtl() ? -1 : 1;
        this.drawerWidth_ = this.adapter_.getDrawerWidth();
        this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
        this.currentX_ = this.startX_;
        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
      }
    }, {
      key: "handleTouchMove_",
      value: function handleTouchMove_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
      }
    }, {
      key: "handleTouchEnd_",
      value: function handleTouchEnd_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.prepareForTouchEnd_(); // Did the user close the drawer by more than 50%?

        if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
          this.close();
        } else {
          // Triggering an open here means we'll get a nice animation back to the fully open state.
          this.open();
        }
      }
    }, {
      key: "prepareForTouchEnd_",
      value: function prepareForTouchEnd_() {
        cancelAnimationFrame(this.updateRaf_);
        this.adapter_.setTranslateX(null);
      }
    }, {
      key: "updateDrawer_",
      value: function updateDrawer_() {
        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
        this.adapter_.setTranslateX(this.newPosition_);
      }
    }, {
      key: "isRootTransitioningEventTarget_",
      value: function isRootTransitioningEventTarget_() {
        // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
        // if the event target is the root event target currently transitioning.
        return false;
      }
    }, {
      key: "handleTransitionEnd_",
      value: function handleTransitionEnd_(evt) {
        if (this.isRootTransitioningEventTarget_(evt.target)) {
          this.adapter_.removeClass(this.animatingCssClass_);
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        }
      }
    }, {
      key: "newPosition_",
      get: function get() {
        var newPos = null;

        if (this.direction_ === 1) {
          newPos = Math.min(0, this.currentX_ - this.startX_);
        } else {
          newPos = Math.max(0, this.currentX_ - this.startX_);
        }

        return newPos;
      }
    }]);

    return MDCSlidableDrawerFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses = {
    ROOT: 'mdc-drawer--temporary',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating',
    SCROLL_LOCK: 'mdc-drawer-scroll-lock'
  };
  var strings = {
    DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
    OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCTemporaryDrawer:open',
    CLOSE_EVENT: 'MDCTemporaryDrawer:close'
  };

  var MDCTemporaryDrawerFoundation =
  /*#__PURE__*/
  function (_MDCSlidableDrawerFou) {
    _inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);

    _createClass(MDCTemporaryDrawerFoundation, null, [{
      key: "cssClasses",
      get: function get$$1() {
        return cssClasses;
      }
    }, {
      key: "strings",
      get: function get$$1() {
        return strings;
      }
    }, {
      key: "defaultAdapter",
      get: function get$$1() {
        return Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, {
          addBodyClass: function addBodyClass()
          /* className: string */
          {},
          removeBodyClass: function removeBodyClass()
          /* className: string */
          {},
          isDrawer: function isDrawer() {
            return false;
          },
          updateCssVariable: function updateCssVariable()
          /* value: string */
          {},
          eventTargetHasClass: function eventTargetHasClass() {
            return (
              /* target: EventTarget, className: string */

              /* boolean */
              false
            );
          }
        });
      }
    }]);

    function MDCTemporaryDrawerFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCTemporaryDrawerFoundation);

      _this = _possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, Object.assign(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses.ROOT)) {
          _this.close(true);
        }
      };

      return _this;
    }

    _createClass(MDCTemporaryDrawerFoundation, [{
      key: "init",
      value: function init() {
        _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), "init", this).call(this); // Make browser aware of custom property being used in this element.
        // Workaround for certain types of hard-to-reproduce heisenbugs.


        this.adapter_.updateCssVariable(0);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), "destroy", this).call(this);

        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.enableScroll_();
      }
    }, {
      key: "open",
      value: function open() {
        this.disableScroll_(); // Make sure custom property values are cleared before starting.

        this.adapter_.updateCssVariable('');

        _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), "open", this).call(this);
      }
    }, {
      key: "close",
      value: function close() {
        // Make sure custom property values are cleared before making any changes.
        this.adapter_.updateCssVariable('');

        _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), "close", this).call(this);
      }
    }, {
      key: "prepareForTouchEnd_",
      value: function prepareForTouchEnd_() {
        _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), "prepareForTouchEnd_", this).call(this);

        this.adapter_.updateCssVariable('');
      }
    }, {
      key: "updateDrawer_",
      value: function updateDrawer_() {
        _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), "updateDrawer_", this).call(this);

        var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
        this.adapter_.updateCssVariable(newOpacity);
      }
    }, {
      key: "isRootTransitioningEventTarget_",
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }, {
      key: "handleTransitionEnd_",
      value: function handleTransitionEnd_(evt) {
        _get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), "handleTransitionEnd_", this).call(this, evt);

        if (!this.isOpen_) {
          this.enableScroll_();
        }
      }
    }, {
      key: "disableScroll_",
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses.SCROLL_LOCK);
      }
    }, {
      key: "enableScroll_",
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses.SCROLL_LOCK);
      }
    }]);

    return MDCTemporaryDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  var MDCTemporaryDrawer =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCTemporaryDrawer, _MDCComponent);

    function MDCTemporaryDrawer() {
      _classCallCheck(this, MDCTemporaryDrawer);

      return _possibleConstructorReturn(this, (MDCTemporaryDrawer.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawer)).apply(this, arguments));
    }

    _createClass(MDCTemporaryDrawer, [{
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this = this;

        var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
            FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
            OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;
        return new MDCTemporaryDrawerFoundation({
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this.root_.classList.contains(className);
          },
          addBodyClass: function addBodyClass(className) {
            return document.body.classList.add(className);
          },
          removeBodyClass: function removeBodyClass(className) {
            return document.body.classList.remove(className);
          },
          eventTargetHasClass: function eventTargetHasClass(target, className) {
            return target.classList.contains(className);
          },
          hasNecessaryDom: function hasNecessaryDom() {
            return Boolean(_this.drawer);
          },
          registerInteractionHandler: function registerInteractionHandler(evt, handler) {
            return _this.root_.addEventListener(remapEvent(evt), handler, applyPassive());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
            return _this.root_.removeEventListener(remapEvent(evt), handler, applyPassive());
          },
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
            return _this.drawer.addEventListener(remapEvent(evt), handler);
          },
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
            return _this.drawer.removeEventListener(remapEvent(evt), handler);
          },
          registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
            return _this.drawer.addEventListener('transitionend', handler);
          },
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
            return _this.drawer.removeEventListener('transitionend', handler);
          },
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
            return document.addEventListener('keydown', handler);
          },
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
            return document.removeEventListener('keydown', handler);
          },
          getDrawerWidth: function getDrawerWidth() {
            return _this.drawer.offsetWidth;
          },
          setTranslateX: function setTranslateX(value) {
            return _this.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : "translateX(".concat(value, "px)"));
          },
          updateCssVariable: function updateCssVariable(value) {
            if (supportsCssCustomProperties()) {
              _this.root_.style.setProperty(OPACITY_VAR_NAME, value);
            }
          },
          getFocusableElements: function getFocusableElements() {
            return _this.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
          },
          saveElementTabState: function saveElementTabState$$1(el) {
            return saveElementTabState(el);
          },
          restoreElementTabState: function restoreElementTabState$$1(el) {
            return restoreElementTabState(el);
          },
          makeElementUntabbable: function makeElementUntabbable(el) {
            return el.setAttribute('tabindex', -1);
          },
          notifyOpen: function notifyOpen() {
            return _this.emit(MDCTemporaryDrawerFoundation.strings.OPEN_EVENT);
          },
          notifyClose: function notifyClose() {
            return _this.emit(MDCTemporaryDrawerFoundation.strings.CLOSE_EVENT);
          },
          isRtl: function isRtl() {
            return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
          },
          isDrawer: function isDrawer(el) {
            return el === _this.drawer;
          }
        });
      }
    }, {
      key: "open",
      get: function get() {
        return this.foundation_.isOpen();
      },
      set: function set(value) {
        if (value) {
          this.foundation_.open();
        } else {
          this.foundation_.close();
        }
      }
      /* Return the drawer element inside the component. */

    }, {
      key: "drawer",
      get: function get() {
        return this.root_.querySelector(MDCTemporaryDrawerFoundation.strings.DRAWER_SELECTOR);
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCTemporaryDrawer(root);
      }
    }]);

    return MDCTemporaryDrawer;
  }(MDCComponent);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$1 = {
    ROOT: 'mdc-drawer--persistent',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating'
  };
  var strings$1 = {
    DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCPersistentDrawer:open',
    CLOSE_EVENT: 'MDCPersistentDrawer:close'
  };

  var MDCPersistentDrawerFoundation =
  /*#__PURE__*/
  function (_MDCSlidableDrawerFou) {
    _inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);

    _createClass(MDCPersistentDrawerFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$1;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$1;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, {
          isDrawer: function isDrawer() {
            return false;
          }
        });
      }
    }]);

    function MDCPersistentDrawerFoundation(adapter) {
      _classCallCheck(this, MDCPersistentDrawerFoundation);

      return _possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, Object.assign(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
    }

    _createClass(MDCPersistentDrawerFoundation, [{
      key: "isRootTransitioningEventTarget_",
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }]);

    return MDCPersistentDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  var MDCPersistentDrawer =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCPersistentDrawer, _MDCComponent);

    function MDCPersistentDrawer() {
      _classCallCheck(this, MDCPersistentDrawer);

      return _possibleConstructorReturn(this, (MDCPersistentDrawer.__proto__ || Object.getPrototypeOf(MDCPersistentDrawer)).apply(this, arguments));
    }

    _createClass(MDCPersistentDrawer, [{
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this = this;

        var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;
        return new MDCPersistentDrawerFoundation({
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this.root_.classList.contains(className);
          },
          hasNecessaryDom: function hasNecessaryDom() {
            return Boolean(_this.drawer);
          },
          registerInteractionHandler: function registerInteractionHandler(evt, handler) {
            return _this.root_.addEventListener(remapEvent(evt), handler, applyPassive());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
            return _this.root_.removeEventListener(remapEvent(evt), handler, applyPassive());
          },
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
            return _this.drawer.addEventListener(remapEvent(evt), handler);
          },
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
            return _this.drawer.removeEventListener(remapEvent(evt), handler);
          },
          registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
            return _this.root_.addEventListener('transitionend', handler);
          },
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
            return _this.root_.removeEventListener('transitionend', handler);
          },
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
            return document.addEventListener('keydown', handler);
          },
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
            return document.removeEventListener('keydown', handler);
          },
          getDrawerWidth: function getDrawerWidth() {
            return _this.drawer.offsetWidth;
          },
          setTranslateX: function setTranslateX(value) {
            return _this.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : "translateX(".concat(value, "px)"));
          },
          getFocusableElements: function getFocusableElements() {
            return _this.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
          },
          saveElementTabState: function saveElementTabState$$1(el) {
            return saveElementTabState(el);
          },
          restoreElementTabState: function restoreElementTabState$$1(el) {
            return restoreElementTabState(el);
          },
          makeElementUntabbable: function makeElementUntabbable(el) {
            return el.setAttribute('tabindex', -1);
          },
          notifyOpen: function notifyOpen() {
            return _this.emit(MDCPersistentDrawerFoundation.strings.OPEN_EVENT);
          },
          notifyClose: function notifyClose() {
            return _this.emit(MDCPersistentDrawerFoundation.strings.CLOSE_EVENT);
          },
          isRtl: function isRtl() {
            return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
          },
          isDrawer: function isDrawer(el) {
            return el === _this.drawer;
          }
        });
      }
    }, {
      key: "open",
      get: function get() {
        return this.foundation_.isOpen();
      },
      set: function set(value) {
        if (value) {
          this.foundation_.open();
        } else {
          this.foundation_.close();
        }
      } // Return the drawer element inside the component.

    }, {
      key: "drawer",
      get: function get() {
        return this.root_.querySelector(MDCPersistentDrawerFoundation.strings.DRAWER_SELECTOR);
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCPersistentDrawer(root);
      }
    }]);

    return MDCPersistentDrawer;
  }(MDCComponent);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var /** @type {?} */ FOCUSABLE_ELEMENTS$1 = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' +
      'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';
  var MdcDrawer = /** @class */ (function () {
      function MdcDrawer(_changeDetectorRef, renderer, elementRef, _registry) {
          var _this = this;
          this._changeDetectorRef = _changeDetectorRef;
          this.renderer = renderer;
          this.elementRef = elementRef;
          this._registry = _registry;
          this._fixed = false;
          this._drawer = 'permanent';
          this.closeOnClick = true;
          this.opened = new core.EventEmitter();
          this.closed = new core.EventEmitter();
          this.isHostClass = true;
          this.role = 'navigation';
          this._mdcAdapter = {
              addClass: function (className) { return _this.renderer.addClass(_this._getHostElement(), className); },
              removeClass: function (className) { return _this.renderer.removeClass(_this._getHostElement(), className); },
              hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
              addBodyClass: function (className) {
                  if (common.isBrowser()) {
                      _this.renderer.addClass(_this.fixedAdjustElement
                          ? _this.fixedAdjustElement : document.body, className);
                  }
              },
              removeBodyClass: function (className) {
                  if (common.isBrowser()) {
                      _this.renderer.removeClass(_this.fixedAdjustElement
                          ? _this.fixedAdjustElement : document.body, className);
                  }
              },
              eventTargetHasClass: function (target, className) { return target.classList.contains(className); },
              hasNecessaryDom: function () { return !!_this.drawerNav; },
              registerInteractionHandler: function (evt, handler) {
                  return _this._registry.listen(remapEvent(evt), handler, _this._getHostElement(), applyPassive());
              },
              deregisterInteractionHandler: function (evt, handler) { return _this._registry.unlisten(evt, handler); },
              registerDrawerInteractionHandler: function (evt, handler) {
                  if (_this.drawerElement) {
                      _this._registry.listen(remapEvent(evt), handler, _this.drawerElement.nativeElement);
                  }
              },
              deregisterDrawerInteractionHandler: function (evt, handler) { return _this._registry.unlisten(evt, handler); },
              registerTransitionEndHandler: function (handler) {
                  if (_this.drawerElement) {
                      _this._registry.listen('transitionend', handler, _this.drawerElement.nativeElement);
                  }
              },
              deregisterTransitionEndHandler: function (handler) { return _this._registry.unlisten('transitionend', handler); },
              registerDocumentKeydownHandler: function (handler) {
                  if (common.isBrowser()) {
                      _this._registry.listen('keydown', handler, document);
                  }
              },
              deregisterDocumentKeydownHandler: function (handler) { return _this._registry.unlisten('keydown', handler); },
              getDrawerWidth: function () { return _this._getHostElement().offsetWidth; },
              setTranslateX: function (value) {
                  if (_this.drawerNav) {
                      _this.renderer.setProperty(_this.drawerNav.elementRef, getTransformPropertyName(), value === null ? null : "translateX(" + value + "px)");
                  }
              },
              updateCssVariable: function (value) {
                  if (supportsCssCustomProperties()) {
                      _this.renderer.setStyle(_this._getHostElement(), '--mdc-temporary-drawer-opacity', value);
                  }
              },
              getFocusableElements: function () {
                  return _this.drawerNav ? _this.drawerNav.elementRef.nativeElement.querySelectorAll(FOCUSABLE_ELEMENTS$1) : null;
              },
              saveElementTabState: function (el) { return saveElementTabState(el); },
              restoreElementTabState: function (el) { return restoreElementTabState(el); },
              makeElementUntabbable: function (el) { return _this.renderer.setAttribute(el, 'tabindex', '-1'); },
              notifyOpen: function () { return _this.opened.emit(); },
              notifyClose: function () { return _this.closed.emit(); },
              isRtl: function () { return getComputedStyle(_this._getHostElement()).direction === 'rtl'; },
              isDrawer: function (el) {
                  return _this.drawerNav ? el === _this.drawerNav.elementRef.nativeElement : false;
              }
          };
          this._initializeFoundation(this._drawer);
      }
      Object.defineProperty(MdcDrawer.prototype, "fixed", {
          get: /**
           * @return {?}
           */
          function () { return this._fixed; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setFixed(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcDrawer.prototype, "drawer", {
          get: /**
           * @return {?}
           */
          function () { return this._drawer; },
          set: /**
           * @param {?} drawer
           * @return {?}
           */
          function (drawer) {
              this.setDrawer(drawer);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcDrawer.prototype, "fixedAdjustElement", {
          get: /**
           * @return {?}
           */
          function () { return this._fixedAdjustElement; },
          set: /**
           * @param {?} element
           * @return {?}
           */
          function (element) {
              this.setFixedAdjustElement(element);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcDrawer.prototype, "drawerElement", {
          get: /**
           * @return {?}
           */
          function () {
              return this.drawerNav && this.drawerNav.elementRef;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcDrawer.prototype, "classFixed", {
          get: /**
           * @return {?}
           */
          function () {
              return this.fixed && this.isDrawerPermanent() ? 'ng-mdc-drawer--fixed' : '';
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MdcDrawer.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          if (this._foundation) {
              this._foundation.destroy();
          }
      };
      /**
       * @param {?} drawer
       * @return {?}
       */
      MdcDrawer.prototype.setDrawer = /**
       * @param {?} drawer
       * @return {?}
       */
      function (drawer) {
          var _this = this;
          this._drawer = drawer ? drawer : 'permanent';
          this._initializeFoundation(drawer);
          if (drawer === 'temporary') {
              this._registry.listen('click', function () {
                  if (_this.closeOnClick) {
                      _this._foundation.close();
                  }
              }, this.drawerElement.nativeElement);
          }
          else if (drawer === 'temporary') {
              this._registry.unlisten('click', function () {
                  if (_this.closeOnClick) {
                      _this._foundation.close();
                  }
              });
          }
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @param {?} element
       * @return {?}
       */
      MdcDrawer.prototype.setFixedAdjustElement = /**
       * @param {?} element
       * @return {?}
       */
      function (element) {
          this._fixedAdjustElement = element;
          if (element) {
              this.renderer.setStyle(this._getHostElement(), 'position', 'absolute');
          }
          else {
              this.renderer.removeStyle(this._getHostElement(), 'position');
          }
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @param {?} fixed
       * @return {?}
       */
      MdcDrawer.prototype.setFixed = /**
       * @param {?} fixed
       * @return {?}
       */
      function (fixed) {
          this._fixed = fixed;
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype.isDrawerPermanent = /**
       * @return {?}
       */
      function () {
          return this._drawer === 'permanent';
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype.isDrawerTemporary = /**
       * @return {?}
       */
      function () {
          return this._drawer === 'temporary';
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype.isDrawerPersistent = /**
       * @return {?}
       */
      function () {
          return this._drawer === 'persistent';
      };
      /**
       * @param {?} drawer
       * @return {?}
       */
      MdcDrawer.prototype._initializeFoundation = /**
       * @param {?} drawer
       * @return {?}
       */
      function (drawer) {
          this._removeDrawerModifierClass();
          this.renderer.addClass(this._getHostElement(), "mdc-drawer--" + drawer);
          if (!this.isDrawerPermanent()) {
              if (drawer === 'temporary') {
                  this._foundation = new MDCTemporaryDrawerFoundation(this._mdcAdapter);
              }
              else if (drawer === 'persistent') {
                  this._foundation = new MDCPersistentDrawerFoundation(this._mdcAdapter);
              }
              this._foundation.init();
          }
          else {
              if (this._foundation) {
                  this._foundation.destroy();
              }
          }
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype._removeDrawerModifierClass = /**
       * @return {?}
       */
      function () {
          this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--temporary');
          this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--persistent');
          this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--permanent');
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype.isOpen = /**
       * @return {?}
       */
      function () {
          if (this.isDrawerPermanent()) {
              return true;
          }
          return this._foundation.isOpen();
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype.open = /**
       * @return {?}
       */
      function () {
          if (this._foundation) {
              this.isOpen() ? this._foundation.close() : this._foundation.open();
          }
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype.close = /**
       * @return {?}
       */
      function () {
          if (this._foundation) {
              this._foundation.close();
          }
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype.getDrawerWidth = /**
       * @return {?}
       */
      function () {
          return this._foundation ? this._mdcAdapter.getDrawerWidth() : this._getHostElement().offsetWidth;
      };
      /**
       * @return {?}
       */
      MdcDrawer.prototype._getHostElement = /**
       * @return {?}
       */
      function () {
          return this.elementRef.nativeElement;
      };
      MdcDrawer.decorators = [
          { type: core.Component, args: [{selector: 'mdc-drawer',
                      exportAs: 'mdcDrawer',
                      template: "\n  <mdc-drawer-navigation>\n    <ng-content></ng-content>\n  </mdc-drawer-navigation>\n  ",
                      providers: [common.EventRegistry],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None
                  },] },
      ];
      /** @nocollapse */
      MdcDrawer.ctorParameters = function () { return [
          { type: core.ChangeDetectorRef },
          { type: core.Renderer2 },
          { type: core.ElementRef },
          { type: common.EventRegistry }
      ]; };
      MdcDrawer.propDecorators = {
          fixed: [{ type: core.Input }],
          drawer: [{ type: core.Input }],
          fixedAdjustElement: [{ type: core.Input }],
          closeOnClick: [{ type: core.Input }],
          opened: [{ type: core.Output }],
          closed: [{ type: core.Output }],
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer',] }],
          role: [{ type: core.HostBinding, args: ['attr.role',] }],
          classFixed: [{ type: core.HostBinding, args: ['class.ng-mdc-drawer--fixed',] }],
          drawerNav: [{ type: core.ViewChild, args: [MdcDrawerNavigation,] }]
      };
      return MdcDrawer;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var /** @type {?} */ DRAWER_COMPONENTS = [
      MdcDrawer,
      MdcDrawerContent,
      MdcDrawerHeader,
      MdcDrawerHeaderContent,
      MdcDrawerNavigation,
      MdcDrawerSpacer,
  ];
  var MdcDrawerModule = /** @class */ (function () {
      function MdcDrawerModule() {
      }
      MdcDrawerModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: DRAWER_COMPONENTS,
                      declarations: DRAWER_COMPONENTS,
                  },] },
      ];
      return MdcDrawerModule;
  }());

  exports.MdcDrawerModule = MdcDrawerModule;
  exports.FOCUSABLE_ELEMENTS = FOCUSABLE_ELEMENTS$1;
  exports.MdcDrawer = MdcDrawer;
  exports.d14 = MdcDrawerContent;
  exports.b14 = MdcDrawerHeader;
  exports.c14 = MdcDrawerHeaderContent;
  exports.e14 = MdcDrawerNavigation;
  exports.a14 = MdcDrawerSpacer;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
