/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, HostBinding, HostListener, Input, Output, Renderer2, ViewEncapsulation, NgZone, NgModule } from '@angular/core';
import { Subject, defer, merge } from 'rxjs';
import { toBoolean, isBrowser, EventRegistry } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { MdcIcon, MdcIconModule } from '@angular-mdc/web/icon';
import { startWith, switchMap, take, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */
class RippleCapableSurface {}

/** @protected {!Element} */
RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
const strings$1 = {
  ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
  INTERACTION_EVENT: 'MDCChip:interaction',
  TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
  REMOVAL_EVENT: 'MDCChip:removal',
  CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
  LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
  TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing',
};

/** @enum {string} */
const cssClasses$1 = {
  CHECKMARK: 'mdc-chip__checkmark',
  CHIP_EXIT: 'mdc-chip--exit',
  HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
  LEADING_ICON: 'mdc-chip__icon--leading',
  TRAILING_ICON: 'mdc-chip__icon--trailing',
  SELECTED: 'mdc-chip--selected',
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @extends {MDCFoundation<!MDCChipAdapter>}
 * @final
 */
class MDCChipFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings$1;
  }

  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$1;
  }

  /**
   * {@see MDCChipAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCChipAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCChipAdapter} */ ({
      addClass: () => {},
      removeClass: () => {},
      hasClass: () => {},
      addClassToLeadingIcon: () => {},
      removeClassFromLeadingIcon: () => {},
      eventTargetHasClass: () => {},
      registerEventHandler: () => {},
      deregisterEventHandler: () => {},
      registerTrailingIconInteractionHandler: () => {},
      deregisterTrailingIconInteractionHandler: () => {},
      notifyInteraction: () => {},
      notifyTrailingIconInteraction: () => {},
      notifyRemoval: () => {},
      getComputedStyleValue: () => {},
      setStyleProperty: () => {},
    });
  }

  /**
   * @param {!MDCChipAdapter} adapter
   */
  constructor(adapter) {
    super(Object.assign(MDCChipFoundation.defaultAdapter, adapter));

    /** @private {function(!Event): undefined} */
    this.interactionHandler_ = (evt) => this.handleInteraction_(evt);
    /** @private {function(!Event): undefined} */
    this.transitionEndHandler_ = (evt) => this.handleTransitionEnd_(evt);
    /** @private {function(!Event): undefined} */
    this.trailingIconInteractionHandler_ = (evt) => this.handleTrailingIconInteraction_(evt);
  }

  init() {
    ['click', 'keydown'].forEach((evtType) => {
      this.adapter_.registerEventHandler(evtType, this.interactionHandler_);
    });
    this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
    ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach((evtType) => {
      this.adapter_.registerTrailingIconInteractionHandler(evtType, this.trailingIconInteractionHandler_);
    });
  }

  destroy() {
    ['click', 'keydown'].forEach((evtType) => {
      this.adapter_.deregisterEventHandler(evtType, this.interactionHandler_);
    });
    this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
    ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach((evtType) => {
      this.adapter_.deregisterTrailingIconInteractionHandler(evtType, this.trailingIconInteractionHandler_);
    });
  }

  /**
   * @return {boolean}
   */
  isSelected() {
    return this.adapter_.hasClass(cssClasses$1.SELECTED);
  }

  /**
   * @param {boolean} selected
   */
  setSelected(selected) {
    if (selected) {
      this.adapter_.addClass(cssClasses$1.SELECTED);
    } else {
      this.adapter_.removeClass(cssClasses$1.SELECTED);
    }
  }

  /**
   * Handles an interaction event on the root element.
   * @param {!Event} evt
   */
  handleInteraction_(evt) {
    if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
      this.adapter_.notifyInteraction();
    }
  }

  /**
   * Handles a transition end event on the root element.
   * @param {!Event} evt
   */
  handleTransitionEnd_(evt) {
    // Handle transition end event on the chip when it is about to be removed.
    if (this.adapter_.eventTargetHasClass(/** @type {!EventTarget} */ (evt.target), cssClasses$1.CHIP_EXIT)) {
      if (evt.propertyName === 'width') {
        this.adapter_.notifyRemoval();
      } else if (evt.propertyName === 'opacity') {
        // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
        const chipWidth = this.adapter_.getComputedStyleValue('width');

        // On the next frame (once we get the computed width), explicitly set the chip's width
        // to its current pixel width, so we aren't transitioning out of 'auto'.
        requestAnimationFrame(() => {
          this.adapter_.setStyleProperty('width', chipWidth);

          // To mitigate jitter, start transitioning padding and margin before width.
          this.adapter_.setStyleProperty('padding', '0');
          this.adapter_.setStyleProperty('margin', '0');

          // On the next frame (once width is explicitly set), transition width to 0.
          requestAnimationFrame(() => {
            this.adapter_.setStyleProperty('width', '0');
          });
        });
      }
      return;
    }

    // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.
    if (evt.propertyName !== 'opacity') {
      return;
    }
    if (this.adapter_.eventTargetHasClass(/** @type {!EventTarget} */ (evt.target), cssClasses$1.LEADING_ICON) &&
        this.adapter_.hasClass(cssClasses$1.SELECTED)) {
      this.adapter_.addClassToLeadingIcon(cssClasses$1.HIDDEN_LEADING_ICON);
    } else if (this.adapter_.eventTargetHasClass(/** @type {!EventTarget} */ (evt.target), cssClasses$1.CHECKMARK) &&
               !this.adapter_.hasClass(cssClasses$1.SELECTED)) {
      this.adapter_.removeClassFromLeadingIcon(cssClasses$1.HIDDEN_LEADING_ICON);
    }
  }

  /**
   * Handles an interaction event on the trailing icon element. This is used to
   * prevent the ripple from activating on interaction with the trailing icon.
   * @param {!Event} evt
   */
  handleTrailingIconInteraction_(evt) {
    evt.stopPropagation();
    if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
      this.adapter_.notifyTrailingIconInteraction();
      this.adapter_.addClass(cssClasses$1.CHIP_EXIT);
    }
  }
}

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
const strings$2 = {
  CHIP_SELECTOR: '.mdc-chip',
};

/** @enum {string} */
const cssClasses$2 = {
  CHOICE: 'mdc-chip-set--choice',
  FILTER: 'mdc-chip-set--filter',
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCChipSetAdapter>}
 * @final
 */
class MDCChipSetFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings$2;
  }

  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$2;
  }

  /**
   * {@see MDCChipSetAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCChipSetAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCChipSetAdapter} */ ({
      hasClass: () => {},
      registerInteractionHandler: () => {},
      deregisterInteractionHandler: () => {},
      removeChip: () => {},
    });
  }

  /**
   * @param {!MDCChipSetAdapter} adapter
   */
  constructor(adapter) {
    super(Object.assign(MDCChipSetFoundation.defaultAdapter, adapter));

    /**
     * The selected chips in the set. Only used for choice chip set or filter chip set.
     * @private {!Array<!MDCChipFoundation>}
     */
    this.selectedChips_ = [];

    /** @private {function(!Event): undefined} */
    this.chipInteractionHandler_ = (evt) => this.handleChipInteraction_(evt);
    /** @private {function(!Event): undefined} */
    this.chipRemovalHandler_ = (evt) => this.handleChipRemoval_(evt);
  }

  init() {
    this.adapter_.registerInteractionHandler(
      MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
    this.adapter_.registerInteractionHandler(
      MDCChipFoundation.strings.REMOVAL_EVENT, this.chipRemovalHandler_);
  }

  destroy() {
    this.adapter_.deregisterInteractionHandler(
      MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
    this.adapter_.deregisterInteractionHandler(
      MDCChipFoundation.strings.REMOVAL_EVENT, this.chipRemovalHandler_);
  }

  /**
   * Selects the given chip. Deselects all other chips if the chip set is of the choice variant.
   * @param {!MDCChipFoundation} chipFoundation
   */
  select(chipFoundation) {
    if (this.adapter_.hasClass(cssClasses$2.CHOICE)) {
      this.deselectAll_();
    }
    chipFoundation.setSelected(true);
    this.selectedChips_.push(chipFoundation);
  }

  /**
   * Deselects the given chip.
   * @param {!MDCChipFoundation} chipFoundation
   */
  deselect(chipFoundation) {
    const index = this.selectedChips_.indexOf(chipFoundation);
    if (index >= 0) {
      this.selectedChips_.splice(index, 1);
    }
    chipFoundation.setSelected(false);
  }

  /** Deselects all selected chips. */
  deselectAll_() {
    this.selectedChips_.forEach((chipFoundation) => {
      chipFoundation.setSelected(false);
    });
    this.selectedChips_.length = 0;
  }

  /**
   * Handles a chip interaction event
   * @param {!Event} evt
   * @private
   */
  handleChipInteraction_(evt) {
    const chipFoundation = evt.detail.chip.foundation;
    if (this.adapter_.hasClass(cssClasses$2.CHOICE) || this.adapter_.hasClass(cssClasses$2.FILTER)) {
      if (chipFoundation.isSelected()) {
        this.deselect(chipFoundation);
      } else {
        this.select(chipFoundation);
      }
    }
  }

  /**
   * Handles the event when a chip is removed.
   * @param {!Event} evt
   * @private
   */
  handleChipRemoval_(evt) {
    const {chip} = evt.detail;
    this.deselect(chip.foundation);
    this.adapter_.removeChip(chip);
  }
}

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Event object emitted by MdcChip when selected or deselected.
 */
class MdcChipSelectionEvent {
    /**
     * @param {?} source
     */
    constructor(source) {
        this.source = source;
    }
}
let /** @type {?} */ nextUniqueId = 0;
class MdcChipIcon extends MdcIcon {
    constructor() {
        super(...arguments);
        this.isHostClass = true;
    }
    /**
     * @return {?}
     */
    get classIconLeading() {
        return this.leading ? 'mdc-chip__icon--leading' : '';
    }
    /**
     * @return {?}
     */
    get classIconTrailing() {
        this.setClickable(this.trailing);
        return this.trailing ? 'mdc-chip__icon--trailing' : '';
    }
}
MdcChipIcon.decorators = [
    { type: Component, args: [{selector: 'mdc-chip-icon, [mdc-chip-icon], [mdcChipIcon]',
                template: '<ng-content></ng-content>',
                exportAs: 'mdcChipIcon',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
MdcChipIcon.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-chip__icon',] }],
    classIconLeading: [{ type: HostBinding, args: ['class.mdc-chip__icon--leading',] }],
    classIconTrailing: [{ type: HostBinding, args: ['class.mdc-chip__icon--trailing',] }]
};
class MdcChipCheckmark {
}
MdcChipCheckmark.decorators = [
    { type: Component, args: [{selector: 'mdc-chip-checkmark',
                exportAs: 'mdcChipCheckmark',
                template: `
  <div class="mdc-chip__checkmark">
    <svg class="mdc-chip__checkmark-svg" viewBox="-2 -3 30 30">
      <path class="mdc-chip__checkmark-path" fill="none" stroke="black" d="M1.73,12.91 8.1,19.28 22.79,4.59"/>
    </svg>
  </div>
  `
            },] },
];
class MdcChipText {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcChipText.decorators = [
    { type: Component, args: [{selector: 'mdc-chip-text, [mdcChipText]',
                exportAs: 'mdcChipText',
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcChipText.ctorParameters = () => [
    { type: ElementRef }
];
MdcChipText.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-chip__text',] }]
};
class MdcChip {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _ripple
     * @param {?} _renderer
     * @param {?} elementRef
     * @param {?} _registry
     */
    constructor(_changeDetectorRef, _ripple, _renderer, elementRef, _registry) {
        this._changeDetectorRef = _changeDetectorRef;
        this._ripple = _ripple;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        this._id = `mdc-chip-${nextUniqueId++}`;
        this._selected = false;
        this._filter = false;
        this._primary = false;
        this._secondary = false;
        /**
         * Whether the chip has focus.
         */
        this._hasFocus = false;
        this._disabled = false;
        /**
         * Emits when the chip is focused.
         */
        this._onFocus = new Subject();
        /**
         * Emits when the chip is blured.
         */
        this._onBlur = new Subject();
        /**
         * Emitted when the chip is destroyed.
         */
        this.destroyed = new EventEmitter();
        /**
         * Emitted when the chip is selected or deselected.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Emitted when the chip is selected or deselected.
         */
        this.trailingIconInteraction = new EventEmitter();
        /**
         * Emitted when a chip is to be removed.
         */
        this.removed = new EventEmitter();
        this.isHostClass = true;
        this._mdcAdapter = {
            addClass: (className) => this._renderer.addClass(this._getHostElement(), className),
            removeClass: (className) => this._renderer.removeClass(this._getHostElement(), className),
            hasClass: (className) => this._getHostElement().classList.contains(className),
            addClassToLeadingIcon: (className) => {
                const /** @type {?} */ leadingIcon = this.getLeadingIcon();
                if (leadingIcon) {
                    this._renderer.addClass(leadingIcon.elementRef.nativeElement, className);
                }
            },
            removeClassFromLeadingIcon: (className) => {
                const /** @type {?} */ leadingIcon = this.getLeadingIcon();
                if (leadingIcon) {
                    this._renderer.removeClass(leadingIcon.elementRef.nativeElement, className);
                }
            },
            eventTargetHasClass: (target, className) => target.classList.contains(className),
            registerEventHandler: (evtType, handler) => this._registry.listen(evtType, handler, this._getHostElement()),
            deregisterEventHandler: (evtType, handler) => this._registry.unlisten(evtType, handler),
            registerInteractionHandler: (evtType, handler) => this._registry.listen(evtType, handler, this._getHostElement()),
            deregisterInteractionHandler: (evtType, handler) => this._registry.unlisten(evtType, handler),
            registerTrailingIconInteractionHandler: (evtType, handler) => {
                if (this.icons) {
                    const /** @type {?} */ trailingIcon = this.icons.find((_) => _.isTrailing());
                    if (trailingIcon) {
                        this._registry.listen(evtType, handler, trailingIcon.elementRef.nativeElement);
                    }
                }
            },
            deregisterTrailingIconInteractionHandler: (evtType, handler) => this._registry.unlisten(evtType, handler),
            notifyInteraction: () => this._emitSelectionChangeEvent(),
            notifyTrailingIconInteraction: () => this.trailingIconInteraction.emit(),
            notifyRemoval: () => this.removed.emit({ chip: this }),
            getComputedStyleValue: (propertyName) => {
                if (isBrowser()) {
                    window.getComputedStyle(this._getHostElement()).getPropertyValue(propertyName);
                }
            },
            setStyleProperty: (propertyName, value) => this._renderer.setStyle(this._getHostElement(), propertyName, value)
        };
    }
    /**
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        this.setSelected(value);
    }
    /**
     * @return {?}
     */
    get filter() { return this._filter; }
    /**
     * @param {?} value
     * @return {?}
     */
    set filter(value) {
        this._filter = toBoolean(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get primary() { return this._primary; }
    /**
     * @param {?} value
     * @return {?}
     */
    set primary(value) {
        this.setPrimary(value);
    }
    /**
     * @return {?}
     */
    get secondary() { return this._secondary; }
    /**
     * @param {?} value
     * @return {?}
     */
    set secondary(value) {
        this.setSecondary(value);
    }
    /**
     * The unique ID of the option.
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * Whether the chip is disabled.
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get tabindex() {
        return this.disabled ? null : 0;
    }
    /**
     * @return {?}
     */
    get classPrimary() {
        return this.primary ? 'ng-mdc-chip--primary' : '';
    }
    /**
     * @return {?}
     */
    get classSecondary() {
        return this.secondary ? 'ng-mdc-chip--secondary' : '';
    }
    /**
     * @return {?}
     */
    onfocus() {
        this._hasFocus = true;
    }
    /**
     * @return {?}
     */
    onblur() {
        this._blur();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._ripple.attachTo(this._getHostElement());
        this._foundation = new MDCChipFoundation(this._mdcAdapter);
        this._foundation.init();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._ripple.destroy();
        this.destroyed.emit({ chip: this });
        this._foundation.destroy();
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    setSelected(selected) {
        this._selected = toBoolean(selected);
        this._foundation.setSelected(selected);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    isSelected() {
        return this._foundation.isSelected();
    }
    /**
     * @param {?} primary
     * @return {?}
     */
    setPrimary(primary) {
        this._primary = primary;
    }
    /**
     * @param {?} secondary
     * @return {?}
     */
    setSecondary(secondary) {
        this._secondary = secondary;
    }
    /**
     * Allows for programmatic focusing of the chip.
     * @return {?}
     */
    focus() {
        this._getHostElement().focus();
        this._onFocus.next({ chip: this });
    }
    /**
     * Allows for programmatic removal of the chip. Called by the MdcChipSet when the DELETE or
     * BACKSPACE keys are pressed.
     *
     * Informs any listeners of the removal request. Does not remove the chip from the DOM.
     * @return {?}
     */
    remove() {
        this.removed.emit({ chip: this });
    }
    /**
     * @return {?}
     */
    isLeadingIconVisibile() {
        return this.filter && this.selected ? false : true;
    }
    /**
     * @return {?}
     */
    getLeadingIcon() {
        if (this.icons) {
            return this.icons.find((_) => _.isLeading());
        }
    }
    /**
     * @return {?}
     */
    _blur() {
        this._onBlur.next({ chip: this });
    }
    /**
     * @return {?}
     */
    foundation() {
        return this._foundation;
    }
    /**
     * Retrieves the DOM element of the component host.
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * Emits the selection change event.
     * @return {?}
     */
    _emitSelectionChangeEvent() {
        this.selectionChange.emit({ source: this });
    }
}
MdcChip.decorators = [
    { type: Component, args: [{selector: 'mdc-chip',
                host: {
                    '[id]': 'id'
                },
                exportAs: 'mdcChip',
                template: `
  <ng-content *ngIf="isLeadingIconVisibile()" select="mdc-chip-icon[leading]"></ng-content>
  <mdc-chip-checkmark *ngIf="filter"></mdc-chip-checkmark>
  <ng-content></ng-content>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    MdcRipple,
                    EventRegistry,
                ]
            },] },
];
/** @nocollapse */
MdcChip.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: MdcRipple },
    { type: Renderer2 },
    { type: ElementRef },
    { type: EventRegistry }
];
MdcChip.propDecorators = {
    primary: [{ type: Input }],
    secondary: [{ type: Input }],
    disabled: [{ type: Input }],
    destroyed: [{ type: Output }],
    selectionChange: [{ type: Output }],
    trailingIconInteraction: [{ type: Output }],
    removed: [{ type: Output }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-chip',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    classPrimary: [{ type: HostBinding, args: ['class.ng-mdc-chip--primary',] }],
    classSecondary: [{ type: HostBinding, args: ['class.ng-mdc-chip--secondary',] }],
    onfocus: [{ type: HostListener, args: ['focus', ['$event'],] }],
    onblur: [{ type: HostListener, args: ['blur', ['$event'],] }],
    chipText: [{ type: ContentChild, args: [MdcChipText,] }],
    icons: [{ type: ContentChildren, args: [MdcChipIcon,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcChipSet {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _ngZone
     * @param {?} _renderer
     * @param {?} elementRef
     * @param {?} _registry
     */
    constructor(_changeDetectorRef, _ngZone, _renderer, elementRef, _registry) {
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this._choice = false;
        this._filter = false;
        this._input = false;
        this.isHostClass = true;
        /**
         * Combined stream of all of the chip change events.
         */
        this.chipSelectionChanges = defer(() => {
            if (this.chips) {
                return merge(...this.chips.map(chip => chip.selectionChange));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap(() => this.chipSelectionChanges));
        });
        this._mdcAdapter = {
            hasClass: (className) => this._getHostElement().classList.contains(className),
            registerInteractionHandler: (evtType, handler) => this._registry.listen(evtType, handler, this._getHostElement()),
            deregisterInteractionHandler: (evtType, handler) => this._registry.unlisten(evtType, handler),
            removeChip: (chip) => {
                const /** @type {?} */ index = this.chips.toArray().indexOf(chip);
                this.chips.toArray().splice(index, 1);
            }
        };
        this._foundation = new MDCChipSetFoundation(this._mdcAdapter);
    }
    /**
     * Indicates that the chips in the set are choice chips, which allow a single selection from a set of options.
     * @return {?}
     */
    get choice() { return this._choice; }
    /**
     * @param {?} value
     * @return {?}
     */
    set choice(value) {
        this.setChoice(value);
    }
    /**
     * Indicates that the chips in the set are filter chips, which allow multiple selection from a set of options.
     * @return {?}
     */
    get filter() { return this._filter; }
    /**
     * @param {?} value
     * @return {?}
     */
    set filter(value) {
        this.setFilter(value);
    }
    /**
     * Indicates that the chips in the set are input chips, which enable user input by converting text into chips.
     * @return {?}
     */
    get input() { return this._input; }
    /**
     * @param {?} value
     * @return {?}
     */
    set input(value) {
        this.setInput(value);
    }
    /**
     * @return {?}
     */
    get classChoice() {
        return this.choice ? 'mdc-chip-set--choice' : '';
    }
    /**
     * @return {?}
     */
    get classFilter() {
        return this.filter ? 'mdc-chip-set--filter' : '';
    }
    /**
     * @return {?}
     */
    get classInput() {
        return this.input ? 'mdc-chip-set--input' : '';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chipSelectionChanges.pipe(takeUntil(merge(this._destroy, this.chips.changes))).subscribe(event => {
            if (!this.filter) {
                this.chips.forEach(chip => {
                    if (chip.selected && chip !== event.source) {
                        chip.setSelected(!chip.selected);
                    }
                });
            }
            if (this.choice || this.filter) {
                event.source.setSelected(!event.source.selected);
            }
        });
        this.chips.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {
            Promise.resolve().then(() => {
                this.chips.forEach(chip => {
                    chip.filter = this.filter;
                });
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
        this._foundation.destroy();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._foundation.init();
    }
    /**
     * @param {?} choice
     * @return {?}
     */
    setChoice(choice) {
        this._choice = choice;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    setFilter(filter) {
        this._filter = filter;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} input
     * @return {?}
     */
    setInput(input) {
        this._input = input;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Retrieves the DOM element of the component host.
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
MdcChipSet.decorators = [
    { type: Component, args: [{selector: 'mdc-chip-set',
                exportAs: 'mdcChipSet',
                template: `<ng-content></ng-content>`,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [EventRegistry]
            },] },
];
/** @nocollapse */
MdcChipSet.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: ElementRef },
    { type: EventRegistry }
];
MdcChipSet.propDecorators = {
    choice: [{ type: Input }],
    filter: [{ type: Input }],
    input: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-chip-set',] }],
    classChoice: [{ type: HostBinding, args: ['class.mdc-chip-set--choice',] }],
    classFilter: [{ type: HostBinding, args: ['class.mdc-chip-set--filter',] }],
    classInput: [{ type: HostBinding, args: ['class.mdc-chip-set--input',] }],
    chips: [{ type: ContentChildren, args: [MdcChip,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ CHIP_DECLARATIONS = [
    MdcChip,
    MdcChipCheckmark,
    MdcChipIcon,
    MdcChipSet,
    MdcChipText
];
class MdcChipsModule {
}
MdcChipsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, MdcIconModule],
                exports: CHIP_DECLARATIONS,
                declarations: CHIP_DECLARATIONS,
                entryComponents: [MdcChip, MdcChipText, MdcChipIcon]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { CHIP_DECLARATIONS, MdcChipsModule, MdcChipSelectionEvent, MdcChipIcon, MdcChipCheckmark, MdcChipText, MdcChip, MdcChipSet };
