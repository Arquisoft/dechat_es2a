/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { Directive, ElementRef, HostBinding, Input, ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Output, Renderer2, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';
import { isBrowser, EventRegistry } from '@angular-mdc/web/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcDrawerSpacer {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcDrawerSpacer.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-drawer-spacer], mdc-drawer-spacer',
                exportAs: 'mdcDrawerSpace'
            },] },
];
/** @nocollapse */
MdcDrawerSpacer.ctorParameters = () => [
    { type: ElementRef }
];
MdcDrawerSpacer.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-drawer__toolbar-spacer',] }]
};
class MdcDrawerHeader {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcDrawerHeader.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-drawer-header], mdc-drawer-header',
                exportAs: 'mdcDrawerHeader'
            },] },
];
/** @nocollapse */
MdcDrawerHeader.ctorParameters = () => [
    { type: ElementRef }
];
MdcDrawerHeader.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-drawer__header',] }]
};
class MdcDrawerHeaderContent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.primary = true;
        this.isHostClass = true;
    }
    /**
     * @return {?}
     */
    get classPrimaryBackground() {
        return this.primary ? 'mdc-theme--primary-bg' : '';
    }
    /**
     * @return {?}
     */
    get classPrimaryOnPrimary() {
        return this.primary ? 'mdc-theme--text-primary-on-primary' : '';
    }
}
MdcDrawerHeaderContent.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-drawer-header-content], mdc-drawer-header-content',
                exportAs: 'mdcDrawerHeaderContent'
            },] },
];
/** @nocollapse */
MdcDrawerHeaderContent.ctorParameters = () => [
    { type: ElementRef }
];
MdcDrawerHeaderContent.propDecorators = {
    primary: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-drawer__header-content',] }],
    classPrimaryBackground: [{ type: HostBinding, args: ['class.mdc-theme--primary-bg',] }],
    classPrimaryOnPrimary: [{ type: HostBinding, args: ['class.mdc-theme--text-primary-on-primary',] }]
};
class MdcDrawerContent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcDrawerContent.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-drawer-content], mdc-drawer-content',
                exportAs: 'mdcDrawerContent'
            },] },
];
/** @nocollapse */
MdcDrawerContent.ctorParameters = () => [
    { type: ElementRef }
];
MdcDrawerContent.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-drawer__content',] }]
};
class MdcDrawerNavigation {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
        this.role = 'navigation';
    }
}
MdcDrawerNavigation.decorators = [
    { type: Directive, args: [{
                selector: 'mdc-drawer-navigation',
                exportAs: 'mdcDrawerNavigation'
            },] },
];
/** @nocollapse */
MdcDrawerNavigation.ctorParameters = () => [
    { type: ElementRef }
];
MdcDrawerNavigation.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-drawer__drawer',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const TAB_DATA = 'data-mdc-tabindex';
const TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

let storedTransformPropertyName_;
let supportsPassive_;

// Remap touch events to pointer events, if the browser doesn't support touch events.
function remapEvent(eventName, globalObj = window) {
  if (!('ontouchstart' in globalObj.document)) {
    switch (eventName) {
    case 'touchstart':
      return 'pointerdown';
    case 'touchmove':
      return 'pointermove';
    case 'touchend':
      return 'pointerup';
    default:
      return eventName;
    }
  }

  return eventName;
}

// Choose the correct transform property to use on the current browser.
function getTransformPropertyName(globalObj = window, forceRefresh = false) {
  if (storedTransformPropertyName_ === undefined || forceRefresh) {
    const el = globalObj.document.createElement('div');
    const transformPropertyName = ('transform' in el.style ? 'transform' : '-webkit-transform');
    storedTransformPropertyName_ = transformPropertyName;
  }

  return storedTransformPropertyName_;
}

// Determine whether the current browser supports CSS properties.
function supportsCssCustomProperties(globalObj = window) {
  if ('CSS' in globalObj) {
    return globalObj.CSS.supports('(--color: red)');
  }
  return false;
}

// Determine whether the current browser supports passive event listeners, and if so, use them.
function applyPassive(globalObj = window, forceRefresh = false) {
  if (supportsPassive_ === undefined || forceRefresh) {
    let isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, {get passive() {
        isSupported = true;
      }});
    } catch (e) { }

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ? {passive: true} : false;
}

// Save the tab state for an element.
function saveElementTabState(el) {
  if (el.hasAttribute('tabindex')) {
    el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
  }
  el.setAttribute(TAB_DATA_HANDLED, true);
}

// Restore the tab state for an element, if it was saved.
function restoreElementTabState(el) {
  // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
  if (el.hasAttribute(TAB_DATA_HANDLED)) {
    if (el.hasAttribute(TAB_DATA)) {
      el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
      el.removeAttribute(TAB_DATA);
    } else {
      el.removeAttribute('tabindex');
    }
    el.removeAttribute(TAB_DATA_HANDLED);
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const FOCUSABLE_ELEMENTS =
  'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' +
  'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class MDCSlidableDrawerFoundation extends MDCFoundation {
  static get defaultAdapter() {
    return {
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      hasClass: (/* className: string */) => {},
      hasNecessaryDom: () => /* boolean */ false,
      registerInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      deregisterInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      registerDrawerInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      deregisterDrawerInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      registerTransitionEndHandler: (/* handler: EventListener */) => {},
      deregisterTransitionEndHandler: (/* handler: EventListener */) => {},
      registerDocumentKeydownHandler: (/* handler: EventListener */) => {},
      deregisterDocumentKeydownHandler: (/* handler: EventListener */) => {},
      setTranslateX: (/* value: number | null */) => {},
      getFocusableElements: () => /* NodeList */ {},
      saveElementTabState: (/* el: Element */) => {},
      restoreElementTabState: (/* el: Element */) => {},
      makeElementUntabbable: (/* el: Element */) => {},
      notifyOpen: () => {},
      notifyClose: () => {},
      isRtl: () => /* boolean */ false,
      getDrawerWidth: () => /* number */ 0,
    };
  }

  constructor(adapter, rootCssClass, animatingCssClass, openCssClass) {
    super(Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, adapter));

    this.rootCssClass_ = rootCssClass;
    this.animatingCssClass_ = animatingCssClass;
    this.openCssClass_ = openCssClass;

    this.transitionEndHandler_ = (evt) => this.handleTransitionEnd_(evt);

    this.inert_ = false;

    this.componentTouchStartHandler_ = (evt) => this.handleTouchStart_(evt);
    this.componentTouchMoveHandler_ = (evt) => this.handleTouchMove_(evt);
    this.componentTouchEndHandler_ = (evt) => this.handleTouchEnd_(evt);
    this.documentKeydownHandler_ = (evt) => {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        this.close();
      }
    };
  }

  init() {
    const ROOT = this.rootCssClass_;
    const OPEN = this.openCssClass_;

    if (!this.adapter_.hasClass(ROOT)) {
      throw new Error(`${ROOT} class required in root element.`);
    }

    if (!this.adapter_.hasNecessaryDom()) {
      throw new Error(`Required DOM nodes missing in ${ROOT} component.`);
    }

    if (this.adapter_.hasClass(OPEN)) {
      this.isOpen_ = true;
    } else {
      this.detabinate_();
      this.isOpen_ = false;
    }

    this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
    this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
    this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
  }

  destroy() {
    this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
    this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
    this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
    // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
    this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
  }

  open() {
    this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
    this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.addClass(this.animatingCssClass_);
    this.adapter_.addClass(this.openCssClass_);
    this.retabinate_();
    // Debounce multiple calls
    if (!this.isOpen_) {
      this.adapter_.notifyOpen();
    }
    this.isOpen_ = true;
  }

  close() {
    this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
    this.adapter_.addClass(this.animatingCssClass_);
    this.adapter_.removeClass(this.openCssClass_);
    this.detabinate_();
    // Debounce multiple calls
    if (this.isOpen_) {
      this.adapter_.notifyClose();
    }
    this.isOpen_ = false;
  }

  isOpen() {
    return this.isOpen_;
  }

  /**
   *  Render all children of the drawer inert when it's closed.
   */
  detabinate_() {
    if (this.inert_) {
      return;
    }

    const elements = this.adapter_.getFocusableElements();
    if (elements) {
      for (let i = 0; i < elements.length; i++) {
        this.adapter_.saveElementTabState(elements[i]);
        this.adapter_.makeElementUntabbable(elements[i]);
      }
    }

    this.inert_ = true;
  }

  /**
   *  Make all children of the drawer tabbable again when it's open.
   */
  retabinate_() {
    if (!this.inert_) {
      return;
    }

    const elements = this.adapter_.getFocusableElements();
    if (elements) {
      for (let i = 0; i < elements.length; i++) {
        this.adapter_.restoreElementTabState(elements[i]);
      }
    }

    this.inert_ = false;
  }

  handleTouchStart_(evt) {
    if (!this.adapter_.hasClass(this.openCssClass_)) {
      return;
    }
    if (evt.pointerType && evt.pointerType !== 'touch') {
      return;
    }

    this.direction_ = this.adapter_.isRtl() ? -1 : 1;
    this.drawerWidth_ = this.adapter_.getDrawerWidth();
    this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
    this.currentX_ = this.startX_;

    this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
  }

  handleTouchMove_(evt) {
    if (evt.pointerType && evt.pointerType !== 'touch') {
      return;
    }

    this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
  }

  handleTouchEnd_(evt) {
    if (evt.pointerType && evt.pointerType !== 'touch') {
      return;
    }

    this.prepareForTouchEnd_();

    // Did the user close the drawer by more than 50%?
    if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
      this.close();
    } else {
      // Triggering an open here means we'll get a nice animation back to the fully open state.
      this.open();
    }
  }

  prepareForTouchEnd_() {
    cancelAnimationFrame(this.updateRaf_);
    this.adapter_.setTranslateX(null);
  }

  updateDrawer_() {
    this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
    this.adapter_.setTranslateX(this.newPosition_);
  }

  get newPosition_() {
    let newPos = null;

    if (this.direction_ === 1) {
      newPos = Math.min(0, this.currentX_ - this.startX_);
    } else {
      newPos = Math.max(0, this.currentX_ - this.startX_);
    }

    return newPos;
  }

  isRootTransitioningEventTarget_() {
    // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
    // if the event target is the root event target currently transitioning.
    return false;
  }

  handleTransitionEnd_(evt) {
    if (this.isRootTransitioningEventTarget_(evt.target)) {
      this.adapter_.removeClass(this.animatingCssClass_);
      this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
    }
  };
}

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const cssClasses = {
  ROOT: 'mdc-drawer--temporary',
  OPEN: 'mdc-drawer--open',
  ANIMATING: 'mdc-drawer--animating',
  SCROLL_LOCK: 'mdc-drawer-scroll-lock',
};

const strings = {
  DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
  OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
  FOCUSABLE_ELEMENTS,
  OPEN_EVENT: 'MDCTemporaryDrawer:open',
  CLOSE_EVENT: 'MDCTemporaryDrawer:close',
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class MDCTemporaryDrawerFoundation extends MDCSlidableDrawerFoundation {
  static get cssClasses() {
    return cssClasses;
  }

  static get strings() {
    return strings;
  }

  static get defaultAdapter() {
    return Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, {
      addBodyClass: (/* className: string */) => {},
      removeBodyClass: (/* className: string */) => {},
      isDrawer: () => false,
      updateCssVariable: (/* value: string */) => {},
      eventTargetHasClass: (/* target: EventTarget, className: string */) => /* boolean */ false,
    });
  }

  constructor(adapter) {
    super(
      Object.assign(MDCTemporaryDrawerFoundation.defaultAdapter, adapter),
      MDCTemporaryDrawerFoundation.cssClasses.ROOT,
      MDCTemporaryDrawerFoundation.cssClasses.ANIMATING,
      MDCTemporaryDrawerFoundation.cssClasses.OPEN);

    this.componentClickHandler_ = (evt) => {
      if (this.adapter_.eventTargetHasClass(evt.target, cssClasses.ROOT)) {
        this.close(true);
      }
    };
  }

  init() {
    super.init();

    // Make browser aware of custom property being used in this element.
    // Workaround for certain types of hard-to-reproduce heisenbugs.
    this.adapter_.updateCssVariable(0);
    this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
  }

  destroy() {
    super.destroy();

    this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
    this.enableScroll_();
  }

  open() {
    this.disableScroll_();
    // Make sure custom property values are cleared before starting.
    this.adapter_.updateCssVariable('');

    super.open();
  }

  close() {
    // Make sure custom property values are cleared before making any changes.
    this.adapter_.updateCssVariable('');

    super.close();
  }

  prepareForTouchEnd_() {
    super.prepareForTouchEnd_();

    this.adapter_.updateCssVariable('');
  }

  updateDrawer_() {
    super.updateDrawer_();

    const newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
    this.adapter_.updateCssVariable(newOpacity);
  }

  isRootTransitioningEventTarget_(el) {
    return this.adapter_.isDrawer(el);
  }

  handleTransitionEnd_(evt) {
    super.handleTransitionEnd_(evt);
    if (!this.isOpen_) {
      this.enableScroll_();
    }
  };

  disableScroll_() {
    this.adapter_.addBodyClass(cssClasses.SCROLL_LOCK);
  }

  enableScroll_() {
    this.adapter_.removeBodyClass(cssClasses.SCROLL_LOCK);
  }
}

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const cssClasses$1 = {
  ROOT: 'mdc-drawer--persistent',
  OPEN: 'mdc-drawer--open',
  ANIMATING: 'mdc-drawer--animating',
};

const strings$1 = {
  DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
  FOCUSABLE_ELEMENTS,
  OPEN_EVENT: 'MDCPersistentDrawer:open',
  CLOSE_EVENT: 'MDCPersistentDrawer:close',
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class MDCPersistentDrawerFoundation extends MDCSlidableDrawerFoundation {
  static get cssClasses() {
    return cssClasses$1;
  }

  static get strings() {
    return strings$1;
  }

  static get defaultAdapter() {
    return Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, {
      isDrawer: () => false,
    });
  }

  constructor(adapter) {
    super(
      Object.assign(MDCPersistentDrawerFoundation.defaultAdapter, adapter),
      MDCPersistentDrawerFoundation.cssClasses.ROOT,
      MDCPersistentDrawerFoundation.cssClasses.ANIMATING,
      MDCPersistentDrawerFoundation.cssClasses.OPEN);
  }

  isRootTransitioningEventTarget_(el) {
    return this.adapter_.isDrawer(el);
  }
}

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ FOCUSABLE_ELEMENTS$1 = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' +
    'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';
class MdcDrawer {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} renderer
     * @param {?} elementRef
     * @param {?} _registry
     */
    constructor(_changeDetectorRef, renderer, elementRef, _registry) {
        this._changeDetectorRef = _changeDetectorRef;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        this._fixed = false;
        this._drawer = 'permanent';
        this.closeOnClick = true;
        this.opened = new EventEmitter();
        this.closed = new EventEmitter();
        this.isHostClass = true;
        this.role = 'navigation';
        this._mdcAdapter = {
            addClass: (className) => this.renderer.addClass(this._getHostElement(), className),
            removeClass: (className) => this.renderer.removeClass(this._getHostElement(), className),
            hasClass: (className) => this._getHostElement().classList.contains(className),
            addBodyClass: (className) => {
                if (isBrowser()) {
                    this.renderer.addClass(this.fixedAdjustElement
                        ? this.fixedAdjustElement : document.body, className);
                }
            },
            removeBodyClass: (className) => {
                if (isBrowser()) {
                    this.renderer.removeClass(this.fixedAdjustElement
                        ? this.fixedAdjustElement : document.body, className);
                }
            },
            eventTargetHasClass: (target, className) => target.classList.contains(className),
            hasNecessaryDom: () => !!this.drawerNav,
            registerInteractionHandler: (evt, handler) => this._registry.listen(remapEvent(evt), handler, this._getHostElement(), applyPassive()),
            deregisterInteractionHandler: (evt, handler) => this._registry.unlisten(evt, handler),
            registerDrawerInteractionHandler: (evt, handler) => {
                if (this.drawerElement) {
                    this._registry.listen(remapEvent(evt), handler, this.drawerElement.nativeElement);
                }
            },
            deregisterDrawerInteractionHandler: (evt, handler) => this._registry.unlisten(evt, handler),
            registerTransitionEndHandler: (handler) => {
                if (this.drawerElement) {
                    this._registry.listen('transitionend', handler, this.drawerElement.nativeElement);
                }
            },
            deregisterTransitionEndHandler: (handler) => this._registry.unlisten('transitionend', handler),
            registerDocumentKeydownHandler: (handler) => {
                if (isBrowser()) {
                    this._registry.listen('keydown', handler, document);
                }
            },
            deregisterDocumentKeydownHandler: (handler) => this._registry.unlisten('keydown', handler),
            getDrawerWidth: () => this._getHostElement().offsetWidth,
            setTranslateX: (value) => {
                if (this.drawerNav) {
                    this.renderer.setProperty(this.drawerNav.elementRef, getTransformPropertyName(), value === null ? null : `translateX(${value}px)`);
                }
            },
            updateCssVariable: (value) => {
                if (supportsCssCustomProperties()) {
                    this.renderer.setStyle(this._getHostElement(), '--mdc-temporary-drawer-opacity', value);
                }
            },
            getFocusableElements: () => this.drawerNav ? this.drawerNav.elementRef.nativeElement.querySelectorAll(FOCUSABLE_ELEMENTS$1) : null,
            saveElementTabState: (el) => saveElementTabState(el),
            restoreElementTabState: (el) => restoreElementTabState(el),
            makeElementUntabbable: (el) => this.renderer.setAttribute(el, 'tabindex', '-1'),
            notifyOpen: () => this.opened.emit(),
            notifyClose: () => this.closed.emit(),
            isRtl: () => getComputedStyle(this._getHostElement()).direction === 'rtl',
            isDrawer: (el) => {
                return this.drawerNav ? el === this.drawerNav.elementRef.nativeElement : false;
            }
        };
        this._initializeFoundation(this._drawer);
    }
    /**
     * @return {?}
     */
    get fixed() { return this._fixed; }
    /**
     * @param {?} value
     * @return {?}
     */
    set fixed(value) {
        this.setFixed(value);
    }
    /**
     * @return {?}
     */
    get drawer() { return this._drawer; }
    /**
     * @param {?} drawer
     * @return {?}
     */
    set drawer(drawer) {
        this.setDrawer(drawer);
    }
    /**
     * @return {?}
     */
    get fixedAdjustElement() { return this._fixedAdjustElement; }
    /**
     * @param {?} element
     * @return {?}
     */
    set fixedAdjustElement(element) {
        this.setFixedAdjustElement(element);
    }
    /**
     * @return {?}
     */
    get drawerElement() {
        return this.drawerNav && this.drawerNav.elementRef;
    }
    /**
     * @return {?}
     */
    get classFixed() {
        return this.fixed && this.isDrawerPermanent() ? 'ng-mdc-drawer--fixed' : '';
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._foundation) {
            this._foundation.destroy();
        }
    }
    /**
     * @param {?} drawer
     * @return {?}
     */
    setDrawer(drawer) {
        this._drawer = drawer ? drawer : 'permanent';
        this._initializeFoundation(drawer);
        if (drawer === 'temporary') {
            this._registry.listen('click', () => {
                if (this.closeOnClick) {
                    this._foundation.close();
                }
            }, this.drawerElement.nativeElement);
        }
        else if (drawer === 'temporary') {
            this._registry.unlisten('click', () => {
                if (this.closeOnClick) {
                    this._foundation.close();
                }
            });
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} element
     * @return {?}
     */
    setFixedAdjustElement(element) {
        this._fixedAdjustElement = element;
        if (element) {
            this.renderer.setStyle(this._getHostElement(), 'position', 'absolute');
        }
        else {
            this.renderer.removeStyle(this._getHostElement(), 'position');
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} fixed
     * @return {?}
     */
    setFixed(fixed) {
        this._fixed = fixed;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    isDrawerPermanent() {
        return this._drawer === 'permanent';
    }
    /**
     * @return {?}
     */
    isDrawerTemporary() {
        return this._drawer === 'temporary';
    }
    /**
     * @return {?}
     */
    isDrawerPersistent() {
        return this._drawer === 'persistent';
    }
    /**
     * @param {?} drawer
     * @return {?}
     */
    _initializeFoundation(drawer) {
        this._removeDrawerModifierClass();
        this.renderer.addClass(this._getHostElement(), `mdc-drawer--${drawer}`);
        if (!this.isDrawerPermanent()) {
            if (drawer === 'temporary') {
                this._foundation = new MDCTemporaryDrawerFoundation(this._mdcAdapter);
            }
            else if (drawer === 'persistent') {
                this._foundation = new MDCPersistentDrawerFoundation(this._mdcAdapter);
            }
            this._foundation.init();
        }
        else {
            if (this._foundation) {
                this._foundation.destroy();
            }
        }
    }
    /**
     * @return {?}
     */
    _removeDrawerModifierClass() {
        this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--temporary');
        this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--persistent');
        this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--permanent');
    }
    /**
     * @return {?}
     */
    isOpen() {
        if (this.isDrawerPermanent()) {
            return true;
        }
        return this._foundation.isOpen();
    }
    /**
     * @return {?}
     */
    open() {
        if (this._foundation) {
            this.isOpen() ? this._foundation.close() : this._foundation.open();
        }
    }
    /**
     * @return {?}
     */
    close() {
        if (this._foundation) {
            this._foundation.close();
        }
    }
    /**
     * @return {?}
     */
    getDrawerWidth() {
        return this._foundation ? this._mdcAdapter.getDrawerWidth() : this._getHostElement().offsetWidth;
    }
    /**
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
MdcDrawer.decorators = [
    { type: Component, args: [{selector: 'mdc-drawer',
                exportAs: 'mdcDrawer',
                template: `
  <mdc-drawer-navigation>
    <ng-content></ng-content>
  </mdc-drawer-navigation>
  `,
                providers: [EventRegistry],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcDrawer.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: EventRegistry }
];
MdcDrawer.propDecorators = {
    fixed: [{ type: Input }],
    drawer: [{ type: Input }],
    fixedAdjustElement: [{ type: Input }],
    closeOnClick: [{ type: Input }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-drawer',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    classFixed: [{ type: HostBinding, args: ['class.ng-mdc-drawer--fixed',] }],
    drawerNav: [{ type: ViewChild, args: [MdcDrawerNavigation,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ DRAWER_COMPONENTS = [
    MdcDrawer,
    MdcDrawerContent,
    MdcDrawerHeader,
    MdcDrawerHeaderContent,
    MdcDrawerNavigation,
    MdcDrawerSpacer,
];
class MdcDrawerModule {
}
MdcDrawerModule.decorators = [
    { type: NgModule, args: [{
                exports: DRAWER_COMPONENTS,
                declarations: DRAWER_COMPONENTS,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcDrawerModule, FOCUSABLE_ELEMENTS$1 as FOCUSABLE_ELEMENTS, MdcDrawer, MdcDrawerContent as ɵd14, MdcDrawerHeader as ɵb14, MdcDrawerHeaderContent as ɵc14, MdcDrawerNavigation as ɵe14, MdcDrawerSpacer as ɵa14 };
