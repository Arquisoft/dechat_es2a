/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { Directive, ElementRef, HostBinding, Input, Renderer2, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, EventEmitter, forwardRef, Output, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { startWith, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
import { toBoolean, isBrowser, EventRegistry, toNumber, getSupportedInputTypes } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { MdcFloatingLabel, MdcFloatingLabelModule } from '@angular-mdc/web/floating-label';
import { MdcLineRipple, MdcLineRippleModule } from '@angular-mdc/web/line-ripple';
import { MdcNotchedOutline, MdcNotchedOutlineIdle, MdcNotchedOutlineModule } from '@angular-mdc/web/notched-outline';
import { MdcIcon } from '@angular-mdc/web/icon';
import { CommonModule } from '@angular/common';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
const strings = {
  ARIA_HIDDEN: 'aria-hidden',
  ROLE: 'role',
};

/** @enum {string} */
const cssClasses = {
  HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
  HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg',
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
 * @final
 */
class MDCTextFieldHelperTextFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses;
  }

  /** @return enum {string} */
  static get strings() {
    return strings;
  }

  /**
   * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCTextFieldHelperTextAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCTextFieldHelperTextAdapter} */ ({
      addClass: () => {},
      removeClass: () => {},
      hasClass: () => {},
      setAttr: () => {},
      removeAttr: () => {},
      setContent: () => {},
    });
  }

  /**
   * @param {!MDCTextFieldHelperTextAdapter} adapter
   */
  constructor(adapter) {
    super(Object.assign(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter));
  }

  /**
   * Sets the content of the helper text field.
   * @param {string} content
   */
  setContent(content) {
    this.adapter_.setContent(content);
  }

  /** @param {boolean} isPersistent Sets the persistency of the helper text. */
  setPersistent(isPersistent) {
    if (isPersistent) {
      this.adapter_.addClass(cssClasses.HELPER_TEXT_PERSISTENT);
    } else {
      this.adapter_.removeClass(cssClasses.HELPER_TEXT_PERSISTENT);
    }
  }

  /**
   * @param {boolean} isValidation True to make the helper text act as an
   *   error validation message.
   */
  setValidation(isValidation) {
    if (isValidation) {
      this.adapter_.addClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
    } else {
      this.adapter_.removeClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
    }
  }

  /** Makes the helper text visible to the screen reader. */
  showToScreenReader() {
    this.adapter_.removeAttr(strings.ARIA_HIDDEN);
  }

  /**
   * Sets the validity of the helper text based on the input validity.
   * @param {boolean} inputIsValid
   */
  setValidity(inputIsValid) {
    const helperTextIsPersistent = this.adapter_.hasClass(cssClasses.HELPER_TEXT_PERSISTENT);
    const helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
    const validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

    if (validationMsgNeedsDisplay) {
      this.adapter_.setAttr(strings.ROLE, 'alert');
    } else {
      this.adapter_.removeAttr(strings.ROLE);
    }

    if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
      this.hide_();
    }
  }

  /**
   * Hides the help text from screen readers.
   * @private
   */
  hide_() {
    this.adapter_.setAttr(strings.ARIA_HIDDEN, 'true');
  }
}

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcTextFieldHelperText {
    /**
     * @param {?} _renderer
     * @param {?} elementRef
     */
    constructor(_renderer, elementRef) {
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this.persistent = false;
        this.validation = false;
        this.isHostClass = true;
        this.ariaHidden = 'true';
        this._mdcAdapter = {
            addClass: (className) => this._renderer.addClass(this.elementRef.nativeElement, className),
            removeClass: (className) => this._renderer.removeClass(this.elementRef.nativeElement, className),
            hasClass: (className) => this.elementRef.nativeElement.classList.contains(className),
            setAttr: (attr, value) => this._renderer.setAttribute(this.elementRef.nativeElement, attr, value),
            removeAttr: (attr) => this._renderer.removeAttribute(this.elementRef.nativeElement, attr),
            setContent: (content) => this.elementRef.nativeElement.textContent = content,
        };
        this.foundation = new MDCTextFieldHelperTextFoundation(this._mdcAdapter);
    }
    /**
     * @return {?}
     */
    get classPersistent() {
        return this.persistent ? 'mdc-text-field-helper-text--persistent' : '';
    }
    /**
     * @return {?}
     */
    get classValidation() {
        return this.validation ? 'mdc-text-field-helper-text--validation-msg' : '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.foundation.init();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @return {?}
     */
    destroy() {
        this.foundation.destroy();
    }
    /**
     * Sets the content of the helper text field.
     * @param {?} content
     * @return {?}
     */
    setContent(content) {
        this.foundation.setContent(content);
    }
    /**
     * Sets the validity of the helper text based on the input validity.
     * @param {?} validity
     * @return {?}
     */
    setValidity(validity) {
        this.foundation.setValidity(validity);
    }
    /**
     * Makes the helper text visible to the screen reader.
     * @return {?}
     */
    showToScreenReader() {
        this.foundation.showToScreenReader();
    }
    /**
     * Sets the persistency of the helper text.
     * @param {?} isPersistent
     * @return {?}
     */
    setPersistent(isPersistent) {
        this.persistent = isPersistent;
        this.foundation.setPersistent(isPersistent);
    }
    /**
     * True to make the helper text act as an error validation message.
     * @param {?} isValidation
     * @return {?}
     */
    setValidation(isValidation) {
        this.validation = isValidation;
        this.foundation.setValidation(isValidation);
    }
}
MdcTextFieldHelperText.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-text-field-helper-text], mdc-text-field-helper-text, [mdcTextFieldHelperText]',
                exportAs: 'mdcHelperText'
            },] },
];
/** @nocollapse */
MdcTextFieldHelperText.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
MdcTextFieldHelperText.propDecorators = {
    id: [{ type: Input }],
    persistent: [{ type: Input }],
    validation: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-text-field-helper-text',] }],
    ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }],
    classPersistent: [{ type: HostBinding, args: ['class.mdc-text-field-helper-text--persistent',] }],
    classValidation: [{ type: HostBinding, args: ['class.mdc-text-field-helper-text--validation-msg',] }]
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
const strings$1 = {
  ICON_EVENT: 'MDCTextField:icon',
  ICON_ROLE: 'button',
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
 * @final
 */
class MDCTextFieldIconFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings$1;
  }

  /**
   * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCTextFieldIconAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCTextFieldIconAdapter} */ ({
      getAttr: () => {},
      setAttr: () => {},
      removeAttr: () => {},
      setContent: () => {},
      registerInteractionHandler: () => {},
      deregisterInteractionHandler: () => {},
      notifyIconAction: () => {},
    });
  }

  /**
   * @param {!MDCTextFieldIconAdapter} adapter
   */
  constructor(adapter) {
    super(Object.assign(MDCTextFieldIconFoundation.defaultAdapter, adapter));

    /** @private {string?} */
    this.savedTabIndex_ = null;

    /** @private {function(!Event): undefined} */
    this.interactionHandler_ = (evt) => this.handleInteraction(evt);
  }

  init() {
    this.savedTabIndex_ = this.adapter_.getAttr('tabindex');

    ['click', 'keydown'].forEach((evtType) => {
      this.adapter_.registerInteractionHandler(evtType, this.interactionHandler_);
    });
  }

  destroy() {
    ['click', 'keydown'].forEach((evtType) => {
      this.adapter_.deregisterInteractionHandler(evtType, this.interactionHandler_);
    });
  }

  /** @param {boolean} disabled */
  setDisabled(disabled) {
    if (!this.savedTabIndex_) {
      return;
    }

    if (disabled) {
      this.adapter_.setAttr('tabindex', '-1');
      this.adapter_.removeAttr('role');
    } else {
      this.adapter_.setAttr('tabindex', this.savedTabIndex_);
      this.adapter_.setAttr('role', strings$1.ICON_ROLE);
    }
  }

  /** @param {string} label */
  setAriaLabel(label) {
    this.adapter_.setAttr('aria-label', label);
  }

  /** @param {string} content */
  setContent(content) {
    this.adapter_.setContent(content);
  }

  /**
   * Handles an interaction event
   * @param {!Event} evt
   */
  handleInteraction(evt) {
    if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
      this.adapter_.notifyIconAction();
    }
  }
}

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */
class RippleCapableSurface {}

/** @protected {!Element} */
RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
const strings$3 = {
  ARIA_CONTROLS: 'aria-controls',
  INPUT_SELECTOR: '.mdc-text-field__input',
  LABEL_SELECTOR: '.mdc-floating-label',
  ICON_SELECTOR: '.mdc-text-field__icon',
  OUTLINE_SELECTOR: '.mdc-notched-outline',
  LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
};

/** @enum {string} */
const cssClasses$2 = {
  ROOT: 'mdc-text-field',
  UPGRADED: 'mdc-text-field--upgraded',
  DISABLED: 'mdc-text-field--disabled',
  DENSE: 'mdc-text-field--dense',
  FOCUSED: 'mdc-text-field--focused',
  INVALID: 'mdc-text-field--invalid',
  BOX: 'mdc-text-field--box',
  OUTLINED: 'mdc-text-field--outlined',
};

/** @enum {number} */
const numbers$1 = {
  LABEL_SCALE: 0.75,
  DENSE_LABEL_SCALE: 0.923,
};

// whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
// under section: `Validation-related attributes`
const VALIDATION_ATTR_WHITELIST = [
  'pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength',
];

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @extends {MDCFoundation<!MDCTextFieldAdapter>}
 * @final
 */
class MDCTextFieldFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$2;
  }

  /** @return enum {string} */
  static get strings() {
    return strings$3;
  }

  /** @return enum {string} */
  static get numbers() {
    return numbers$1;
  }

  /** @return {boolean} */
  get shouldShake() {
    return !this.isValid() && !this.isFocused_;
  }

  /** @return {boolean} */
  get shouldFloat() {
    return this.isFocused_ || !!this.getValue() || this.isBadInput_();
  }

  /**
   * {@see MDCTextFieldAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCTextFieldAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCTextFieldAdapter} */ ({
      addClass: () => {},
      removeClass: () => {},
      hasClass: () => {},
      registerTextFieldInteractionHandler: () => {},
      deregisterTextFieldInteractionHandler: () => {},
      registerInputInteractionHandler: () => {},
      deregisterInputInteractionHandler: () => {},
      registerValidationAttributeChangeHandler: () => {},
      deregisterValidationAttributeChangeHandler: () => {},
      getNativeInput: () => {},
      isFocused: () => {},
      isRtl: () => {},
      activateLineRipple: () => {},
      deactivateLineRipple: () => {},
      setLineRippleTransformOrigin: () => {},
      shakeLabel: () => {},
      floatLabel: () => {},
      hasLabel: () => {},
      getLabelWidth: () => {},
      hasOutline: () => {},
      notchOutline: () => {},
      closeOutline: () => {},
    });
  }

  /**
   * @param {!MDCTextFieldAdapter} adapter
   * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
   */
  constructor(adapter, foundationMap = /** @type {!FoundationMapType} */ ({})) {
    super(Object.assign(MDCTextFieldFoundation.defaultAdapter, adapter));

    /** @type {!MDCTextFieldHelperTextFoundation|undefined} */
    this.helperText_ = foundationMap.helperText;
    /** @type {!MDCTextFieldIconFoundation|undefined} */
    this.icon_ = foundationMap.icon;

    /** @private {boolean} */
    this.isFocused_ = false;
    /** @private {boolean} */
    this.receivedUserInput_ = false;
    /** @private {boolean} */
    this.useCustomValidityChecking_ = false;
    /** @private {boolean} */
    this.isValid_ = true;
    /** @private {function(): undefined} */
    this.inputFocusHandler_ = () => this.activateFocus();
    /** @private {function(): undefined} */
    this.inputBlurHandler_ = () => this.deactivateFocus();
    /** @private {function(): undefined} */
    this.inputInputHandler_ = () => this.autoCompleteFocus();
    /** @private {function(!Event): undefined} */
    this.setPointerXOffset_ = (evt) => this.setTransformOrigin(evt);
    /** @private {function(!Event): undefined} */
    this.textFieldInteractionHandler_ = () => this.handleTextFieldInteraction();
    /** @private {function(!Array): undefined} */
    this.validationAttributeChangeHandler_ = (attributesList) => this.handleValidationAttributeChange(attributesList);

    /** @private {!MutationObserver} */
    this.validationObserver_;
  }

  init() {
    this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
    // Ensure label does not collide with any pre-filled value.
    if (this.adapter_.hasLabel() && (this.getValue() || this.isBadInput_())) {
      this.adapter_.floatLabel(this.shouldFloat);
      this.notchOutline(this.shouldFloat);
    }

    if (this.adapter_.isFocused()) {
      this.inputFocusHandler_();
    }

    this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
    this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
    this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
    ['mousedown', 'touchstart'].forEach((evtType) => {
      this.adapter_.registerInputInteractionHandler(evtType, this.setPointerXOffset_);
    });
    ['click', 'keydown'].forEach((evtType) => {
      this.adapter_.registerTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler_);
    });
    this.validationObserver_ =
        this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
  }

  destroy() {
    this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
    this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
    this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
    this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
    ['mousedown', 'touchstart'].forEach((evtType) => {
      this.adapter_.deregisterInputInteractionHandler(evtType, this.setPointerXOffset_);
    });
    ['click', 'keydown'].forEach((evtType) => {
      this.adapter_.deregisterTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler_);
    });
    this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
  }

  /**
   * Handles user interactions with the Text Field.
   */
  handleTextFieldInteraction() {
    if (this.adapter_.getNativeInput().disabled) {
      return;
    }
    this.receivedUserInput_ = true;
  }

  /**
   * Handles validation attribute changes
   * @param {!Array<string>} attributesList
   */
  handleValidationAttributeChange(attributesList) {
    attributesList.some((attributeName) => {
      if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
        this.styleValidity_(true);
        return true;
      }
    });
  }

  /**
   * Opens/closes the notched outline.
   * @param {boolean} openNotch
   */
  notchOutline(openNotch) {
    if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
      return;
    }

    if (openNotch) {
      const isDense = this.adapter_.hasClass(cssClasses$2.DENSE);
      const labelScale = isDense ? numbers$1.DENSE_LABEL_SCALE : numbers$1.LABEL_SCALE;
      const labelWidth = this.adapter_.getLabelWidth() * labelScale;
      const isRtl = this.adapter_.isRtl();
      this.adapter_.notchOutline(labelWidth, isRtl);
    } else {
      this.adapter_.closeOutline();
    }
  }

  /**
   * Activates the text field focus state.
   */
  activateFocus() {
    this.isFocused_ = true;
    this.styleFocused_(this.isFocused_);
    this.adapter_.activateLineRipple();
    this.notchOutline(this.shouldFloat);
    if (this.adapter_.hasLabel()) {
      this.adapter_.shakeLabel(this.shouldShake);
      this.adapter_.floatLabel(this.shouldFloat);
    }
    if (this.helperText_) {
      this.helperText_.showToScreenReader();
    }
  }

  /**
   * Sets the line ripple's transform origin, so that the line ripple activate
   * animation will animate out from the user's click location.
   * @param {!Event} evt
   */
  setTransformOrigin(evt) {
    const targetClientRect = evt.target.getBoundingClientRect();
    const evtCoords = {x: evt.clientX, y: evt.clientY};
    const normalizedX = evtCoords.x - targetClientRect.left;
    this.adapter_.setLineRippleTransformOrigin(normalizedX);
  }

  /**
   * Activates the Text Field's focus state in cases when the input value
   * changes without user input (e.g. programatically).
   */
  autoCompleteFocus() {
    if (!this.receivedUserInput_) {
      this.activateFocus();
    }
  }

  /**
   * Deactivates the Text Field's focus state.
   */
  deactivateFocus() {
    this.isFocused_ = false;
    this.adapter_.deactivateLineRipple();
    const input = this.getNativeInput_();
    const shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
    const isValid = this.isValid();
    this.styleValidity_(isValid);
    this.styleFocused_(this.isFocused_);
    if (this.adapter_.hasLabel()) {
      this.adapter_.shakeLabel(this.shouldShake);
      this.adapter_.floatLabel(this.shouldFloat);
      this.notchOutline(this.shouldFloat);
    }
    if (shouldRemoveLabelFloat) {
      this.receivedUserInput_ = false;
    }
  }

  /**
   * @return {string} The value of the input Element.
   */
  getValue() {
    return this.getNativeInput_().value;
  }

  /**
   * @param {string} value The value to set on the input Element.
   */
  setValue(value) {
    this.getNativeInput_().value = value;
    const isValid = this.isValid();
    this.styleValidity_(isValid);
    if (this.adapter_.hasLabel()) {
      this.adapter_.shakeLabel(this.shouldShake);
      this.adapter_.floatLabel(this.shouldFloat);
      this.notchOutline(this.shouldFloat);
    }
  }

  /**
   * @return {boolean} If a custom validity is set, returns that value.
   *     Otherwise, returns the result of native validity checks.
   */
  isValid() {
    return this.useCustomValidityChecking_
      ? this.isValid_ : this.isNativeInputValid_();
  }

  /**
   * @param {boolean} isValid Sets the validity state of the Text Field.
   */
  setValid(isValid) {
    this.useCustomValidityChecking_ = true;
    this.isValid_ = isValid;
    // Retrieve from the getter to ensure correct logic is applied.
    isValid = this.isValid();
    this.styleValidity_(isValid);
    if (this.adapter_.hasLabel()) {
      this.adapter_.shakeLabel(this.shouldShake);
    }
  }

  /**
   * @return {boolean} True if the Text Field is disabled.
   */
  isDisabled() {
    return this.getNativeInput_().disabled;
  }

  /**
   * @param {boolean} disabled Sets the text-field disabled or enabled.
   */
  setDisabled(disabled) {
    this.getNativeInput_().disabled = disabled;
    this.styleDisabled_(disabled);
  }

  /**
   * @param {string} content Sets the content of the helper text.
   */
  setHelperTextContent(content) {
    if (this.helperText_) {
      this.helperText_.setContent(content);
    }
  }

  /**
   * Sets the aria label of the icon.
   * @param {string} label
   */
  setIconAriaLabel(label) {
    if (this.icon_) {
      this.icon_.setAriaLabel(label);
    }
  }

  /**
   * Sets the text content of the icon.
   * @param {string} content
   */
  setIconContent(content) {
    if (this.icon_) {
      this.icon_.setContent(content);
    }
  }

  /**
   * @return {boolean} True if the Text Field input fails in converting the
   *     user-supplied value.
   * @private
   */
  isBadInput_() {
    return this.getNativeInput_().validity.badInput;
  }

  /**
   * @return {boolean} The result of native validity checking
   *     (ValidityState.valid).
   */
  isNativeInputValid_() {
    return this.getNativeInput_().validity.valid;
  }

  /**
   * Styles the component based on the validity state.
   * @param {boolean} isValid
   * @private
   */
  styleValidity_(isValid) {
    const {INVALID} = MDCTextFieldFoundation.cssClasses;
    if (isValid) {
      this.adapter_.removeClass(INVALID);
    } else {
      this.adapter_.addClass(INVALID);
    }
    if (this.helperText_) {
      this.helperText_.setValidity(isValid);
    }
  }

  /**
   * Styles the component based on the focused state.
   * @param {boolean} isFocused
   * @private
   */
  styleFocused_(isFocused) {
    const {FOCUSED} = MDCTextFieldFoundation.cssClasses;
    if (isFocused) {
      this.adapter_.addClass(FOCUSED);
    } else {
      this.adapter_.removeClass(FOCUSED);
    }
  }

  /**
   * Styles the component based on the disabled state.
   * @param {boolean} isDisabled
   * @private
   */
  styleDisabled_(isDisabled) {
    const {DISABLED, INVALID} = MDCTextFieldFoundation.cssClasses;
    if (isDisabled) {
      this.adapter_.addClass(DISABLED);
      this.adapter_.removeClass(INVALID);
    } else {
      this.adapter_.removeClass(DISABLED);
    }
    if (this.icon_) {
      this.icon_.setDisabled(isDisabled);
    }
  }

  /**
   * @return {!Element|!NativeInputType} The native text input from the
   * host environment, or a dummy if none exists.
   * @private
   */
  getNativeInput_() {
    return this.adapter_.getNativeInput() ||
    /** @type {!NativeInputType} */ ({
      value: '',
      disabled: false,
      validity: {
        badInput: false,
        valid: true,
      },
    });
  }
}

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MdcTextField),
    multi: true
};
// Invalid input type. Using one of these will throw an error.
const /** @type {?} */ MDC_INPUT_INVALID_TYPES = [
    'button',
    'checkbox',
    'color',
    'file',
    'hidden',
    'image',
    'radio',
    'range',
    'reset',
    'submit'
];
let /** @type {?} */ nextUniqueId = 0;
class MdcTextField {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _renderer
     * @param {?} elementRef
     * @param {?} _ripple
     * @param {?} _registry
     */
    constructor(_changeDetectorRef, _renderer, elementRef, _ripple, _registry) {
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._ripple = _ripple;
        this._registry = _registry;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this._uid = `mdc-input-${nextUniqueId++}`;
        this.placeholder = '';
        this.tabIndex = 0;
        this.direction = 'ltr';
        this.iconAction = new EventEmitter();
        this.change = new EventEmitter();
        this.blur = new EventEmitter();
        this.isHostClass = true;
        this._type = 'text';
        this._box = false;
        this._outline = false;
        this._required = false;
        this._focused = false;
        this._mdcAdapter = {
            addClass: (className) => this._renderer.addClass(this._getHostElement(), className),
            removeClass: (className) => this._renderer.removeClass(this._getHostElement(), className),
            hasClass: (className) => this._getHostElement().classList.contains(className),
            registerTextFieldInteractionHandler: (evtType, handler) => this._registry.listen(evtType, handler, this._getHostElement()),
            deregisterTextFieldInteractionHandler: (evtType, handler) => this._registry.unlisten(evtType, handler),
            registerInputInteractionHandler: (evtType, handler) => this._registry.listen(evtType, handler, this.inputText.nativeElement),
            deregisterInputInteractionHandler: (evtType, handler) => this._registry.unlisten(evtType, handler),
            isFocused: () => this._focused,
            isRtl: () => this.direction === 'rtl',
            activateLineRipple: () => {
                if (this.lineRipple) {
                    this.lineRipple.activate();
                }
            },
            deactivateLineRipple: () => {
                if (this.lineRipple) {
                    this.lineRipple.deactivate();
                }
            },
            setLineRippleTransformOrigin: (normalizedX) => {
                if (this.lineRipple) {
                    this.lineRipple.setRippleCenter(normalizedX);
                }
            },
            shakeLabel: (shouldShake) => this.floatingLabel.shake(shouldShake),
            floatLabel: (shouldFloat) => this.floatingLabel.float(shouldFloat),
            hasLabel: () => !!this.floatingLabel,
            getLabelWidth: () => this.floatingLabel.getWidth(),
            hasOutline: () => this.outline,
            notchOutline: (notchWidth, isRtl) => this.outlined.notch(notchWidth, isRtl),
            closeOutline: () => this.outlined.closeNotch(),
            registerValidationAttributeChangeHandler: (handler) => {
                const /** @type {?} */ getAttributesList = (mutationsList) => mutationsList.map((mutation) => mutation.attributeName);
                const /** @type {?} */ observer = new MutationObserver((mutationsList) => handler(getAttributesList(mutationsList)));
                return observer.observe(this.inputText.nativeElement, { attributes: true });
            },
            deregisterValidationAttributeChangeHandler: (observer) => {
                if (observer) {
                    observer.disconnect();
                }
            },
            getNativeInput: () => this.inputText.nativeElement
        };
        this._mdcIconAdapter = {
            getAttr: (attr) => this.icons.first.elementRef.nativeElement.getAttribute(attr),
            setAttr: (attr, value) => this.icons.first.elementRef.nativeElement.setAttribute(attr, value),
            removeAttr: (attr) => this.icons.first.elementRef.nativeElement.removeAttribute(attr),
            setContent: (content) => this.icons.first.elementRef.nativeElement.textContent = content,
            registerInteractionHandler: (evtType, handler) => this._registry.listen(evtType, handler, this.icons.first.elementRef.nativeElement),
            deregisterInteractionHandler: (evtType, handler) => this._registry.unlisten(evtType, handler),
            notifyIconAction: () => this.iconAction.emit(true)
        };
        this._foundation = new MDCTextFieldFoundation(this._mdcAdapter);
        /**
         * View -> model callback called when value changes
         */
        this._onChange = () => { };
        /**
         * View -> model callback called when text field has been touched
         */
        this._onTouched = () => { };
        // Force setter to be called in case id was not specified.
        this.id = this.id;
    }
    /**
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) { this._id = value || this._uid; }
    /**
     * Input type of the element.
     * @return {?}
     */
    get type() { return this._type; }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value || 'text';
        this._validateType();
        // When using Angular inputs, developers are no longer able to set the properties on the native
        // input element. To ensure that bindings for `type` work, we need to sync the setter
        // with the native property. Textarea elements don't support the type property or attribute.
        if (!this.isTextarea() && getSupportedInputTypes().has(this._type)) {
            this.inputText.nativeElement.type = this._type;
        }
    }
    /**
     * @return {?}
     */
    get box() { return this._box; }
    /**
     * @param {?} value
     * @return {?}
     */
    set box(value) {
        this.setBox(value);
    }
    /**
     * @return {?}
     */
    get outline() { return this._outline; }
    /**
     * @param {?} value
     * @return {?}
     */
    set outline(value) {
        this.setOutline(value);
    }
    /**
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this.setDisabled(value);
    }
    /**
     * @return {?}
     */
    get required() { return this._required; }
    /**
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this.setRequired(value);
    }
    /**
     * @return {?}
     */
    get focused() { return this._focused; }
    /**
     * @param {?} value
     * @return {?}
     */
    set focused(value) {
        this._focused = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get fullwidth() { return this._fullwidth; }
    /**
     * @param {?} value
     * @return {?}
     */
    set fullwidth(value) {
        this.setFullwidth(value);
    }
    /**
     * @return {?}
     */
    get dense() { return this._dense; }
    /**
     * @param {?} value
     * @return {?}
     */
    set dense(value) {
        this.setDense(value);
    }
    /**
     * @return {?}
     */
    get helperText() { return this._helperText; }
    /**
     * @param {?} helperText
     * @return {?}
     */
    set helperText(helperText) {
        this.setHelperText(helperText);
    }
    /**
     * The input element's value.
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.setValue(value);
    }
    /**
     * @return {?}
     */
    get valid() {
        return this._useCustomValidity ? this._foundation.isValid() : this.inputText.nativeElement.validity.valid;
    }
    /**
     * Whether the control is empty.
     * @return {?}
     */
    get empty() {
        return !this.inputText.nativeElement.value && !this.isBadInput();
    }
    /**
     * @return {?}
     */
    get classBox() {
        return this.box ? 'mdc-text-field--box' : '';
    }
    /**
     * @return {?}
     */
    get classDense() {
        return this.dense ? 'mdc-text-field--dense' : '';
    }
    /**
     * @return {?}
     */
    get classFullwidth() {
        return this.fullwidth ? 'mdc-text-field--fullwidth' : '';
    }
    /**
     * @return {?}
     */
    get classFocused() {
        return this._focused ? 'mdc-text-field--focused' : '';
    }
    /**
     * @return {?}
     */
    get classOutlined() {
        return this.outline ? 'mdc-text-field--outlined' : '';
    }
    /**
     * Returns a map of all subcomponents to subfoundations.
     * @return {?}
     */
    _getFoundationMap() {
        return {
            helperText: this._helperText ? this.helperText.foundation : undefined,
            icon: this._hasIcons() ? this.icons.first.foundation : undefined
        };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.outline && this.outlined) {
            this.outlined.outlineIdle = this.outlineIdle;
            this._foundation.notchOutline(this.shouldFloat());
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._foundation = new MDCTextFieldFoundation(this._mdcAdapter, this._getFoundationMap());
        this._foundation.init();
        this.icons.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {
            Promise.resolve().then(() => {
                this.icons.forEach(icon => {
                    this._renderer.addClass(icon.elementRef.nativeElement, 'mdc-text-field__icon');
                    if (icon.isLeading() || icon.isTrailing()) {
                        this._iconFoundation = new MDCTextFieldIconFoundation(this._mdcIconAdapter);
                        icon.foundation = this._iconFoundation;
                    }
                });
                this.updateIconState();
                this.writeValue(this._value);
                this._changeDetectorRef.detectChanges();
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._hasIcons()) {
            this.icons.forEach(icon => {
                icon.foundation.destroy();
            });
        }
        this._ripple.destroy();
        this._foundation.destroy();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.setValue(value == null ? '' : value, false);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    shouldFloat() {
        return this._foundation.shouldFloat;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onInput(value) {
        this.setValue(value);
    }
    /**
     * @return {?}
     */
    onFocus() {
        this._focused = true;
    }
    /**
     * @return {?}
     */
    onBlur() {
        this._focused = false;
        this._onTouched();
        this.blur.emit(this.value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    isDisabled() {
        return this._foundation.isDisabled();
    }
    /**
     * @return {?}
     */
    isBadInput() {
        const /** @type {?} */ validity = this.inputText.nativeElement.validity;
        return validity && validity.badInput;
    }
    /**
     * @return {?}
     */
    focus() {
        if (!this.disabled) {
            this._focused = true;
            this.inputText.nativeElement.focus();
        }
    }
    /**
     * @param {?} isValid
     * @return {?}
     */
    setValid(isValid) {
        this._useCustomValidity = true;
        this._foundation.setValid(isValid);
    }
    /**
     * @return {?}
     */
    isTextarea() {
        const /** @type {?} */ nativeElement = this._getHostElement();
        const /** @type {?} */ nodeName = isBrowser ? nativeElement.nodeName : nativeElement.name;
        return nodeName ? nodeName.toLowerCase() === 'textarea' : false;
    }
    /**
     * Sets the text-field required or not.
     * @param {?} required
     * @return {?}
     */
    setRequired(required) {
        this._required = required;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} value
     * @param {?=} isUserInput
     * @return {?}
     */
    setValue(value, isUserInput = true) {
        this._value = (this.type === 'number') ?
            (value === '' ? null : toNumber(value)) : value;
        this._foundation.setValue(this.value);
        if (isUserInput) {
            this._onChange(this.value);
        }
        if (this.required && !this.value) {
            this.setRequired(false);
            setTimeout(() => this.setRequired(true));
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Styles the text field as a box text field.
     * @param {?} box
     * @return {?}
     */
    setBox(box) {
        this._box = toBoolean(box);
        if (this._outline && this._box) {
            this._outline = false;
        }
        this._box ? this._ripple.attachTo(this._getHostElement(), false, this.inputText.nativeElement) : this._ripple.destroy();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Styles the text field as an outlined text field.
     * @param {?} outline
     * @return {?}
     */
    setOutline(outline) {
        this._outline = toBoolean(outline);
        if (this._outline && this._box) {
            this._box = false;
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Styles the text field as a fullwidth text field.
     * @param {?} fullwidth
     * @return {?}
     */
    setFullwidth(fullwidth) {
        this._fullwidth = toBoolean(fullwidth);
        this.placeholder = this.fullwidth ? this.label : '';
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} dense
     * @return {?}
     */
    setDense(dense) {
        this._dense = toBoolean(dense);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    setDisabled(disabled) {
        this.setDisabledState(disabled);
    }
    /**
     * @param {?} helperText
     * @return {?}
     */
    setHelperText(helperText) {
        this._helperText = helperText;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * True if the Text Field is required.
     * @return {?}
     */
    isRequired() {
        return this.required;
    }
    /**
     * @return {?}
     */
    selectAll() {
        this.inputText.nativeElement.select();
    }
    /**
     * The value of the input Element.
     * @return {?}
     */
    getValue() {
        return this._foundation.getValue();
    }
    /**
     * Deactives the Text Field's focus state.
     * @return {?}
     */
    deactivateFocus() {
        this._foundation.deactivateFocus();
    }
    /**
     * Activates the text field focus state.
     * @return {?}
     */
    activateFocus() {
        this._foundation.activateFocus();
    }
    /**
     * Sets the content of the helper text.
     * @param {?} content
     * @return {?}
     */
    setHelperTextContent(content) {
        this._foundation.setHelperTextContent(content);
    }
    /**
     * @param {?} label
     * @return {?}
     */
    setIconAriaLabel(label) {
        this._iconFoundation.setAriaLabel(label);
    }
    /**
     * @param {?} content
     * @return {?}
     */
    setIconContent(content) {
        this._iconFoundation.setContent(content);
    }
    /**
     * @return {?}
     */
    updateIconState() {
        if (this.icons.find(_ => _.isLeading())) {
            this._renderer.addClass(this._getHostElement(), 'mdc-text-field--with-leading-icon');
        }
        else if (this.icons.find(_ => _.isTrailing())) {
            this._renderer.addClass(this._getHostElement(), 'mdc-text-field--with-trailing-icon');
        }
    }
    /**
     * @return {?}
     */
    getLeadingIcon() {
        return this.icons.find((_) => _.isLeading());
    }
    /**
     * @return {?}
     */
    getTrailingIcon() {
        return this.icons.find((_) => _.isTrailing());
    }
    /**
     * @return {?}
     */
    _hasIcons() {
        return this.icons && this.icons.length > 0;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this._disabled = isDisabled;
        this._foundation.setDisabled(isDisabled);
        if (this.focused) {
            this.focused = false;
        }
        if (this._hasIcons()) {
            // Reset the clickable state of mdc-icon
            this.icons.first.clickable = this.icons.first.clickable;
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} className
     * @return {?}
     */
    hasClass(className) {
        return this._getHostElement().classList.contains(className);
    }
    /**
     * Retrieves the DOM element of the component host.
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * Make sure the input is a supported type.
     * @return {?}
     */
    _validateType() {
        if (MDC_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {
            throw Error(`Input type "${this._type}" is not supported.`);
        }
    }
}
MdcTextField.decorators = [
    { type: Component, args: [{selector: 'mdc-text-field',
                exportAs: 'mdcTextField',
                template: `
  <ng-content select="mdc-icon[leading]"></ng-content>
  <input #input class="mdc-text-field__input"
    [id]="id"
    [tabindex]="tabIndex"
    [disabled]="disabled"
    [placeholder]="placeholder"
    [attr.maxlength]="maxlength"
    [required]="required"
    (focus)="onFocus()"
    (blur)="onBlur()"
    (input)="onInput($event.target.value)" />
    <ng-content></ng-content>
    <mdc-floating-label [attr.for]="id" *ngIf="!placeholder">{{label}}</mdc-floating-label>
    <mdc-line-ripple *ngIf="!outline"></mdc-line-ripple>
    <mdc-notched-outline *ngIf="outline"></mdc-notched-outline>
    <mdc-notched-outline-idle *ngIf="outline"></mdc-notched-outline-idle>
  `,
                providers: [
                    MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR,
                    MdcRipple,
                    EventRegistry
                ],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcTextField.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: MdcRipple },
    { type: EventRegistry }
];
MdcTextField.propDecorators = {
    label: [{ type: Input }],
    maxlength: [{ type: Input }],
    placeholder: [{ type: Input }],
    tabIndex: [{ type: Input }],
    direction: [{ type: Input }],
    iconAction: [{ type: Output }],
    change: [{ type: Output }],
    blur: [{ type: Output }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-text-field',] }],
    inputText: [{ type: ViewChild, args: ['input',] }],
    floatingLabel: [{ type: ViewChild, args: [MdcFloatingLabel,] }],
    lineRipple: [{ type: ViewChild, args: [MdcLineRipple,] }],
    icons: [{ type: ContentChildren, args: [MdcIcon,] }],
    outlined: [{ type: ViewChild, args: [MdcNotchedOutline,] }],
    outlineIdle: [{ type: ViewChild, args: [MdcNotchedOutlineIdle,] }],
    id: [{ type: Input }],
    type: [{ type: Input }],
    box: [{ type: Input }],
    outline: [{ type: Input }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    focused: [{ type: Input }],
    fullwidth: [{ type: Input }],
    dense: [{ type: Input }],
    helperText: [{ type: Input }],
    value: [{ type: Input }],
    classBox: [{ type: HostBinding, args: ['class.mdc-text-field--box',] }],
    classDense: [{ type: HostBinding, args: ['class.mdc-text-field--dense',] }],
    classFullwidth: [{ type: HostBinding, args: ['class.mdc-text-field--fullwidth',] }],
    classFocused: [{ type: HostBinding, args: ['class.mdc-text-field--focused',] }],
    classOutlined: [{ type: HostBinding, args: ['class.mdc-text-field--outlined',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MdcTextarea),
    multi: true
};
class MdcTextarea extends MdcTextField {
    constructor() {
        super(...arguments);
        this.isHostClass = true;
    }
}
MdcTextarea.decorators = [
    { type: Component, args: [{selector: 'mdc-textarea',
                exportAs: 'mdcTextarea',
                template: `
  <textarea #input class="mdc-text-field__input"
    type="text"
    [id]="id"
    [rows]="rows"
    [cols]="cols"
    [tabindex]="tabIndex"
    [attr.maxlength]="maxlength"
    [disabled]="disabled"
    [required]="required"
    (blur)="onBlur()"
    (input)="onInput($event.target.value)"></textarea>
    <mdc-floating-label [attr.for]="id">{{label}}</mdc-floating-label>
  `,
                providers: [
                    MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR,
                    MdcRipple,
                    EventRegistry
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
MdcTextarea.propDecorators = {
    rows: [{ type: Input }],
    cols: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-text-field--textarea',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ TEXTFIELD_DECLARATIONS = [
    MdcTextarea,
    MdcTextField,
    MdcTextFieldHelperText,
];
class MdcTextFieldModule {
}
MdcTextFieldModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MdcLineRippleModule,
                    MdcFloatingLabelModule,
                    MdcNotchedOutlineModule
                ],
                exports: TEXTFIELD_DECLARATIONS,
                declarations: TEXTFIELD_DECLARATIONS,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcTextFieldModule, MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR, MdcTextField, MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR, MdcTextarea, MdcTextFieldHelperText };
