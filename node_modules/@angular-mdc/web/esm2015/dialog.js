/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { Directive, ElementRef, HostBinding, Input, Renderer2, Component, ContentChild, ContentChildren, EventEmitter, Optional, Output, SkipSelf, ViewChild, ViewEncapsulation, Inject, InjectionToken, Injectable, Injector, TemplateRef, NgModule } from '@angular/core';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { MdcButton } from '@angular-mdc/web/button';
import { Subject } from 'rxjs';
import { isBrowser, EventRegistry, ESCAPE } from '@angular-mdc/web/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, PortalInjector, TemplatePortal, PortalModule } from '@angular-mdc/web/portal';
import { Overlay, OverlayModule } from '@angular-mdc/web/overlay';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcDialogSurface {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcDialogSurface.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-dialog-surface], mdc-dialog-surface'
            },] },
];
/** @nocollapse */
MdcDialogSurface.ctorParameters = () => [
    { type: ElementRef }
];
MdcDialogSurface.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-dialog__surface',] }]
};
class MdcDialogHeader {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcDialogHeader.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-dialog-header], mdc-dialog-header'
            },] },
];
/** @nocollapse */
MdcDialogHeader.ctorParameters = () => [
    { type: ElementRef }
];
MdcDialogHeader.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-dialog__header',] }]
};
class MdcDialogHeaderTitle {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcDialogHeaderTitle.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-dialog-header-title], mdc-dialog-header-title'
            },] },
];
/** @nocollapse */
MdcDialogHeaderTitle.ctorParameters = () => [
    { type: ElementRef }
];
MdcDialogHeaderTitle.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-dialog__header__title',] }]
};
class MdcDialogBody {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.scrollable = false;
        this.isHostClass = true;
    }
    /**
     * @return {?}
     */
    get classScrollable() {
        return this.scrollable ? 'mdc-dialog__body--scrollable' : '';
    }
}
MdcDialogBody.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-dialog-body], mdc-dialog-body'
            },] },
];
/** @nocollapse */
MdcDialogBody.ctorParameters = () => [
    { type: ElementRef }
];
MdcDialogBody.propDecorators = {
    scrollable: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-dialog__body',] }],
    classScrollable: [{ type: HostBinding, args: ['class.mdc-dialog__body--scrollable',] }]
};
class MdcDialogFooter {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcDialogFooter.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-dialog-footer], mdc-dialog-footer'
            },] },
];
/** @nocollapse */
MdcDialogFooter.ctorParameters = () => [
    { type: ElementRef }
];
MdcDialogFooter.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-dialog__footer',] }]
};
class MdcDialogBackdrop {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcDialogBackdrop.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-dialog-backdrop], mdc-dialog-backdrop'
            },] },
];
/** @nocollapse */
MdcDialogBackdrop.ctorParameters = () => [
    { type: ElementRef }
];
MdcDialogBackdrop.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-dialog__backdrop',] }]
};
class MdcDialogButton extends MdcButton {
    /**
     * @param {?} _renderer
     * @param {?} _elementRef
     * @param {?} _ripple
     */
    constructor(_renderer, _elementRef, _ripple) {
        super(_renderer, _elementRef, _ripple);
        this.accept = false;
        this.cancel = false;
        this.action = false;
        this.focused = false;
    }
    /**
     * @return {?}
     */
    get isFooterButton() {
        return this._renderer.parentNode(this._elementRef) === MdcDialogFooter ? 'mdc-dialog__footer__button' : '';
    }
    /**
     * @return {?}
     */
    get classAction() {
        return this.action ? 'mdc-dialog__action' : '';
    }
    /**
     * @return {?}
     */
    get classAccept() {
        return this.accept ? 'mdc-dialog__footer__button--accept' : '';
    }
    /**
     * @return {?}
     */
    get classCancel() {
        return this.cancel ? 'mdc-dialog__footer__button--cancel' : '';
    }
}
MdcDialogButton.decorators = [
    { type: Directive, args: [{
                selector: 'button[mdc-dialog-button], a[mdc-dialog-button]',
                providers: [MdcRipple]
            },] },
];
/** @nocollapse */
MdcDialogButton.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: MdcRipple }
];
MdcDialogButton.propDecorators = {
    accept: [{ type: Input }],
    cancel: [{ type: Input }],
    action: [{ type: Input }],
    focused: [{ type: Input }],
    isFooterButton: [{ type: HostBinding, args: ['class.mdc-dialog__footer__button',] }],
    classAction: [{ type: HostBinding, args: ['class.mdc-dialog__action',] }],
    classAccept: [{ type: HostBinding, args: ['class.mdc-dialog__footer__button--accept',] }],
    classCancel: [{ type: HostBinding, args: ['class.mdc-dialog__footer__button--cancel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
let /** @type {?} */ uniqueId = 0;
/**
 * Reference to a dialog dispatched from the MdcDialog service.
 * @template T, R
 */
class MdcDialogRef {
    /**
     * @param {?} _overlayRef
     * @param {?} _containerInstance
     * @param {?=} id
     */
    constructor(_overlayRef, _containerInstance, id = `mdc-dialog-${uniqueId++}`) {
        this._overlayRef = _overlayRef;
        this._containerInstance = _containerInstance;
        this.id = id;
        /**
         * Subject for notifying the user that the dialog has finished opening.
         */
        this._afterOpen = new Subject();
        /**
         * Subject for notifying the user that the dialog has finished closing.
         */
        this._afterClosed = new Subject();
        /**
         * Subject for notifying the user that the dialog has started closing.
         */
        this._beforeClose = new Subject();
    }
    /**
     * Closes the dialog.
     * @param {?=} dialogResult
     * @return {?}
     */
    close(dialogResult) {
        this._result = dialogResult;
        this._beforeClose.next(this._result);
        this._beforeClose.complete();
        this._overlayRef.dispose();
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     * @return {?}
     */
    afterOpen() {
        return this._afterOpen.asObservable();
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     * @return {?}
     */
    afterClosed() {
        return this._afterClosed.asObservable();
    }
    /**
     * Gets an observable that is notified when the dialog has started closing.
     * @return {?}
     */
    beforeClose() {
        return this._beforeClose.asObservable();
    }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */
class RippleCapableSurface {}

/** @protected {!Element} */
RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const cssClasses$1 = {
  ROOT: 'mdc-dialog',
  OPEN: 'mdc-dialog--open',
  ANIMATING: 'mdc-dialog--animating',
  BACKDROP: 'mdc-dialog__backdrop',
  SCROLL_LOCK: 'mdc-dialog-scroll-lock',
  ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
  CANCEL_BTN: 'mdc-dialog__footer__button--cancel',
};

const strings$1 = {
  OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
  DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
  ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
  ACCEPT_EVENT: 'MDCDialog:accept',
  CANCEL_EVENT: 'MDCDialog:cancel',
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class MDCDialogFoundation extends MDCFoundation {
  static get cssClasses() {
    return cssClasses$1;
  }

  static get strings() {
    return strings$1;
  }

  static get defaultAdapter() {
    return {
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      addBodyClass: (/* className: string */) => {},
      removeBodyClass: (/* className: string */) => {},
      eventTargetHasClass: (/* target: EventTarget, className: string */) => /* boolean */ false,
      registerInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      deregisterInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      registerSurfaceInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      deregisterSurfaceInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      registerDocumentKeydownHandler: (/* handler: EventListener */) => {},
      deregisterDocumentKeydownHandler: (/* handler: EventListener */) => {},
      registerTransitionEndHandler: (/* handler: EventListener */) => {},
      deregisterTransitionEndHandler: (/* handler: EventListener */) => {},
      notifyAccept: () => {},
      notifyCancel: () => {},
      trapFocusOnSurface: () => {},
      untrapFocusOnSurface: () => {},
      isDialog: (/* el: Element */) => /* boolean */ false,
    };
  }

  constructor(adapter) {
    super(Object.assign(MDCDialogFoundation.defaultAdapter, adapter));
    this.isOpen_ = false;
    this.componentClickHandler_ = (evt) => {
      if (this.adapter_.eventTargetHasClass(evt.target, cssClasses$1.BACKDROP)) {
        this.cancel(true);
      }
    };
    this.dialogClickHandler_ = (evt) => this.handleDialogClick_(evt);
    this.documentKeydownHandler_ = (evt) => {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        this.cancel(true);
      }
    };
    this.transitionEndHandler_ = (evt) => this.handleTransitionEnd_(evt);
  };

  destroy() {
    // Ensure that dialog is cleaned up when destroyed
    if (this.isOpen_) {
      this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
      this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
      this.adapter_.untrapFocusOnSurface();
      this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
      this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
      this.enableScroll_();
    }
  }

  open() {
    this.isOpen_ = true;
    this.disableScroll_();
    this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
    this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
    this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
  }

  close() {
    this.isOpen_ = false;
    this.enableScroll_();
    this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
    this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
    this.adapter_.untrapFocusOnSurface();
    this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
    this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
  }

  isOpen() {
    return this.isOpen_;
  }

  accept(shouldNotify) {
    if (shouldNotify) {
      this.adapter_.notifyAccept();
    }

    this.close();
  }

  cancel(shouldNotify) {
    if (shouldNotify) {
      this.adapter_.notifyCancel();
    }

    this.close();
  }

  handleDialogClick_(evt) {
    const {target} = evt;
    if (this.adapter_.eventTargetHasClass(target, cssClasses$1.ACCEPT_BTN)) {
      this.accept(true);
    } else if (this.adapter_.eventTargetHasClass(target, cssClasses$1.CANCEL_BTN)) {
      this.cancel(true);
    }
  }

  handleTransitionEnd_(evt) {
    if (this.adapter_.isDialog(evt.target)) {
      this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
      if (this.isOpen_) {
        this.adapter_.trapFocusOnSurface();
      }    }  };

  disableScroll_() {
    this.adapter_.addBodyClass(cssClasses$1.SCROLL_LOCK);
  }

  enableScroll_() {
    this.adapter_.removeBodyClass(cssClasses$1.SCROLL_LOCK);
  }
}

var tabbable = function(el, options) {
  options = options || {};

  var elementDocument = el.ownerDocument || el;
  var basicTabbables = [];
  var orderedTabbables = [];

  // A node is "available" if
  // - it's computed style
  var isUnavailable = createIsUnavailable(elementDocument);

  var candidateSelectors = [
    'input',
    'select',
    'a[href]',
    'textarea',
    'button',
    '[tabindex]',
  ];

  var candidates = el.querySelectorAll(candidateSelectors.join(','));

  if (options.includeContainer) {
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    if (
      candidateSelectors.some(function(candidateSelector) {
        return matches.call(el, candidateSelector);
      })
    ) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var candidate, candidateIndexAttr, candidateIndex;
  for (var i = 0, l = candidates.length; i < l; i++) {
    candidate = candidates[i];
    candidateIndexAttr = parseInt(candidate.getAttribute('tabindex'), 10);
    candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;

    if (
      candidateIndex < 0
      || (candidate.tagName === 'INPUT' && candidate.type === 'hidden')
      || candidate.disabled
      || isUnavailable(candidate, elementDocument)
    ) {
      continue;
    }

    if (candidateIndex === 0) {
      basicTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        index: i,
        tabIndex: candidateIndex,
        node: candidate,
      });
    }
  }

  var tabbableNodes = orderedTabbables
    .sort(function(a, b) {
      return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
    })
    .map(function(a) {
      return a.node
    });

  Array.prototype.push.apply(tabbableNodes, basicTabbables);

  return tabbableNodes;
};

function createIsUnavailable(elementDocument) {
  // Node cache must be refreshed on every check, in case
  // the content of the element has changed
  var isOffCache = [];

  // "off" means `display: none;`, as opposed to "hidden",
  // which means `visibility: hidden;`. getComputedStyle
  // accurately reflects visiblity in context but not
  // "off" state, so we need to recursively check parents.

  function isOff(node, nodeComputedStyle) {
    if (node === elementDocument.documentElement) return false;

    // Find the cached node (Array.prototype.find not available in IE9)
    for (var i = 0, length = isOffCache.length; i < length; i++) {
      if (isOffCache[i][0] === node) return isOffCache[i][1];
    }

    nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

    var result = false;

    if (nodeComputedStyle.display === 'none') {
      result = true;
    } else if (node.parentNode) {
      result = isOff(node.parentNode);
    }

    isOffCache.push([node, result]);

    return result;
  }

  return function isUnavailable(node) {
    if (node === elementDocument.documentElement) return false;

    var computedStyle = elementDocument.defaultView.getComputedStyle(node);

    if (isOff(node, computedStyle)) return true;

    return computedStyle.visibility === 'hidden';
  }
}

var listeningFocusTrap = null;

function focusTrap(element, userOptions) {
  var tabbableNodes = [];
  var firstTabbableNode = null;
  var lastTabbableNode = null;
  var nodeFocusedBeforeActivation = null;
  var active = false;
  var paused = false;
  var tabEvent = null;

  var container = (typeof element === 'string')
    ? document.querySelector(element)
    : element;

  var config = userOptions || {};
  config.returnFocusOnDeactivate = (userOptions && userOptions.returnFocusOnDeactivate !== undefined)
    ? userOptions.returnFocusOnDeactivate
    : true;
  config.escapeDeactivates = (userOptions && userOptions.escapeDeactivates !== undefined)
    ? userOptions.escapeDeactivates
    : true;

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause,
  };

  return trap;

  function activate(activateOptions) {
    if (active) return;

    var defaultedActivateOptions = {
      onActivate: (activateOptions && activateOptions.onActivate !== undefined)
        ? activateOptions.onActivate
        : config.onActivate,
    };

    active = true;
    paused = false;
    nodeFocusedBeforeActivation = document.activeElement;

    if (defaultedActivateOptions.onActivate) {
      defaultedActivateOptions.onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!active) return;

    var defaultedDeactivateOptions = {
      returnFocus: (deactivateOptions && deactivateOptions.returnFocus !== undefined)
        ? deactivateOptions.returnFocus
        : config.returnFocusOnDeactivate,
      onDeactivate: (deactivateOptions && deactivateOptions.onDeactivate !== undefined)
        ? deactivateOptions.onDeactivate
        : config.onDeactivate,
    };

    removeListeners();

    if (defaultedDeactivateOptions.onDeactivate) {
      defaultedDeactivateOptions.onDeactivate();
    }

    if (defaultedDeactivateOptions.returnFocus) {
      setTimeout(function () {
        tryFocus(nodeFocusedBeforeActivation);
      }, 0);
    }

    active = false;
    paused = false;
    return this;
  }

  function pause() {
    if (paused || !active) return;
    paused = true;
    removeListeners();
  }

  function unpause() {
    if (!paused || !active) return;
    paused = false;
    addListeners();
  }

  function addListeners() {
    if (!active) return;

    // There can be only one listening focus trap at a time
    if (listeningFocusTrap) {
      listeningFocusTrap.pause();
    }
    listeningFocusTrap = trap;

    updateTabbableNodes();
    // Ensure that the focused element doesn't capture the event that caused the focus trap activation
    setTimeout(function () {
      tryFocus(firstFocusNode());
    }, 0);
    document.addEventListener('focus', checkFocus, true);
    document.addEventListener('click', checkClick, true);
    document.addEventListener('mousedown', checkPointerDown, true);
    document.addEventListener('touchstart', checkPointerDown, true);
    document.addEventListener('keydown', checkKey, true);

    return trap;
  }

  function removeListeners() {
    if (!active || listeningFocusTrap !== trap) return;

    document.removeEventListener('focus', checkFocus, true);
    document.removeEventListener('click', checkClick, true);
    document.removeEventListener('mousedown', checkPointerDown, true);
    document.removeEventListener('touchstart', checkPointerDown, true);
    document.removeEventListener('keydown', checkKey, true);

    listeningFocusTrap = null;

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = document.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function firstFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(document.activeElement)) {
      node = document.activeElement;
    } else {
      node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error('You can\'t have a focus-trap without at least one focusable element');
    }

    return node;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event
  function checkPointerDown(e) {
    if (config.clickOutsideDeactivates && !container.contains(e.target)) {
      deactivate({ returnFocus: false });
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) return;
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function checkFocus(e) {
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
    // Checking for a blur method here resolves a Firefox issue (#15)
    if (typeof e.target.blur === 'function') e.target.blur();

    if (tabEvent) {
      readjustFocus(tabEvent);
    }
  }

  function checkKey(e) {
    if (e.key === 'Tab' || e.keyCode === 9) {
      handleTab(e);
    }

    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      deactivate();
    }
  }

  function handleTab(e) {
    updateTabbableNodes();

    if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
      return tabEvent = e;
    }

    e.preventDefault();
    var currentFocusIndex = tabbableNodes.indexOf(e.target);

    if (e.shiftKey) {
      if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
        return tryFocus(lastTabbableNode);
      }
      return tryFocus(tabbableNodes[currentFocusIndex - 1]);
    }

    if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

    tryFocus(tabbableNodes[currentFocusIndex + 1]);
  }

  function updateTabbableNodes() {
    tabbableNodes = tabbable(container);
    firstTabbableNode = tabbableNodes[0];
    lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
  }

  function readjustFocus(e) {
    if (e.shiftKey) return tryFocus(lastTabbableNode);

    tryFocus(firstTabbableNode);
  }
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function tryFocus(node) {
  if (!node || !node.focus) return;
  if (node === document.activeElement)  return;

  node.focus();
  if (node.tagName.toLowerCase() === 'input') {
    node.select();
  }
}

var focusTrap_1 = focusTrap;

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function createFocusTrapInstance(surfaceEl, acceptButtonEl, focusTrapFactory = focusTrap_1) {
  return focusTrapFactory(surfaceEl, {
    initialFocus: acceptButtonEl,
    clickOutsideDeactivates: true,
  });
}

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcDialogComponent {
    /**
     * @param {?} _renderer
     * @param {?} elementRef
     * @param {?} _registry
     * @param {?} dialogRef
     */
    constructor(_renderer, elementRef, _registry, dialogRef) {
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        this.dialogRef = dialogRef;
        /**
         * ID of the element that should be considered as the dialog's label.
         */
        this._ariaLabelledBy = null;
        this.clickOutsideToClose = true;
        this.escapeToClose = true;
        this.isHostClass = true;
        this.ariaHidden = 'true';
        this.tabIndex = -1;
        this._accept = new EventEmitter();
        this._cancel = new EventEmitter();
        this._mdcAdapter = {
            addClass: (className) => this._renderer.addClass(this.elementRef.nativeElement, className),
            removeClass: (className) => this._renderer.removeClass(this.elementRef.nativeElement, className),
            addBodyClass: (className) => {
                if (isBrowser()) {
                    this._renderer.addClass(document.body, className);
                }
            },
            removeBodyClass: (className) => {
                if (isBrowser()) {
                    this._renderer.removeClass(document.body, className);
                }
            },
            eventTargetHasClass: (target, className) => target.classList.contains(className),
            registerInteractionHandler: (evt, handler) => {
                const /** @type {?} */ clickOutsideToClose = this._config ? this._config.clickOutsideToClose : this.clickOutsideToClose;
                handler = this.dialogSurface && clickOutsideToClose ? handler : (event) => {
                    if ((/** @type {?} */ (event.target)).classList.contains('mdc-dialog__footer__button--accept')) {
                        this.accept();
                    }
                    else if ((/** @type {?} */ (event.target)).classList.contains('mdc-dialog__footer__button--cancel')) {
                        this.cancel();
                    }
                };
                this._registry.listen(evt, handler, this.elementRef.nativeElement);
            },
            deregisterInteractionHandler: (evt, handler) => this._registry.unlisten(evt, handler),
            registerSurfaceInteractionHandler: (evt, handler) => this._registry.listen(evt, handler, this.dialogSurface.elementRef.nativeElement),
            deregisterSurfaceInteractionHandler: (evt, handler) => this._registry.unlisten(evt, handler),
            registerDocumentKeydownHandler: (handler) => {
                if (!isBrowser()) {
                    return;
                }
                const /** @type {?} */ escapeToClose = this._config ? this._config.escapeToClose : this.escapeToClose;
                handler = escapeToClose ? handler : this._onKeyDown;
                this._registry.listen('keydown', handler, document);
            },
            deregisterDocumentKeydownHandler: (handler) => {
                if (!isBrowser()) {
                    return;
                }
                const /** @type {?} */ escapeToClose = this._config ? this._config.escapeToClose : this.escapeToClose;
                handler = escapeToClose ? handler : this._onKeyDown;
                this._registry.unlisten('keydown', handler);
            },
            registerTransitionEndHandler: (handler) => {
                if (this.dialogSurface) {
                    this._registry.listen('transitionend', handler, this.dialogSurface.elementRef.nativeElement);
                }
            },
            deregisterTransitionEndHandler: (handler) => {
                if (this.dialogSurface) {
                    this._registry.unlisten('transitionend', handler);
                }
            },
            notifyAccept: () => {
                this._accept.emit('MDCDialog:accept');
                if (this.dialogRef) {
                    this.dialogRef.close();
                }
            },
            notifyCancel: () => {
                this._cancel.emit('MDCDialog:cancel');
                if (this.dialogRef) {
                    this.dialogRef.close();
                }
            },
            trapFocusOnSurface: () => {
                if (this._focusTrap) {
                    this._focusTrap.activate();
                }
            },
            untrapFocusOnSurface: () => {
                if (this._focusTrap) {
                    this._focusTrap.deactivate();
                }
            },
            isDialog: (el) => this.dialogSurface ? el === this.dialogSurface.elementRef.nativeElement : false
        };
        this._foundation = new MDCDialogFoundation(this._mdcAdapter);
        if (this.dialogRef) {
            this._config = this.dialogRef._containerInstance._config;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._foundation.init();
        if (this._config) {
            this.show();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._foundation.destroy();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onKeyDown(event) {
        if (ESCAPE === event.keyCode) {
            event.stopPropagation();
        }
    }
    /**
     * @return {?}
     */
    show() {
        const /** @type {?} */ focusedEl = this.dialogButtons.find((_) => _.focused || _.accept);
        if (isBrowser()) {
            this._focusTrap = createFocusTrapInstance(this.dialogSurface.elementRef.nativeElement, {
                initialFocus: focusedEl ? focusedEl.getHostElement() : this.elementRef.nativeElement,
                clickOutsideDeactivates: this._config ? this._config.clickOutsideToClose : this.clickOutsideToClose,
                escapeDeactivates: this._config ? this._config.escapeToClose : this.escapeToClose,
            });
        }
        setTimeout(() => {
            this._foundation.open();
            if (focusedEl) {
                focusedEl.focus();
            }
        }, 10);
    }
    /**
     * @return {?}
     */
    close() {
        this._foundation.close();
    }
    /**
     * @return {?}
     */
    isOpen() {
        return this._foundation.isOpen();
    }
    /**
     * @param {?=} shouldNotify
     * @return {?}
     */
    accept(shouldNotify = true) {
        this._foundation.accept(shouldNotify);
    }
    /**
     * @param {?=} shouldNotify
     * @return {?}
     */
    cancel(shouldNotify = true) {
        this._foundation.cancel(shouldNotify);
    }
}
MdcDialogComponent.decorators = [
    { type: Component, args: [{selector: 'mdc-dialog',
                template: `
  <mdc-dialog-surface>
    <ng-content></ng-content>
  </mdc-dialog-surface>
  <mdc-dialog-backdrop></mdc-dialog-backdrop>
  `,
                host: {
                    '[attr.role]': '_config?.role',
                    '[attr.aria-labelledby]': '_config?.ariaLabel ? null : _ariaLabelledBy',
                    '[attr.aria-label]': '_config?.ariaLabel',
                    '[attr.aria-describedby]': '_config?.ariaDescribedBy || null',
                },
                providers: [EventRegistry],
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcDialogComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: EventRegistry },
    { type: MdcDialogRef, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
MdcDialogComponent.propDecorators = {
    clickOutsideToClose: [{ type: Input }],
    escapeToClose: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-dialog',] }],
    ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }],
    tabIndex: [{ type: HostBinding, args: ['tabindex',] }],
    _accept: [{ type: Output, args: ['accept',] }],
    _cancel: [{ type: Output, args: ['cancel',] }],
    dialogSurface: [{ type: ViewChild, args: [MdcDialogSurface,] }],
    dialogBody: [{ type: ContentChild, args: [MdcDialogBody,] }],
    dialogButtons: [{ type: ContentChildren, args: [MdcDialogButton, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcDialogContainer extends BasePortalOutlet {
    /**
     * @param {?} elementRef
     * @param {?} _document
     */
    constructor(elementRef, _document) {
        super();
        this.elementRef = elementRef;
        this._document = _document;
        /**
         * Element that was focused before the dialog was opened. Save this to restore upon close.
         */
        this._elementFocusedBeforeDialogWasOpened = null;
    }
    /**
     * Attach a component portal as content to this container.
     * @template T
     * @param {?} portal
     * @return {?}
     */
    attachComponentPortal(portal) {
        this._savePreviouslyFocusedElement();
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @template C
     * @param {?} portal Portal to be attached as the dialog content.
     * @return {?}
     */
    attachTemplatePortal(portal) {
        this._savePreviouslyFocusedElement();
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    /**
     * Saves a reference to the element that was focused before the dialog was opened.
     * @return {?}
     */
    _savePreviouslyFocusedElement() {
        if (this._document) {
            this._elementFocusedBeforeDialogWasOpened = /** @type {?} */ (this._document.activeElement);
        }
    }
}
MdcDialogContainer.decorators = [
    { type: Component, args: [{selector: 'mdc-dialog-container',
                template: `<ng-template cdkPortalOutlet></ng-template>`,
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcDialogContainer.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
MdcDialogContainer.propDecorators = {
    _portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ MDC_DIALOG_DATA = new InjectionToken('MdcDialogData');
class MdcDialogConfig {
    constructor() {
        /**
         * The ARIA role of the dialog element.
         */
        this.role = 'dialog';
        /**
         * ID of the element that describes the dialog.
         */
        this.ariaDescribedBy = null;
        /**
         * Aria label to assign to the dialog element
         */
        this.ariaLabel = null;
        /**
         * Whether the user can use escape key to close the dialog
         */
        this.escapeToClose = true;
        /**
         * Whether the user can click outside to close the dialog
         */
        this.clickOutsideToClose = true;
        /**
         * Data being injected into the child component.
         */
        this.data = null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcDialog {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _parentDialog
     */
    constructor(_overlay, _injector, _parentDialog) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._parentDialog = _parentDialog;
        this._openedDialogRef = null;
    }
    /**
     * Shows a dialog with a message and an optional action.
     * @template T
     * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
     *     or a TemplateRef to instantiate as the dialog content.
     * @param {?=} config Additional configuration options for the dialog.
     * @return {?} Reference to the newly-opened dialog.
     */
    open(componentOrTemplateRef, config) {
        const /** @type {?} */ _config = _applyConfigDefaults(config);
        if (this._openedDialogRef) {
            this._openedDialogRef.close();
        }
        config = _applyConfigDefaults(config);
        const /** @type {?} */ overlayRef = this._createOverlay();
        const /** @type {?} */ dialogContainer = this._attachDialogContainer(overlayRef, config);
        const /** @type {?} */ dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
        this._openedDialogRef = dialogRef;
        return dialogRef;
    }
    /**
     * @return {?}
     */
    close() {
        if (this._openedDialogRef) {
            this._openedDialogRef.close();
        }
    }
    /**
     * Attaches the dialog container component to the overlay.
     * @param {?} overlay
     * @param {?} config
     * @return {?}
     */
    _attachDialogContainer(overlay, config) {
        const /** @type {?} */ containerPortal = new ComponentPortal(MdcDialogContainer, config.viewContainerRef);
        const /** @type {?} */ containerRef = overlay.attach(containerPortal);
        containerRef.instance._config = config;
        return containerRef.instance;
    }
    /**
     * Creates a new overlay.
     * @return {?}
     */
    _createOverlay() {
        return this._overlay.create();
    }
    /**
     * Attaches the user-provided component to the already-created MdcDialogContainer.
     * @template T
     * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
     *     or a TemplateRef to instantiate as the content.
     * @param {?} dialogContainer Reference to the wrapping MdcDialogContainer.
     * @param {?} overlayRef Reference to the overlay in which the dialog resides.
     * @param {?} config The dialog configuration.
     * @return {?} A promise resolving to the MdcDialogRef that should be returned to the user.
     */
    _attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config) {
        // Create a reference to the dialog we're creating in order to give the user a handle
        // to modify and close it.
        const /** @type {?} */ dialogRef = new MdcDialogRef(overlayRef, dialogContainer, config.id);
        if (componentOrTemplateRef instanceof TemplateRef) {
            dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, /** @type {?} */ ((null)), /** @type {?} */ ({ $implicit: config.data, dialogRef })));
        }
        else {
            const /** @type {?} */ injector = this._createInjector(config, dialogRef, dialogContainer);
            const /** @type {?} */ contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, undefined, injector));
            dialogRef.componentInstance = contentRef.instance;
        }
        return dialogRef;
    }
    /**
     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
     * of a dialog to close itself and, optionally, to return a value.
     * @template T
     * @param {?} config Config object that is used to construct the dialog.
     * @param {?} dialogRef Reference to the dialog.
     * @param {?} dialogContainer
     * @return {?} The custom injector that can be used inside the dialog.
     */
    _createInjector(config, dialogRef, dialogContainer) {
        const /** @type {?} */ userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const /** @type {?} */ injectionTokens = new WeakMap();
        injectionTokens.set(MdcDialogRef, dialogRef);
        injectionTokens.set(MdcDialogContainer, dialogContainer);
        injectionTokens.set(MDC_DIALOG_DATA, config.data);
        injectionTokens.set(MdcDialogConfig, config);
        return new PortalInjector(userInjector || this._injector, injectionTokens);
    }
}
MdcDialog.decorators = [
    { type: Injectable },
];
/** @nocollapse */
MdcDialog.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: MdcDialog, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
/**
 * Applies default options to the dialog config.
 * @param {?=} config The configuration to which the defaults will be applied.
 * @return {?} The new configuration object with defaults applied.
 */
function _applyConfigDefaults(config) {
    return Object.assign({}, new MdcDialogConfig(), config);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ DIALOG_DECLARATIONS = [
    MdcDialogComponent,
    MdcDialogContainer,
    MdcDialogBackdrop,
    MdcDialogBody,
    MdcDialogButton,
    MdcDialogFooter,
    MdcDialogHeader,
    MdcDialogHeaderTitle,
    MdcDialogSurface,
];
class MdcDialogModule {
}
MdcDialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    PortalModule
                ],
                exports: [
                    DIALOG_DECLARATIONS
                ],
                declarations: DIALOG_DECLARATIONS,
                providers: [MdcDialog],
                entryComponents: [
                    MdcDialogContainer,
                    MdcDialogComponent
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcDialogModule, MdcDialog, MDC_DIALOG_DATA, MdcDialogConfig, MdcDialogContainer, MdcDialogSurface, MdcDialogHeader, MdcDialogHeaderTitle, MdcDialogBody, MdcDialogFooter, MdcDialogBackdrop, MdcDialogButton, MdcDialogRef, MdcDialogComponent };
