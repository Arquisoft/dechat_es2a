/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, Output, Renderer2, ViewEncapsulation, ContentChildren, NgZone, ViewChild, NgModule } from '@angular/core';
import { EventRegistry, toBoolean } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { defer, merge, Subject } from 'rxjs';
import { startWith, switchMap, take, takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Change event that is fired whenever the selected state of an option changes.
 */
class MdcListSelectionChange {
    /**
     * @param {?} source
     */
    constructor(source) {
        this.source = source;
    }
}
let /** @type {?} */ uniqueIdCounter = 0;
class MdcListItemGraphic {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
        this.ariaHidden = 'true';
    }
}
MdcListItemGraphic.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListItemGraphic], [mdc-list-item-graphic], mdc-list-item-graphic',
                exportAs: 'mdcListItemGraphic',
            },] },
];
/** @nocollapse */
MdcListItemGraphic.ctorParameters = () => [
    { type: ElementRef }
];
MdcListItemGraphic.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item__graphic',] }],
    ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }]
};
class MdcListItemMeta {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListItemMeta.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListItemMeta], [mdc-list-item-meta], mdc-list-item-meta',
                exportAs: 'mdcListItemMeta',
            },] },
];
/** @nocollapse */
MdcListItemMeta.ctorParameters = () => [
    { type: ElementRef }
];
MdcListItemMeta.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item__meta',] }]
};
class MdcListItemText {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListItemText.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListItemText], [mdc-list-item-text], mdc-list-item-text',
                exportAs: 'mdcListItemText',
            },] },
];
/** @nocollapse */
MdcListItemText.ctorParameters = () => [
    { type: ElementRef }
];
MdcListItemText.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item__text',] }]
};
class MdcListItemSecondary {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListItemSecondary.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListItemSecondary], [mdc-list-item-secondary], mdc-list-item-secondary',
                exportAs: 'mdcListItemSecondary',
            },] },
];
/** @nocollapse */
MdcListItemSecondary.ctorParameters = () => [
    { type: ElementRef }
];
MdcListItemSecondary.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item__secondary-text',] }]
};
class MdcListItem {
    /**
     * @param {?} ripple
     * @param {?} _changeDetector
     * @param {?} _renderer
     * @param {?} elementRef
     */
    constructor(ripple, _changeDetector, _renderer, elementRef) {
        this.ripple = ripple;
        this._changeDetector = _changeDetector;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._id = `mdc-list-item-${uniqueIdCounter++}`;
        this.isHostClass = true;
        this.role = 'listitem';
        this.selectionChange = new EventEmitter();
    }
    /**
     * The unique ID of the option.
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * @return {?}
     */
    get classSelected() {
        return this.selected ? 'mdc-list-item--selected' : '';
    }
    /**
     * @return {?}
     */
    onclick() {
        this.setSelected(!this.selected);
        this._emitChangeEvent();
    }
    /**
     * Whether the option is selected.
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        this.setSelected(value);
    }
    /**
     * Sets the selected state of the option.
     * @param {?} selected
     * @return {?}
     */
    setSelected(selected) {
        this._selected = selected;
        this._changeDetector.markForCheck();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.ripple.destroy();
    }
    /**
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * Emits a change event if the selected state of an option changed.
     * @return {?}
     */
    _emitChangeEvent() {
        this.selectionChange.emit(new MdcListSelectionChange(this));
    }
}
MdcListItem.decorators = [
    { type: Component, args: [{selector: 'mdc-list-item, a[mdc-list-item]',
                exportAs: 'mdcListItem',
                host: {
                    '[id]': 'id',
                },
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    EventRegistry,
                    MdcRipple
                ]
            },] },
];
/** @nocollapse */
MdcListItem.ctorParameters = () => [
    { type: MdcRipple },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];
MdcListItem.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    classSelected: [{ type: HostBinding, args: ['class.mdc-list-item--selected',] }],
    selectionChange: [{ type: Output }],
    listItemStart: [{ type: ContentChild, args: [MdcListItemGraphic,] }],
    onclick: [{ type: HostListener, args: ['click', ['$event'],] }],
    selected: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Change event that is being fired whenever the selected state of an option changes.
 */
class MdcListItemChange {
    /**
     * @param {?} source
     * @param {?} option
     */
    constructor(source, option) {
        this.source = source;
        this.option = option;
    }
}
class MdcListGroup {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListGroup.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-list-group], mdc-list-group',
                exportAs: 'mdcListGroup',
            },] },
];
/** @nocollapse */
MdcListGroup.ctorParameters = () => [
    { type: ElementRef }
];
MdcListGroup.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-group',] }]
};
class MdcListGroupSubheader {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListGroupSubheader.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListGroupSubheader], [mdc-list-group-subheader], mdc-list-group-subheader',
                exportAs: 'mdcListGroupSubheader',
            },] },
];
/** @nocollapse */
MdcListGroupSubheader.ctorParameters = () => [
    { type: ElementRef }
];
MdcListGroupSubheader.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-group__subheader',] }]
};
class MdcListDivider {
    /**
     * @param {?} _renderer
     */
    constructor(_renderer) {
        this._renderer = _renderer;
        this._inset = false;
        this._padded = false;
    }
    /**
     * @return {?}
     */
    get inset() { return this._inset; }
    /**
     * @param {?} value
     * @return {?}
     */
    set inset(value) {
        this._inset = toBoolean(value);
        this._inset ? this._renderer.addClass(this.nativeEl.nativeElement, 'mdc-list-divider--inset')
            : this._renderer.removeClass(this.nativeEl.nativeElement, 'mdc-list-divider--inset');
    }
    /**
     * @return {?}
     */
    get padded() { return this._padded; }
    /**
     * @param {?} value
     * @return {?}
     */
    set padded(value) {
        this._padded = toBoolean(value);
        this._padded ? this._renderer.addClass(this.nativeEl.nativeElement, 'mdc-list-divider--padded')
            : this._renderer.removeClass(this.nativeEl.nativeElement, 'mdc-list-divider--padded');
    }
}
MdcListDivider.decorators = [
    { type: Component, args: [{selector: '[mdc-list-divider], mdc-list-divider',
                exportAs: 'mdcListDivider',
                template: '<div #nativeEl class="mdc-list-divider" role="seperator"></div>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcListDivider.ctorParameters = () => [
    { type: Renderer2 }
];
MdcListDivider.propDecorators = {
    inset: [{ type: Input }],
    padded: [{ type: Input }],
    nativeEl: [{ type: ViewChild, args: ['nativeEl',] }]
};
class MdcList {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _ngZone
     * @param {?} elementRef
     */
    constructor(_changeDetectorRef, _ngZone, elementRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this.elementRef = elementRef;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this.dense = false;
        this.lines = 1;
        this.border = false;
        this._interactive = true;
        this.isHostClass = true;
        this.role = 'list';
        /**
         * Emits a change event whenever the selected state of an option changes.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Combined stream of all of the child options' change events.
         */
        this.optionSelectionChanges = defer(() => {
            if (this.options) {
                return merge(...this.options.map(option => option.selectionChange));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap(() => this.optionSelectionChanges));
        });
    }
    /**
     * @return {?}
     */
    get avatar() { return this._avatar; }
    /**
     * @param {?} value
     * @return {?}
     */
    set avatar(value) {
        this._avatar = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get interactive() { return this._interactive; }
    /**
     * @param {?} value
     * @return {?}
     */
    set interactive(value) {
        if (value !== this._interactive) {
            this.setInteractive(value);
        }
    }
    /**
     * @return {?}
     */
    get multiple() { return this._multiple; }
    /**
     * @param {?} value
     * @return {?}
     */
    set multiple(value) {
        this.setMultiple(value);
    }
    /**
     * @return {?}
     */
    get classDense() {
        return this.dense ? 'mdc-list--dense' : '';
    }
    /**
     * @return {?}
     */
    get classLines() {
        return this.lines === 2 ? 'mdc-list--two-line' : '';
    }
    /**
     * @return {?}
     */
    get classAvatar() {
        return this.avatar ? 'mdc-list--avatar-list' : '';
    }
    /**
     * @return {?}
     */
    get classBorder() {
        return this.border ? 'ng-mdc-list--border' : '';
    }
    /**
     * @return {?}
     */
    get classInteractive() {
        return !this.interactive ? 'mdc-list--non-interactive' : '';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.optionSelectionChanges.pipe(takeUntil(merge(this._destroy, this.options.changes))).subscribe(event => {
            this.selectionChange.emit(new MdcListItemChange(this, event.source));
        });
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {
            Promise.resolve().then(() => {
                this.setInteractive(this.interactive);
                if (!this.multiple) {
                    this._resetOptions();
                }
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * Drops current option subscriptions and IDs and resets from scratch.
     * @return {?}
     */
    _resetOptions() {
        const /** @type {?} */ changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges
            .pipe(takeUntil(changedOrDestroyed)).subscribe(event => {
            if (!this.multiple) {
                this.clearSelected(event.source);
            }
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setInteractive(value) {
        this._interactive = toBoolean(value);
        if (!this.options) {
            return;
        }
        this.options.forEach(option => {
            if (value) {
                option.ripple.attachTo(option._getHostElement());
            }
            else {
                option.ripple.destroy();
            }
        });
    }
    /**
     * @param {?} multiple
     * @return {?}
     */
    setMultiple(multiple) {
        this._multiple = multiple;
        this.clearSelected();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?=} skip
     * @return {?}
     */
    clearSelected(skip) {
        if (!this.options) {
            return;
        }
        this.options.forEach(option => {
            if (option !== skip) {
                option.setSelected(false);
            }
        });
    }
}
MdcList.decorators = [
    { type: Component, args: [{selector: 'mdc-list',
                exportAs: 'mdcList',
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcList.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: ElementRef }
];
MdcList.propDecorators = {
    dense: [{ type: Input }],
    lines: [{ type: Input }],
    border: [{ type: Input }],
    avatar: [{ type: Input }],
    interactive: [{ type: Input }],
    multiple: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    classDense: [{ type: HostBinding, args: ['class.mdc-list--dense',] }],
    classLines: [{ type: HostBinding, args: ['class.mdc-list--two-line',] }],
    classAvatar: [{ type: HostBinding, args: ['class.mdc-list--avatar-list',] }],
    classBorder: [{ type: HostBinding, args: ['class.ng-mdc-list--border',] }],
    classInteractive: [{ type: HostBinding, args: ['class.mdc-list--non-interactive',] }],
    options: [{ type: ContentChildren, args: [MdcListItem, { descendants: true },] }],
    selectionChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ LIST_DECLARATIONS = [
    MdcList,
    MdcListDivider,
    MdcListGroup,
    MdcListGroupSubheader,
    MdcListItem,
    MdcListItemGraphic,
    MdcListItemMeta,
    MdcListItemSecondary,
    MdcListItemText,
];
class MdcListModule {
}
MdcListModule.decorators = [
    { type: NgModule, args: [{
                exports: LIST_DECLARATIONS,
                declarations: LIST_DECLARATIONS,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcListModule, MdcListSelectionChange, MdcListItemGraphic, MdcListItemMeta, MdcListItemText, MdcListItemSecondary, MdcListItem, MdcListItemChange, MdcListGroup, MdcListGroupSubheader, MdcListDivider, MdcList };
