/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, forwardRef, HostBinding, HostListener, Input, Output, Renderer2, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { toBoolean, EventRegistry, SPACE } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { MdcIcon, MdcIconModule } from '@angular-mdc/web/icon';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
const cssClasses = {
  ROOT: 'mdc-icon-toggle',
  DISABLED: 'mdc-icon-toggle--disabled',
};

/** @enum {string} */
const strings = {
  DATA_TOGGLE_ON: 'data-toggle-on',
  DATA_TOGGLE_OFF: 'data-toggle-off',
  ARIA_PRESSED: 'aria-pressed',
  ARIA_DISABLED: 'aria-disabled',
  ARIA_LABEL: 'aria-label',
  CHANGE_EVENT: 'MDCIconToggle:change',
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCIconToggleAdapter>}
 */
class MDCIconToggleFoundation extends MDCFoundation {
  static get cssClasses() {
    return cssClasses;
  }

  static get strings() {
    return strings;
  }

  static get defaultAdapter() {
    return {
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      registerInteractionHandler: (/* type: string, handler: EventListener */) => {},
      deregisterInteractionHandler: (/* type: string, handler: EventListener */) => {},
      setText: (/* text: string */) => {},
      getTabIndex: () => /* number */ 0,
      setTabIndex: (/* tabIndex: number */) => {},
      getAttr: (/* name: string */) => /* string */ '',
      setAttr: (/* name: string, value: string */) => {},
      rmAttr: (/* name: string */) => {},
      notifyChange: (/* evtData: IconToggleEvent */) => {},
    };
  }

  constructor(adapter) {
    super(Object.assign(MDCIconToggleFoundation.defaultAdapter, adapter));

    /** @private {boolean} */
    this.on_ = false;

    /** @private {boolean} */
    this.disabled_ = false;

    /** @private {number} */
    this.savedTabIndex_ = -1;

    /** @private {?IconToggleState} */
    this.toggleOnData_ = null;

    /** @private {?IconToggleState} */
    this.toggleOffData_ = null;

    this.clickHandler_ = /** @private {!EventListener} */ (
      () => this.toggleFromEvt_());

    /** @private {boolean} */
    this.isHandlingKeydown_ = false;

    this.keydownHandler_ = /** @private {!EventListener} */ ((/** @type {!KeyboardKey} */ evt) => {
      if (isSpace(evt)) {
        this.isHandlingKeydown_ = true;
        return evt.preventDefault();
      }
    });

    this.keyupHandler_ = /** @private {!EventListener} */ ((/** @type {!KeyboardKey} */ evt) => {
      if (isSpace(evt)) {
        this.isHandlingKeydown_ = false;
        this.toggleFromEvt_();
      }
    });
  }

  init() {
    this.refreshToggleData();
    this.savedTabIndex_ = this.adapter_.getTabIndex();
    this.adapter_.registerInteractionHandler('click', this.clickHandler_);
    this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
    this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
  }

  refreshToggleData() {
    const {DATA_TOGGLE_ON, DATA_TOGGLE_OFF} = MDCIconToggleFoundation.strings;
    this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
    this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
  }

  destroy() {
    this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
    this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
    this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
  }

  /** @private */
  toggleFromEvt_() {
    this.toggle();
    const {on_: isOn} = this;
    this.adapter_.notifyChange(/** @type {!IconToggleEvent} */ ({isOn}));
  }

  /** @return {boolean} */
  isOn() {
    return this.on_;
  }

  /** @param {boolean=} isOn */
  toggle(isOn = !this.on_) {
    this.on_ = isOn;

    const {ARIA_LABEL, ARIA_PRESSED} = MDCIconToggleFoundation.strings;

    if (this.on_) {
      this.adapter_.setAttr(ARIA_PRESSED, 'true');
    } else {
      this.adapter_.setAttr(ARIA_PRESSED, 'false');
    }

    const {cssClass: classToRemove} =
        this.on_ ? this.toggleOffData_ : this.toggleOnData_;

    if (classToRemove) {
      this.adapter_.removeClass(classToRemove);
    }

    const {content, label, cssClass} = this.on_ ? this.toggleOnData_ : this.toggleOffData_;

    if (cssClass) {
      this.adapter_.addClass(cssClass);
    }
    if (content) {
      this.adapter_.setText(content);
    }
    if (label) {
      this.adapter_.setAttr(ARIA_LABEL, label);
    }
  }

  /**
   * @param {string} dataAttr
   * @return {!IconToggleState}
   */
  parseJsonDataAttr_(dataAttr) {
    const val = this.adapter_.getAttr(dataAttr);
    if (!val) {
      return {};
    }
    return /** @type {!IconToggleState} */ (JSON.parse(val));
  }

  /** @return {boolean} */
  isDisabled() {
    return this.disabled_;
  }

  /** @param {boolean} isDisabled */
  setDisabled(isDisabled) {
    this.disabled_ = isDisabled;

    const {DISABLED} = MDCIconToggleFoundation.cssClasses;
    const {ARIA_DISABLED} = MDCIconToggleFoundation.strings;

    if (this.disabled_) {
      this.savedTabIndex_ = this.adapter_.getTabIndex();
      this.adapter_.setTabIndex(-1);
      this.adapter_.setAttr(ARIA_DISABLED, 'true');
      this.adapter_.addClass(DISABLED);
    } else {
      this.adapter_.setTabIndex(this.savedTabIndex_);
      this.adapter_.rmAttr(ARIA_DISABLED);
      this.adapter_.removeClass(DISABLED);
    }
  }

  /** @return {boolean} */
  isKeyboardActivated() {
    return this.isHandlingKeydown_;
  }
}

/**
 * @param {!KeyboardKey} keyboardKey
 * @return {boolean}
 */
function isSpace(keyboardKey) {
  return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
}


/** @record */
class IconToggleState {}

/**
 * The aria-label value of the icon toggle, or undefined if there is no aria-label.
 * @export {string|undefined}
 */
IconToggleState.prototype.label;

/**
 * The text for the icon toggle, or undefined if there is no text.
 * @export {string|undefined}
 */
IconToggleState.prototype.content;

/**
 * The CSS class to add to the icon toggle, or undefined if there is no CSS class.
 * @export {string|undefined}
 */
IconToggleState.prototype.cssClass;

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */
class RippleCapableSurface {}

/** @protected {!Element} */
RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ MD_ICON_TOGGLE_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MdcIconToggle),
    multi: true
};
class MdcIconToggle {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _renderer
     * @param {?} elementRef
     * @param {?} ripple
     * @param {?} _registry
     */
    constructor(_changeDetectorRef, _renderer, elementRef, ripple, _registry) {
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this.ripple = ripple;
        this._registry = _registry;
        this.onChange = () => { };
        this.onTouched = () => { };
        this.change = new EventEmitter();
        this.isHostClass = true;
        this.role = 'button';
        this.ariaPressed = 'false';
        this.tabindex = '0';
        this._mdcAdapter = {
            addClass: (className) => this._renderer.addClass(this.iconClass ? this._getIconElement() : this._getHostElement(), className),
            removeClass: (className) => this._renderer.removeClass(this.iconClass ? this._getIconElement() : this._getHostElement(), className),
            registerInteractionHandler: (type, handler) => this._registry.listen(type, handler, this._getHostElement()),
            deregisterInteractionHandler: (type, handler) => this._registry.unlisten(type, handler),
            setText: (text) => this._getIconElement().textContent = text,
            getTabIndex: () => this._getHostElement().tabIndex,
            setTabIndex: (tabIndex) => this._getHostElement().tabIndex = tabIndex,
            getAttr: (name) => this._getHostElement().getAttribute(name),
            setAttr: (name, value) => this._renderer.setAttribute(this._getHostElement(), name, value),
            rmAttr: (name) => this._renderer.removeAttribute(this._getHostElement(), name),
            notifyChange: (evtData) => {
                this.change.emit(evtData.isOn);
                this.onChange(this._foundation.isOn());
            }
        };
        this._foundation = new MDCIconToggleFoundation(this._mdcAdapter);
    }
    /**
     * @return {?}
     */
    get iconClass() { return this._iconClass; }
    /**
     * @param {?} value
     * @return {?}
     */
    set iconClass(value) {
        this.setIconClass(value);
    }
    /**
     * @return {?}
     */
    get on() { return this._foundation.isOn(); }
    /**
     * @param {?} value
     * @return {?}
     */
    set on(value) {
        this.setOn(value);
    }
    /**
     * @return {?}
     */
    get value() { return this._foundation.isOn(); }
    /**
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this.setDisabled(value);
    }
    /**
     * @return {?}
     */
    get primary() { return this._primary; }
    /**
     * @param {?} value
     * @return {?}
     */
    set primary(value) {
        this.setPrimary(value);
    }
    /**
     * @return {?}
     */
    get secondary() { return this._secondary; }
    /**
     * @param {?} value
     * @return {?}
     */
    set secondary(value) {
        this.setSecondary(value);
    }
    /**
     * @return {?}
     */
    get classPrimary() {
        return this.primary ? 'ng-mdc-icon-toggle--primary' : '';
    }
    /**
     * @return {?}
     */
    get classSecondary() {
        return this.secondary ? 'ng-mdc-icon-toggle--secondary' : '';
    }
    /**
     * @return {?}
     */
    get dataToggleOn() {
        return JSON.stringify({
            content: this.iconOn,
            label: this.labelOn,
            cssClass: this.cssClassOn
        });
    }
    /**
     * @return {?}
     */
    get dataToggleOff() {
        return JSON.stringify({
            content: this.iconOff,
            label: this.labelOff,
            cssClass: this.cssClassOff
        });
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onclick(evt) {
        this._onClick(evt);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onkeydown(evt) {
        this._onKeydown(evt);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._foundation.init();
        this._foundation.refreshToggleData();
        this._foundation.toggle(this._on || this._foundation.isOn());
        this.ripple.attachTo(this._getHostElement(), true);
        this._changeDetectorRef.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.ripple.destroy();
        this._foundation.destroy();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.onChange(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?=} isOn
     * @return {?}
     */
    toggle(isOn) {
        this._foundation.toggle(isOn);
    }
    /**
     * @return {?}
     */
    refreshToggleData() {
        this._foundation.refreshToggleData();
    }
    /**
     * @param {?} iconClass
     * @return {?}
     */
    setIconClass(iconClass) {
        this._renderer.removeClass(this._getIconElement(), this._iconClass);
        this._iconClass = iconClass ? iconClass : 'material-icons';
        this._renderer.addClass(this._getIconElement(), this._iconClass);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    isOn() {
        return this._foundation.isOn();
    }
    /**
     * @param {?} on
     * @return {?}
     */
    setOn(on) {
        if (on !== this._on) {
            this._on = on;
            this._foundation.refreshToggleData();
            this._foundation.toggle(on);
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @param {?} primary
     * @return {?}
     */
    setPrimary(primary) {
        this._primary = toBoolean(primary);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} secondary
     * @return {?}
     */
    setSecondary(secondary) {
        this._secondary = toBoolean(secondary);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Sets the button disabled state
     * @param {?} disabled
     * @return {?}
     */
    setDisabled(disabled) {
        this._disabled = disabled;
        this._foundation.setDisabled(disabled);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onClick(event) {
        // A disabled button shouldn't apply any actions
        if (this.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onKeydown(event) {
        if (this.disabled) {
            return;
        }
        if (event.keyCode === SPACE) {
            this.ripple.setSurfaceActive(true);
        }
        else {
            this.ripple.setSurfaceActive(false);
        }
    }
    /**
     * @return {?}
     */
    _getIconElement() {
        return this.icon.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
MdcIconToggle.decorators = [
    { type: Component, args: [{selector: 'mdc-icon-toggle',
                exportAs: 'mdcIconToggle',
                template: '<mdc-icon></mdc-icon>',
                providers: [
                    MD_ICON_TOGGLE_CONTROL_VALUE_ACCESSOR,
                    MdcRipple,
                    EventRegistry,
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcIconToggle.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: MdcRipple },
    { type: EventRegistry }
];
MdcIconToggle.propDecorators = {
    iconOn: [{ type: Input }],
    iconOff: [{ type: Input }],
    labelOn: [{ type: Input }],
    labelOff: [{ type: Input }],
    cssClassOn: [{ type: Input }],
    cssClassOff: [{ type: Input }],
    iconClass: [{ type: Input }],
    on: [{ type: Input }],
    disabled: [{ type: Input }],
    primary: [{ type: Input }],
    secondary: [{ type: Input }],
    change: [{ type: Output }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-icon-toggle',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaPressed: [{ type: HostBinding, args: ['attr.aria-pressed',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabIndex',] }],
    classPrimary: [{ type: HostBinding, args: ['class.ng-mdc-icon-toggle--primary',] }],
    classSecondary: [{ type: HostBinding, args: ['class.ng-mdc-icon-toggle--secondary',] }],
    dataToggleOn: [{ type: HostBinding, args: ['attr.data-toggle-on',] }],
    dataToggleOff: [{ type: HostBinding, args: ['attr.data-toggle-off',] }],
    onclick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onkeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    icon: [{ type: ViewChild, args: [MdcIcon,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcIconToggleModule {
}
MdcIconToggleModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    MdcIconModule
                ],
                exports: [
                    MdcIconToggle,
                    MdcIconModule,
                ],
                declarations: [MdcIconToggle]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcIconToggleModule, MD_ICON_TOGGLE_CONTROL_VALUE_ACCESSOR, MdcIconToggle };
