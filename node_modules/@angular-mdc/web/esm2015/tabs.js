/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, HostBinding, Input, Output, Renderer2, ViewEncapsulation, ContentChildren, NgZone, ViewChild, NgModule } from '@angular/core';
import { Subject, defer, merge } from 'rxjs';
import { takeUntil, startWith, switchMap, take } from 'rxjs/operators';
import { MdcRouter, toBoolean, EventRegistry, isBrowser, toNumber, MdcRouterModule } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { MdcIcon } from '@angular-mdc/web/icon';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */
class RippleCapableSurface {}

/** @protected {!Element} */
RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const cssClasses$1 = {
  ACTIVE: 'mdc-tab--active',
};

const strings$1 = {
  SELECTED_EVENT: 'MDCTab:selected',
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class MDCTabFoundation extends MDCFoundation {
  static get cssClasses() {
    return cssClasses$1;
  }

  static get strings() {
    return strings$1;
  }

  static get defaultAdapter() {
    return {
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      registerInteractionHandler: (/* type: string, handler: EventListener */) => {},
      deregisterInteractionHandler: (/* type: string, handler: EventListener */) => {},
      getOffsetWidth: () => /* number */ 0,
      getOffsetLeft: () => /* number */ 0,
      notifySelected: () => {},
    };
  }

  constructor(adapter = {}) {
    super(Object.assign(MDCTabFoundation.defaultAdapter, adapter));

    this.computedWidth_ = 0;
    this.computedLeft_ = 0;
    this.isActive_ = false;
    this.preventDefaultOnClick_ = false;

    this.clickHandler_ = (evt) => {
      if (this.preventDefaultOnClick_) {
        evt.preventDefault();
      }
      this.adapter_.notifySelected();
    };

    this.keydownHandler_ = (evt) => {
      if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
        this.adapter_.notifySelected();
      }
    };
  }

  init() {
    this.adapter_.registerInteractionHandler('click', this.clickHandler_);
    this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
  }

  destroy() {
    this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
    this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
  }

  getComputedWidth() {
    return this.computedWidth_;
  }

  getComputedLeft() {
    return this.computedLeft_;
  }

  isActive() {
    return this.isActive_;
  }

  setActive(isActive) {
    this.isActive_ = isActive;
    if (this.isActive_) {
      this.adapter_.addClass(cssClasses$1.ACTIVE);
    } else {
      this.adapter_.removeClass(cssClasses$1.ACTIVE);
    }
  }

  preventsDefaultOnClick() {
    return this.preventDefaultOnClick_;
  }

  setPreventDefaultOnClick(preventDefaultOnClick) {
    this.preventDefaultOnClick_ = preventDefaultOnClick;
  }

  measureSelf() {
    this.computedWidth_ = this.adapter_.getOffsetWidth();
    this.computedLeft_ = this.adapter_.getOffsetLeft();
  }
}

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const {Object<string, !VendorPropertyMapType>} */
const eventTypeMap = {
  'animationstart': {
    noPrefix: 'animationstart',
    webkitPrefix: 'webkitAnimationStart',
    styleProperty: 'animation',
  },
  'animationend': {
    noPrefix: 'animationend',
    webkitPrefix: 'webkitAnimationEnd',
    styleProperty: 'animation',
  },
  'animationiteration': {
    noPrefix: 'animationiteration',
    webkitPrefix: 'webkitAnimationIteration',
    styleProperty: 'animation',
  },
  'transitionend': {
    noPrefix: 'transitionend',
    webkitPrefix: 'webkitTransitionEnd',
    styleProperty: 'transition',
  },
};

/** @const {Object<string, !VendorPropertyMapType>} */
const cssPropertyMap = {
  'animation': {
    noPrefix: 'animation',
    webkitPrefix: '-webkit-animation',
  },
  'transform': {
    noPrefix: 'transform',
    webkitPrefix: '-webkit-transform',
  },
  'transition': {
    noPrefix: 'transition',
    webkitPrefix: '-webkit-transition',
  },
};

/**
 * @param {!Object} windowObj
 * @return {boolean}
 */
function hasProperShape(windowObj) {
  return (windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function');
}

/**
 * @param {string} eventType
 * @return {boolean}
 */
function eventFoundInMaps(eventType) {
  return (eventType in eventTypeMap || eventType in cssPropertyMap);
}

/**
 * @param {string} eventType
 * @param {!Object<string, !VendorPropertyMapType>} map
 * @param {!Element} el
 * @return {string}
 */
function getJavaScriptEventName(eventType, map, el) {
  return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
}

/**
 * Helper function to determine browser prefix for CSS3 animation events
 * and property names.
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getAnimationName(windowObj, eventType) {
  if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
    return eventType;
  }

  const map = /** @type {!Object<string, !VendorPropertyMapType>} */ (
    eventType in eventTypeMap ? eventTypeMap : cssPropertyMap
  );
  const el = windowObj['document']['createElement']('div');
  let eventName = '';

  if (map === eventTypeMap) {
    eventName = getJavaScriptEventName(eventType, map, el);
  } else {
    eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  return eventName;
}

/**
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getCorrectPropertyName(windowObj, eventType) {
  return getAnimationName(windowObj, eventType);
}

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const cssClasses$2 = {
  UPGRADED: 'mdc-tab-bar-upgraded',
};

const strings$2 = {
  TAB_SELECTOR: '.mdc-tab',
  INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
  CHANGE_EVENT: 'MDCTabBar:change',
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class MDCTabBarFoundation extends MDCFoundation {
  static get cssClasses() {
    return cssClasses$2;
  }

  static get strings() {
    return strings$2;
  }

  static get defaultAdapter() {
    return {
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      bindOnMDCTabSelectedEvent: () => {},
      unbindOnMDCTabSelectedEvent: () => {},
      registerResizeHandler: (/* handler: EventListener */) => {},
      deregisterResizeHandler: (/* handler: EventListener */) => {},
      getOffsetWidth: () => /* number */ 0,
      setStyleForIndicator: (/* propertyName: string, value: string */) => {},
      getOffsetWidthForIndicator: () => /* number */ 0,
      notifyChange: (/* evtData: {activeTabIndex: number} */) => {},
      getNumberOfTabs: () => /* number */ 0,
      isTabActiveAtIndex: (/* index: number */) => /* boolean */ false,
      setTabActiveAtIndex: (/* index: number, isActive: true */) => {},
      isDefaultPreventedOnClickForTabAtIndex: (/* index: number */) => /* boolean */ false,
      setPreventDefaultOnClickForTabAtIndex: (/* index: number, preventDefaultOnClick: boolean */) => {},
      measureTabAtIndex: (/* index: number */) => {},
      getComputedWidthForTabAtIndex: (/* index: number */) => /* number */ 0,
      getComputedLeftForTabAtIndex: (/* index: number */) => /* number */ 0,
    };
  }

  constructor(adapter) {
    super(Object.assign(MDCTabBarFoundation.defaultAdapter, adapter));

    this.isIndicatorShown_ = false;
    this.computedWidth_ = 0;
    this.computedLeft_ = 0;
    this.activeTabIndex_ = 0;
    this.layoutFrame_ = 0;
    this.resizeHandler_ = () => this.layout();
  }

  init() {
    this.adapter_.addClass(cssClasses$2.UPGRADED);
    this.adapter_.bindOnMDCTabSelectedEvent();
    this.adapter_.registerResizeHandler(this.resizeHandler_);
    const activeTabIndex = this.findActiveTabIndex_();
    if (activeTabIndex >= 0) {
      this.activeTabIndex_ = activeTabIndex;
    }
    this.layout();
  }

  destroy() {
    this.adapter_.removeClass(cssClasses$2.UPGRADED);
    this.adapter_.unbindOnMDCTabSelectedEvent();
    this.adapter_.deregisterResizeHandler(this.resizeHandler_);
  }

  layoutInternal_() {
    this.forEachTabIndex_((index) => this.adapter_.measureTabAtIndex(index));
    this.computedWidth_ = this.adapter_.getOffsetWidth();
    this.layoutIndicator_();
  }

  layoutIndicator_() {
    const isIndicatorFirstRender = !this.isIndicatorShown_;

    // Ensure that indicator appears in the right position immediately for correct first render.
    if (isIndicatorFirstRender) {
      this.adapter_.setStyleForIndicator('transition', 'none');
    }

    const translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
    const scaleAmtForActiveTabWidth =
      this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();

    const transformValue = `translateX(${translateAmtForActiveTabLeft}px) scale(${scaleAmtForActiveTabWidth}, 1)`;
    this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);

    if (isIndicatorFirstRender) {
      // Force layout so that transform styles to take effect.
      this.adapter_.getOffsetWidthForIndicator();
      this.adapter_.setStyleForIndicator('transition', '');
      this.adapter_.setStyleForIndicator('visibility', 'visible');
      this.isIndicatorShown_ = true;
    }
  }

  findActiveTabIndex_() {
    let activeTabIndex = -1;
    this.forEachTabIndex_((index) => {
      if (this.adapter_.isTabActiveAtIndex(index)) {
        activeTabIndex = index;
        return true;
      }
    });
    return activeTabIndex;
  }

  forEachTabIndex_(iterator) {
    const numTabs = this.adapter_.getNumberOfTabs();
    for (let index = 0; index < numTabs; index++) {
      const shouldBreak = iterator(index);
      if (shouldBreak) {
        break;
      }
    }
  }

  layout() {
    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
    }

    this.layoutFrame_ = requestAnimationFrame(() => {
      this.layoutInternal_();
      this.layoutFrame_ = 0;
    });
  }

  switchToTabAtIndex(index, shouldNotify) {
    if (index === this.activeTabIndex_) {
      return;
    }

    if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
      throw new Error(`Out of bounds index specified for tab: ${index}`);
    }

    const prevActiveTabIndex = this.activeTabIndex_;
    this.activeTabIndex_ = index;
    requestAnimationFrame(() => {
      if (prevActiveTabIndex >= 0) {
        this.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
      }
      this.adapter_.setTabActiveAtIndex(this.activeTabIndex_, true);
      this.layoutIndicator_();
      if (shouldNotify) {
        this.adapter_.notifyChange({activeTabIndex: this.activeTabIndex_});
      }
    });
  }

  getActiveTabIndex() {
    return this.findActiveTabIndex_();
  }
}

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const cssClasses$3 = {
  INDICATOR_FORWARD: 'mdc-tab-bar-scroller__indicator--forward',
  INDICATOR_BACK: 'mdc-tab-bar-scroller__indicator--back',
  INDICATOR_ENABLED: 'mdc-tab-bar-scroller__indicator--enabled',
  TAB: 'mdc-tab',
};

const strings$3 = {
  FRAME_SELECTOR: '.mdc-tab-bar-scroller__scroll-frame',
  TABS_SELECTOR: '.mdc-tab-bar-scroller__scroll-frame__tabs',
  TAB_SELECTOR: '.mdc-tab',
  INDICATOR_FORWARD_SELECTOR: '.mdc-tab-bar-scroller__indicator--forward',
  INDICATOR_BACK_SELECTOR: '.mdc-tab-bar-scroller__indicator--back',
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class MDCTabBarScrollerFoundation extends MDCFoundation {
  static get cssClasses() {
    return cssClasses$3;
  }

  static get strings() {
    return strings$3;
  }

  static get defaultAdapter() {
    return {
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      eventTargetHasClass: (/* target: EventTarget, className: string */) => /* boolean */ false,
      addClassToForwardIndicator: (/* className: string */) => {},
      removeClassFromForwardIndicator: (/* className: string */) => {},
      addClassToBackIndicator: (/* className: string */) => {},
      removeClassFromBackIndicator: (/* className: string */) => {},
      isRTL: () => /* boolean */ false,
      registerBackIndicatorClickHandler: (/* handler: EventListener */) => {},
      deregisterBackIndicatorClickHandler: (/* handler: EventListener */) => {},
      registerForwardIndicatorClickHandler: (/* handler: EventListener */) => {},
      deregisterForwardIndicatorClickHandler: (/* handler: EventListener */) => {},
      registerCapturedInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      deregisterCapturedInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      registerWindowResizeHandler: (/* handler: EventListener */) => {},
      deregisterWindowResizeHandler: (/* handler: EventListener */) => {},
      getNumberOfTabs: () => /* number */ 0,
      getComputedWidthForTabAtIndex: () => /* number */ 0,
      getComputedLeftForTabAtIndex: () => /* number */ 0,
      getOffsetWidthForScrollFrame: () => /* number */ 0,
      getScrollLeftForScrollFrame: () => /* number */ 0,
      setScrollLeftForScrollFrame: (/* scrollLeftAmount: number */) => {},
      getOffsetWidthForTabBar: () => /* number */ 0,
      setTransformStyleForTabBar: (/* value: string */) => {},
      getOffsetLeftForEventTarget: (/* target: EventTarget */) => /* number */ 0,
      getOffsetWidthForEventTarget: (/* target: EventTarget */) => /* number */ 0,
    };
  }

  constructor(adapter) {
    super(Object.assign(MDCTabBarScrollerFoundation.defaultAdapter, adapter));

    this.pointerDownRecognized_ = false;
    this.currentTranslateOffset_ = 0;
    this.focusedTarget_ = null;
    this.layoutFrame_ = 0;
    this.scrollFrameScrollLeft_ = 0;
    this.forwardIndicatorClickHandler_ = (evt) => this.scrollForward(evt);
    this.backIndicatorClickHandler_ = (evt) => this.scrollBack(evt);
    this.resizeHandler_ = () => this.layout();
    this.interactionHandler_ = (evt) => {
      if (evt.type == 'touchstart' || evt.type == 'mousedown') {
        this.pointerDownRecognized_ = true;
      }
      this.handlePossibleTabKeyboardFocus_(evt);

      if (evt.type == 'focus') {
        this.pointerDownRecognized_ = false;
      }
    };
  }

  init() {
    this.adapter_.registerBackIndicatorClickHandler(this.backIndicatorClickHandler_);
    this.adapter_.registerForwardIndicatorClickHandler(this.forwardIndicatorClickHandler_);
    this.adapter_.registerWindowResizeHandler(this.resizeHandler_);
    ['touchstart', 'mousedown', 'focus'].forEach((evtType) => {
      this.adapter_.registerCapturedInteractionHandler(evtType, this.interactionHandler_);
    });
    this.layout();
  }

  destroy() {
    this.adapter_.deregisterBackIndicatorClickHandler(this.backIndicatorClickHandler_);
    this.adapter_.deregisterForwardIndicatorClickHandler(this.forwardIndicatorClickHandler_);
    this.adapter_.deregisterWindowResizeHandler(this.resizeHandler_);
    ['touchstart', 'mousedown', 'focus'].forEach((evtType) => {
      this.adapter_.deregisterCapturedInteractionHandler(evtType, this.interactionHandler_);
    });
  }

  scrollBack(evt = null) {
    if (evt) {
      evt.preventDefault();
    }

    let tabWidthAccumulator = 0;
    let scrollTargetIndex = 0;

    for (let i = this.adapter_.getNumberOfTabs() - 1; i > 0; i--) {
      const tabOffsetLeft = this.adapter_.getComputedLeftForTabAtIndex(i);
      const tabBarWidthLessTabOffsetLeft = this.adapter_.getOffsetWidthForTabBar() - tabOffsetLeft;

      let tabIsNotOccluded = tabOffsetLeft > this.currentTranslateOffset_;
      if (this.isRTL_()) {
        tabIsNotOccluded = tabBarWidthLessTabOffsetLeft > this.currentTranslateOffset_;
      }

      if (tabIsNotOccluded) {
        continue;
      }

      tabWidthAccumulator += this.adapter_.getComputedWidthForTabAtIndex(i);

      const scrollTargetDetermined = tabWidthAccumulator > this.adapter_.getOffsetWidthForScrollFrame();
      if (scrollTargetDetermined) {
        scrollTargetIndex = this.isRTL_() ? i + 1 : i;
        break;
      }
    }

    this.scrollToTabAtIndex(scrollTargetIndex);
  }

  scrollForward(evt = null) {
    if (evt) {
      evt.preventDefault();
    }

    const scrollFrameOffsetWidth = this.adapter_.getOffsetWidthForScrollFrame() + this.currentTranslateOffset_;
    let scrollTargetIndex = 0;

    for (let i = 0; i < this.adapter_.getNumberOfTabs(); i++) {
      const tabOffsetLeftAndWidth =
        this.adapter_.getComputedLeftForTabAtIndex(i) + this.adapter_.getComputedWidthForTabAtIndex(i);
      let scrollTargetDetermined = tabOffsetLeftAndWidth > scrollFrameOffsetWidth;

      if (this.isRTL_()) {
        const frameOffsetAndTabWidth =
          scrollFrameOffsetWidth - this.adapter_.getComputedWidthForTabAtIndex(i);
        const tabOffsetLeftAndWidth =
          this.adapter_.getComputedLeftForTabAtIndex(i) + this.adapter_.getComputedWidthForTabAtIndex(i);
        const tabRightOffset =
          this.adapter_.getOffsetWidthForTabBar() - tabOffsetLeftAndWidth;

        scrollTargetDetermined = tabRightOffset > frameOffsetAndTabWidth;
      }

      if (scrollTargetDetermined) {
        scrollTargetIndex = i;
        break;
      }
    }

    this.scrollToTabAtIndex(scrollTargetIndex);
  }

  layout() {
    cancelAnimationFrame(this.layoutFrame_);
    this.scrollFrameScrollLeft_ = this.adapter_.getScrollLeftForScrollFrame();
    this.layoutFrame_ = requestAnimationFrame(() => this.layout_());
  }

  isRTL_() {
    return this.adapter_.isRTL();
  }

  handlePossibleTabKeyboardFocus_(evt) {
    if (!this.adapter_.eventTargetHasClass(evt.target, cssClasses$3.TAB) || this.pointerDownRecognized_) {
      return;
    }

    const resetAmt = this.isRTL_() ? this.scrollFrameScrollLeft_ : 0;
    this.adapter_.setScrollLeftForScrollFrame(resetAmt);

    this.focusedTarget_ = evt.target;
    const scrollFrameWidth = this.adapter_.getOffsetWidthForScrollFrame();
    const tabBarWidth = this.adapter_.getOffsetWidthForTabBar();
    const leftEdge = this.adapter_.getOffsetLeftForEventTarget(this.focusedTarget_);
    const rightEdge = leftEdge + this.adapter_.getOffsetWidthForEventTarget(this.focusedTarget_);

    let shouldScrollBack = rightEdge <= this.currentTranslateOffset_;
    let shouldScrollForward = rightEdge > this.currentTranslateOffset_ + scrollFrameWidth;

    if (this.isRTL_()) {
      const normalizedLeftOffset = tabBarWidth - leftEdge;
      shouldScrollBack = leftEdge >= tabBarWidth - this.currentTranslateOffset_;
      shouldScrollForward = normalizedLeftOffset > scrollFrameWidth + this.currentTranslateOffset_;
    }

    if (shouldScrollForward) {
      this.scrollForward();
    } else if (shouldScrollBack) {
      this.scrollBack();
    }

    this.pointerDownRecognized_ = false;
  }

  layout_() {
    const frameWidth = this.adapter_.getOffsetWidthForScrollFrame();
    const isOverflowing = this.adapter_.getOffsetWidthForTabBar() > frameWidth;

    if (!isOverflowing) {
      this.currentTranslateOffset_ = 0;
    }

    this.shiftFrame_();
    this.updateIndicatorEnabledStates_();
  }

  scrollToTabAtIndex(index) {
    const scrollTargetOffsetLeft = this.adapter_.getComputedLeftForTabAtIndex(index);
    const scrollTargetOffsetWidth = this.adapter_.getComputedWidthForTabAtIndex(index);

    this.currentTranslateOffset_ =
      this.normalizeForRTL_(scrollTargetOffsetLeft, scrollTargetOffsetWidth);

    requestAnimationFrame(() => this.shiftFrame_());
  }

  normalizeForRTL_(left, width) {
    return this.isRTL_() ? this.adapter_.getOffsetWidthForTabBar() - (left + width) : left;
  }

  shiftFrame_() {
    const shiftAmount = this.isRTL_() ?
      this.currentTranslateOffset_ : -this.currentTranslateOffset_;

    this.adapter_.setTransformStyleForTabBar(`translateX(${shiftAmount}px)`);
    this.updateIndicatorEnabledStates_();
  }

  updateIndicatorEnabledStates_() {
    const {INDICATOR_ENABLED} = cssClasses$3;
    if (this.currentTranslateOffset_ === 0) {
      this.adapter_.removeClassFromBackIndicator(INDICATOR_ENABLED);
    } else {
      this.adapter_.addClassToBackIndicator(INDICATOR_ENABLED);
    }

    const remainingTabBarWidth = this.adapter_.getOffsetWidthForTabBar() - this.currentTranslateOffset_;
    if (remainingTabBarWidth > this.adapter_.getOffsetWidthForScrollFrame()) {
      this.adapter_.addClassToForwardIndicator(INDICATOR_ENABLED);
    } else {
      this.adapter_.removeClassFromForwardIndicator(INDICATOR_ENABLED);
    }
  }
}

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcTabIconText {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcTabIconText.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-tab-icon-text], mdc-tab-icon-text',
                exportAs: 'mdcTabIconText'
            },] },
];
/** @nocollapse */
MdcTabIconText.ctorParameters = () => [
    { type: ElementRef }
];
MdcTabIconText.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-tab__icon-text',] }]
};
class MdcTab {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _renderer
     * @param {?} elementRef
     * @param {?} _registry
     * @param {?} ripple
     */
    constructor(_changeDetectorRef, _renderer, elementRef, _registry, ripple) {
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        this.ripple = ripple;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this._active = false;
        this._disabled = false;
        /**
         * Event emitted when the option is selected.
         */
        this.selected = new EventEmitter();
        this.isHostClass = true;
        this.role = 'tab';
        this._mdcAdapter = {
            addClass: (className) => {
                this._renderer.addClass(this._getHostElement(), className);
            },
            removeClass: (className) => {
                this._renderer.removeClass(this._getHostElement(), className);
            },
            registerInteractionHandler: (type, handler) => {
                this._registry.listen(type, handler, this._getHostElement());
            },
            deregisterInteractionHandler: (type, handler) => {
                this._registry.unlisten(type, handler);
            },
            getOffsetWidth: () => this._getHostElement().offsetWidth,
            getOffsetLeft: () => this._getHostElement().offsetLeft,
            notifySelected: () => this._emitSelectedEvent()
        };
        this._foundation = new MDCTabFoundation(this._mdcAdapter);
    }
    /**
     * @return {?}
     */
    get active() { return this._active; }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        this.setActive(value);
    }
    /**
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this.setDisabled(value);
    }
    /**
     * @return {?}
     */
    get classIconText() {
        return this.tabIcon != null && this.tabIconText != null;
    }
    /**
     * @return {?}
     */
    get classActive() {
        return this._active ? 'mdc-tab--active' : '';
    }
    /**
     * @return {?}
     */
    get classDisabled() {
        return this._disabled ? 'ng-mdc-tab--disabled' : '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._foundation.init();
        this.setPreventDefaultOnClick(true);
        if (this.tabRouter) {
            this._routerChangeSubscription = this.tabRouter.routeChange
                .pipe(takeUntil(this._destroy))
                .subscribe((_) => {
                this.setActive(_.active);
                this._emitSelectedEvent();
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
        this._foundation.destroy();
    }
    /**
     * @return {?}
     */
    isActive() {
        return this._foundation.isActive();
    }
    /**
     * @param {?} active
     * @return {?}
     */
    setActive(active) {
        this._active = toBoolean(active);
        this._foundation.setActive(active);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    setDisabled(disabled) {
        this._disabled = disabled;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    getComputedWidth() {
        return this._foundation.getComputedWidth();
    }
    /**
     * @return {?}
     */
    getComputedLeft() {
        return this._mdcAdapter.getOffsetLeft();
    }
    /**
     * @return {?}
     */
    getPreventDefaultOnClick() {
        return this._foundation.preventsDefaultOnClick();
    }
    /**
     * @param {?} preventDefaultOnClick
     * @return {?}
     */
    setPreventDefaultOnClick(preventDefaultOnClick) {
        this._foundation.setPreventDefaultOnClick(preventDefaultOnClick);
    }
    /**
     * @return {?}
     */
    measureSelf() {
        this._foundation.measureSelf();
    }
    /**
     * Emits the tab selected event.
     * @return {?}
     */
    _emitSelectedEvent() {
        this.selected.emit({ tab: this });
    }
    /**
     * Retrieves the DOM element of the component host.
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
MdcTab.decorators = [
    { type: Component, args: [{selector: '[mdc-tab], mdc-tab',
                exportAs: 'mdcTab',
                template: '<ng-content></ng-content>',
                providers: [
                    MdcRipple,
                    EventRegistry
                ],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcTab.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: EventRegistry },
    { type: MdcRipple }
];
MdcTab.propDecorators = {
    active: [{ type: Input }],
    disabled: [{ type: Input }],
    selected: [{ type: Output }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-tab',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    classIconText: [{ type: HostBinding, args: ['class.mdc-tab--with-icon-and-text',] }],
    classActive: [{ type: HostBinding, args: ['class.mdc-tab--active',] }],
    classDisabled: [{ type: HostBinding, args: ['class.ng-mdc-tab--disabled',] }],
    tabIcon: [{ type: ContentChild, args: [MdcIcon,] }],
    tabIconText: [{ type: ContentChild, args: [MdcTabIconText,] }],
    tabRouter: [{ type: ContentChild, args: [MdcRouter,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A simple change event emitted selection changes.
 */
class MdcTabChangeEvent {
    /**
     * @param {?} index
     * @param {?} tab
     */
    constructor(index, tab) {
        this.index = index;
        this.tab = tab;
    }
}
class MdcTabBarIndicator {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcTabBarIndicator.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-tab-bar-indicator], mdc-tab-bar-indicator',
                exportAs: 'mdcTabBarIndicator'
            },] },
];
/** @nocollapse */
MdcTabBarIndicator.ctorParameters = () => [
    { type: ElementRef }
];
MdcTabBarIndicator.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-tab-bar__indicator',] }]
};
class MdcTabBar {
    /**
     * @param {?} _ngZone
     * @param {?} _changeDetectorRef
     * @param {?} _renderer
     * @param {?} elementRef
     * @param {?} _registry
     */
    constructor(_ngZone, _changeDetectorRef, _renderer, elementRef, _registry) {
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this._disableRipple = false;
        this._primary = false;
        this._secondary = false;
        /**
         * The tab index that should be selected after the content has been checked.
         */
        this._indexToSelect = 0;
        this._selectedIndex = null;
        /**
         * Event emitted when the tab selection has changed.
         */
        this.selectedTabChange = new EventEmitter(true);
        /**
         * Event emitted when tabs are added or removed.
         */
        this.tabsChangeEvent = new EventEmitter();
        this.isHostClass = true;
        this.scrollFrameContent = false;
        this.role = 'tablist';
        /**
         * Combined stream of all of the tab change events.
         */
        this.optionSelectionChanges = defer(() => {
            if (this.tabs) {
                return merge(...this.tabs.map(option => option.selected));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap(() => this.optionSelectionChanges));
        });
        this._mdcAdapter = {
            addClass: (className) => {
                this._renderer.addClass(this.elementRef.nativeElement, className);
            },
            removeClass: (className) => {
                this._renderer.removeClass(this.elementRef.nativeElement, className);
            },
            bindOnMDCTabSelectedEvent: () => {
                const /** @type {?} */ changedOrDestroyed = merge(this.tabs.changes, this._destroy);
                this.optionSelectionChanges
                    .pipe(takeUntil(changedOrDestroyed)).subscribe(event => {
                    if (event.tab.disabled) {
                        return;
                    }
                    this.setActiveTab(event.tab, true);
                    this._foundation.switchToTabAtIndex(this.getActiveTabIndex(), true);
                    this.selectedTabChange.emit(new MdcTabChangeEvent(this.getActiveTabIndex(), event.tab));
                });
            },
            unbindOnMDCTabSelectedEvent: () => {
                /* not needed */
            },
            registerResizeHandler: (handler) => {
                if (isBrowser()) {
                    this._registry.listen('resize', handler, window);
                }
            },
            deregisterResizeHandler: (handler) => {
                if (isBrowser()) {
                    this._registry.unlisten('resize', handler);
                }
            },
            getOffsetWidth: () => this.elementRef.nativeElement.offsetWidth,
            setStyleForIndicator: (propertyName, value) => this._renderer.setStyle(this.indicator.elementRef.nativeElement, propertyName, value),
            getOffsetWidthForIndicator: () => this.indicator.elementRef.nativeElement.offsetWidth,
            notifyChange: (evtData) => {
                this.selectedTabChange.emit(new MdcTabChangeEvent(evtData.activeTabIndex, this.getActiveTab()));
            },
            getNumberOfTabs: () => this.tabs.length,
            isTabActiveAtIndex: (index) => this.tabs.toArray()[index].isActive(),
            setTabActiveAtIndex: (index, isActive) => this.tabs.toArray()[index].setActive(isActive),
            isDefaultPreventedOnClickForTabAtIndex: (index) => !!this.tabs.toArray()[index].getPreventDefaultOnClick(),
            setPreventDefaultOnClickForTabAtIndex: (index, preventDefaultOnClick) => this.tabs.toArray()[index].setPreventDefaultOnClick(preventDefaultOnClick),
            measureTabAtIndex: (index) => this.tabs.toArray()[index].measureSelf(),
            getComputedWidthForTabAtIndex: (index) => {
                return this.tabs.length ? this.tabs.toArray()[index].getComputedWidth() : -1;
            },
            getComputedLeftForTabAtIndex: (index) => {
                return this.tabs.length ? this.tabs.toArray()[index].getComputedLeft() : -1;
            }
        };
        this._foundation = new MDCTabBarFoundation(this._mdcAdapter);
    }
    /**
     * The index of the active tab.
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._indexToSelect = toNumber(value, null);
    }
    /**
     * @return {?}
     */
    get selectedIndex() { return this._selectedIndex; }
    /**
     * @return {?}
     */
    get primary() { return this._primary; }
    /**
     * @param {?} value
     * @return {?}
     */
    set primary(value) {
        this._primary = toBoolean(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get secondary() { return this._secondary; }
    /**
     * @param {?} value
     * @return {?}
     */
    set secondary(value) {
        this._secondary = toBoolean(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get disableRipple() { return this._disableRipple; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableRipple(value) {
        this.setDisableRipple(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get classTabIcon() {
        return this.tabs.length > 0
            && this.tabs.first.tabIcon != null
            && this.tabs.first.tabIconText == null ? 'mdc-tab-bar--icon-tab-bar' : '';
    }
    /**
     * @return {?}
     */
    get classTabIconText() {
        return this.tabs.length > 0
            && this.tabs.first.tabIcon != null
            && this.tabs.first.tabIconText != null ? 'mdc-tab-bar--icons-with-text' : '';
    }
    /**
     * @return {?}
     */
    get classPrimary() {
        return this.primary ? 'ng-mdc-tab--primary' : '';
    }
    /**
     * @return {?}
     */
    get classSecondary() {
        return this.secondary ? 'ng-mdc-tab--secondary' : '';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this.tabs.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {
            this._foundation.init();
            this._initializeSelection();
            this.setDisableRipple(this.disableRipple);
            this._foundation.layout();
            this.tabsChangeEvent.emit();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
        this._foundation.destroy();
    }
    /**
     * @return {?}
     */
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then(() => {
            if (this.getActiveTabIndex() < 0 && this.tabs.first) {
                this.tabs.first.setActive(true);
            }
        });
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    setDisableRipple(disabled) {
        if (!this.tabs) {
            return;
        }
        if (this._disableRipple !== disabled) {
            this._disableRipple = disabled;
        }
        this.tabs.forEach(tab => {
            disabled ? tab.ripple.destroy() : tab.ripple.attachTo(tab.elementRef.nativeElement);
        });
    }
    /**
     * @param {?} index
     * @return {?}
     */
    setTabActiveAtIndex(index) {
        if (this.tabs.toArray()[index].disabled) {
            return;
        }
        this._foundation.switchToTabAtIndex(index, true);
        this._mdcAdapter.setTabActiveAtIndex(index, true);
    }
    /**
     * @return {?}
     */
    getActiveTabIndex() {
        return this._foundation.getActiveTabIndex();
    }
    /**
     * @return {?}
     */
    getActiveTab() {
        const /** @type {?} */ tab = this.tabs.find(_ => _.isActive());
        return tab ? tab[0] : null;
    }
    /**
     * @param {?} tab
     * @param {?} active
     * @return {?}
     */
    setActiveTab(tab, active) {
        this.tabs.forEach(_ => {
            _.setActive(false);
        }); /** @type {?} */
        ((this.tabs.find(_ => _ === tab))).setActive(active);
    }
    /**
     * @return {?}
     */
    layout() {
        this._foundation.layout();
    }
    /**
     * @return {?}
     */
    getNumberOfTabs() {
        return this._mdcAdapter.getNumberOfTabs();
    }
    /**
     * @return {?}
     */
    getComputedWidth() {
        return this._mdcAdapter.getOffsetWidth();
    }
    /**
     * @param {?} index
     * @param {?} preventDefaultOnClick
     * @return {?}
     */
    setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
        this._mdcAdapter.setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick);
    }
    /**
     * @param {?} index
     * @return {?}
     */
    isDefaultPreventedOnClickForTabAtIndex(index) {
        return this._mdcAdapter.isDefaultPreventedOnClickForTabAtIndex(index);
    }
}
MdcTabBar.decorators = [
    { type: Component, args: [{selector: '[mdc-tab-bar], mdc-tab-bar',
                exportAs: 'mdcTabBar',
                template: `
  <ng-content></ng-content>
  <mdc-tab-bar-indicator></mdc-tab-bar-indicator>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [EventRegistry]
            },] },
];
/** @nocollapse */
MdcTabBar.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: EventRegistry }
];
MdcTabBar.propDecorators = {
    selectedIndex: [{ type: Input }],
    primary: [{ type: Input }],
    secondary: [{ type: Input }],
    disableRipple: [{ type: Input }],
    selectedTabChange: [{ type: Output }],
    tabsChangeEvent: [{ type: Output }],
    tabs: [{ type: ContentChildren, args: [MdcTab,] }],
    indicator: [{ type: ViewChild, args: [MdcTabBarIndicator,] }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-tab-bar',] }],
    scrollFrameContent: [{ type: HostBinding, args: ['class.mdc-tab-bar-scroller__scroll-frame__tabs',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    classTabIcon: [{ type: HostBinding, args: ['class.mdc-tab-bar--icon-tab-bar',] }],
    classTabIconText: [{ type: HostBinding, args: ['class.mdc-tab-bar--icons-with-text',] }],
    classPrimary: [{ type: HostBinding, args: ['class.ng-mdc-tab--primary',] }],
    classSecondary: [{ type: HostBinding, args: ['class.ng-mdc-tab--secondary',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdcTabBarScrollBack {
    /**
     * @param {?} _renderer
     * @param {?} elementRef
     */
    constructor(_renderer, elementRef) {
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this.isHostClass = true;
        this.isBackClass = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.icon) {
            this._renderer.addClass(this.icon.elementRef.nativeElement, 'mdc-tab-bar-scroller__indicator__inner');
        }
    }
}
MdcTabBarScrollBack.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-tab-bar-scroll-back], mdc-tab-bar-scroll-back',
                exportAs: 'mdcTabBarScrollBack'
            },] },
];
/** @nocollapse */
MdcTabBarScrollBack.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
MdcTabBarScrollBack.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-tab-bar-scroller__indicator',] }],
    isBackClass: [{ type: HostBinding, args: ['class.mdc-tab-bar-scroller__indicator--back',] }],
    icon: [{ type: ContentChild, args: [MdcIcon,] }]
};
class MdcTabBarScrollForward {
    /**
     * @param {?} _renderer
     * @param {?} elementRef
     */
    constructor(_renderer, elementRef) {
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this.isHostClass = true;
        this.isForwardClass = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.icon) {
            this._renderer.addClass(this.icon.elementRef.nativeElement, 'mdc-tab-bar-scroller__indicator__inner');
        }
    }
}
MdcTabBarScrollForward.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-tab-bar-scroll-forward], mdc-tab-bar-scroll-forward',
                exportAs: 'mdcTabBarScrollForward'
            },] },
];
/** @nocollapse */
MdcTabBarScrollForward.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
MdcTabBarScrollForward.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-tab-bar-scroller__indicator',] }],
    isForwardClass: [{ type: HostBinding, args: ['class.mdc-tab-bar-scroller__indicator--forward',] }],
    icon: [{ type: ContentChild, args: [MdcIcon,] }]
};
class MdcTabBarScrollFrame {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tabBar) {
            this.tabBar.scrollFrameContent = true;
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    findTab(index) {
        return this.tabBar.tabs.toArray()[index];
    }
}
MdcTabBarScrollFrame.decorators = [
    { type: Directive, args: [{
                selector: '[mdc-tab-bar-scroll-frame], mdc-tab-bar-scroll-frame',
                exportAs: 'mdcTabBarScrollFrame'
            },] },
];
/** @nocollapse */
MdcTabBarScrollFrame.ctorParameters = () => [
    { type: ElementRef }
];
MdcTabBarScrollFrame.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-tab-bar-scroller__scroll-frame',] }],
    tabBar: [{ type: ContentChild, args: [MdcTabBar,] }]
};
class MdcTabBarScroller {
    /**
     * @param {?} _renderer
     * @param {?} elementRef
     * @param {?} _registry
     */
    constructor(_renderer, elementRef, _registry) {
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        this.direction = 'ltr';
        this.isHostClass = true;
        this._mdcAdapter = {
            addClass: (className) => {
                this._renderer.addClass(this.elementRef.nativeElement, className);
            },
            removeClass: (className) => {
                this._renderer.removeClass(this.elementRef.nativeElement, className);
            },
            eventTargetHasClass: (target, className) => target.classList.contains(className),
            addClassToForwardIndicator: (className) => {
                if (this.scrollForward) {
                    this._renderer.addClass(this.forward.elementRef.nativeElement, className);
                }
            },
            removeClassFromForwardIndicator: (className) => {
                if (this.scrollForward) {
                    this._renderer.removeClass(this.forward.elementRef.nativeElement, className);
                }
            },
            addClassToBackIndicator: (className) => {
                if (this.scrollBack) {
                    this._renderer.addClass(this.back.elementRef.nativeElement, className);
                }
            },
            removeClassFromBackIndicator: (className) => {
                if (this.scrollBack) {
                    this._renderer.removeClass(this.back.elementRef.nativeElement, className);
                }
            },
            isRTL: () => this.direction === 'rtl',
            registerBackIndicatorClickHandler: (handler) => {
                if (this.scrollBack) {
                    this._registry.listen('click', handler, this.back.elementRef.nativeElement);
                }
            },
            deregisterBackIndicatorClickHandler: (handler) => {
                if (this.scrollBack) {
                    this._registry.unlisten('click', handler);
                }
            },
            registerForwardIndicatorClickHandler: (handler) => {
                if (this.scrollForward) {
                    this._registry.listen('click', handler, this.forward.elementRef.nativeElement);
                }
            },
            deregisterForwardIndicatorClickHandler: (handler) => {
                if (this.scrollForward) {
                    this._registry.unlisten('click', handler);
                }
            },
            registerCapturedInteractionHandler: (evt, handler) => {
                this._registry.listen(evt, handler, this.elementRef.nativeElement);
            },
            deregisterCapturedInteractionHandler: (evt, handler) => {
                this._registry.unlisten(evt, handler);
            },
            registerWindowResizeHandler: (handler) => {
                if (isBrowser()) {
                    this._registry.listen('resize', handler, window);
                }
            },
            deregisterWindowResizeHandler: (handler) => {
                if (isBrowser()) {
                    this._registry.unlisten('resize', handler);
                }
            },
            getNumberOfTabs: () => {
                return (this.scrollFrame && this.scrollFrame.tabBar) ? this.scrollFrame.tabBar.tabs.length : 0;
            },
            getComputedWidthForTabAtIndex: (index) => this.scrollFrame.findTab(index).getComputedWidth(),
            getComputedLeftForTabAtIndex: (index) => this.scrollFrame.findTab(index).getComputedLeft(),
            getOffsetWidthForScrollFrame: () => {
                return this.scrollFrame ? this.scrollFrame.elementRef.nativeElement.offsetWidth : 0;
            },
            getScrollLeftForScrollFrame: () => {
                return this.scrollFrame ? this.scrollFrame.elementRef.nativeElement.scrollLeft : 0;
            },
            setScrollLeftForScrollFrame: (scrollLeftAmount) => {
                if (this.scrollFrame) {
                    this._renderer.setProperty(this.scrollFrame.elementRef.nativeElement, 'scrollLeft', scrollLeftAmount);
                }
            },
            getOffsetWidthForTabBar: () => {
                return (this.scrollFrame && this.scrollFrame.tabBar) ? this.scrollFrame.tabBar.elementRef.nativeElement.offsetWidth : 0;
            },
            setTransformStyleForTabBar: (value) => {
                if (this.scrollFrame && this.scrollFrame.tabBar) {
                    this._renderer.setStyle(this.scrollFrame.tabBar.elementRef.nativeElement, getCorrectPropertyName(window, 'transform'), value);
                }
            },
            getOffsetLeftForEventTarget: (target) => target.offsetLeft,
            getOffsetWidthForEventTarget: (target) => target.offsetWidth
        };
        this._foundation = new MDCTabBarScrollerFoundation(this._mdcAdapter);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._foundation.init();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._tabBarChangeSubscription = this.scrollFrame.tabBar.tabsChangeEvent.subscribe(() => {
            this.layout();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._tabBarChangeSubscription) {
            this._tabBarChangeSubscription.unsubscribe();
            this._tabBarChangeSubscription = null;
        }
        this._foundation.destroy();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    scrollToTabAtIndex(index) {
        this._foundation.scrollToTabAtIndex(index);
    }
    /**
     * @return {?}
     */
    layout() {
        this._foundation.layout();
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    scrollBack(event) {
        this._foundation.scrollBack(event);
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    scrollForward(event) {
        this._foundation.scrollForward(event);
    }
}
MdcTabBarScroller.decorators = [
    { type: Component, args: [{selector: '[mdc-tab-bar-scroller], mdc-tab-bar-scroller',
                exportAs: 'mdcTabBarScroller',
                template: '<ng-content></ng-content>',
                providers: [EventRegistry],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcTabBarScroller.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: EventRegistry }
];
MdcTabBarScroller.propDecorators = {
    direction: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-tab-bar-scroller',] }],
    scrollFrame: [{ type: ContentChild, args: [MdcTabBarScrollFrame,] }],
    back: [{ type: ContentChild, args: [MdcTabBarScrollBack,] }],
    forward: [{ type: ContentChild, args: [MdcTabBarScrollForward,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ TAB_DECLARATIONS = [
    MdcTab,
    MdcTabIconText,
    MdcTabBar,
    MdcTabBarIndicator,
    MdcTabBarScroller,
    MdcTabBarScrollBack,
    MdcTabBarScrollForward,
    MdcTabBarScrollFrame,
];
class MdcTabModule {
}
MdcTabModule.decorators = [
    { type: NgModule, args: [{
                imports: [MdcRouterModule],
                exports: [
                    MdcRouterModule,
                    TAB_DECLARATIONS
                ],
                declarations: [
                    TAB_DECLARATIONS
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcTabModule, MdcTabIconText, MdcTab, MdcTabChangeEvent, MdcTabBarIndicator, MdcTabBar, MdcTabBarScrollBack, MdcTabBarScrollForward, MdcTabBarScrollFrame, MdcTabBarScroller };
