/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, Input, Output, Renderer2, ViewChild, NgModule } from '@angular/core';
import { isBrowser, toBoolean, EventRegistry } from '@angular-mdc/web/common';
import { CommonModule } from '@angular/common';

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @type {string|undefined} */
var storedTransformPropertyName_;
/**
 * Returns the name of the correct transform property to use on the current browser.
 * @param {!Window} globalObj
 * @param {boolean=} forceRefresh
 * @return {string}
 */

function getTransformPropertyName(globalObj) {
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (storedTransformPropertyName_ === undefined || forceRefresh) {
    var el = globalObj.document.createElement('div');
    var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
    storedTransformPropertyName_ = transformPropertyName;
  }

  return storedTransformPropertyName_;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
var MDCFoundation =
/*#__PURE__*/
function () {
  _createClass(MDCFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    }
    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    }
    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    }
    /** @return {!Object} */

  }, {
    key: "defaultAdapter",
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    }
    /**
     * @param {A=} adapter
     */

  }]);

  function MDCFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MDCFoundation);

    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  _createClass(MDCFoundation, [{
    key: "init",
    value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
    }
  }, {
    key: "destroy",
    value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    }
  }]);

  return MDCFoundation;
}();

/**
 * @template F
 */

var MDCComponent =
/*#__PURE__*/
function () {
  _createClass(MDCComponent, null, [{
    key: "attachTo",

    /**
     * @param {!Element} root
     * @return {!MDCComponent}
     */
    value: function attachTo(root) {
      // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
      // returns an instantiated component with its root set to that element. Also note that in the cases of
      // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
      // from getDefaultFoundation().
      return new MDCComponent(root, new MDCFoundation());
    }
    /**
     * @param {!Element} root
     * @param {F=} foundation
     * @param {...?} args
     */

  }]);

  function MDCComponent(root) {
    var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    _classCallCheck(this, MDCComponent);

    /** @protected {!Element} */
    this.root_ = root;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  _createClass(MDCComponent, [{
    key: "initialize",
    value: function initialize()
    /* ...args */
    {} // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.

    /**
     * @return {!F} foundation
     */

  }, {
    key: "getDefaultFoundation",
    value: function getDefaultFoundation() {
      // Subclasses must override this method to return a properly configured foundation class for the
      // component.
      throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
    }
  }, {
    key: "initialSyncWithDOM",
    value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
      // object. An example of this would be a form control wrapper that needs to synchronize its internal state
      // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
      // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // Subclasses may implement this method to release any resources / deregister any listeners they have
      // attached. An example of this might be deregistering a resize event from the window object.
      this.foundation_.destroy();
    }
    /**
     * Wrapper method to add an event listener to the component's root element. This is most useful when
     * listening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "listen",
    value: function listen(evtType, handler) {
      this.root_.addEventListener(evtType, handler);
    }
    /**
     * Wrapper method to remove an event listener to the component's root element. This is most useful when
     * unlistening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "unlisten",
    value: function unlisten(evtType, handler) {
      this.root_.removeEventListener(evtType, handler);
    }
    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type,
     * with the given data.
     * @param {string} evtType
     * @param {!Object} evtData
     * @param {boolean=} shouldBubble
     */

  }, {
    key: "emit",
    value: function emit(evtType, evtData) {
      var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var evt;

      if (typeof CustomEvent === 'function') {
        evt = new CustomEvent(evtType, {
          detail: evtData,
          bubbles: shouldBubble
        });
      } else {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }

      this.root_.dispatchEvent(evt);
    }
  }]);

  return MDCComponent;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Menu. Provides an interface for managing
 * - classes
 * - dom
 * - focus
 * - position
 * - dimensions
 * - event handlers
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCMenuAdapter =
/*#__PURE__*/
function () {
  function MDCMenuAdapter() {
    _classCallCheck(this, MDCMenuAdapter);
  }

  _createClass(MDCMenuAdapter, [{
    key: "addClass",

    /** @param {string} className */
    value: function addClass(className) {}
    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}
    /**
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}
    /** @return {boolean} */

  }, {
    key: "hasNecessaryDom",
    value: function hasNecessaryDom() {}
    /**
     * @param {EventTarget} target
     * @param {string} attributeName
     * @return {string}
     */

  }, {
    key: "getAttributeForEventTarget",
    value: function getAttributeForEventTarget(target, attributeName) {}
    /** @return {{ width: number, height: number }} */

  }, {
    key: "getInnerDimensions",
    value: function getInnerDimensions() {}
    /** @return {boolean} */

  }, {
    key: "hasAnchor",
    value: function hasAnchor() {}
    /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

  }, {
    key: "getAnchorDimensions",
    value: function getAnchorDimensions() {}
    /** @return {{ width: number, height: number }} */

  }, {
    key: "getWindowDimensions",
    value: function getWindowDimensions() {}
    /** @return {number} */

  }, {
    key: "getNumberOfItems",
    value: function getNumberOfItems() {}
    /**
     * @param {string} type
     * @param {function(!Event)} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(type, handler) {}
    /**
     * @param {string} type
     * @param {function(!Event)} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}
    /** @param {function(!Event)} handler */

  }, {
    key: "registerBodyClickHandler",
    value: function registerBodyClickHandler(handler) {}
    /** @param {function(!Event)} handler */

  }, {
    key: "deregisterBodyClickHandler",
    value: function deregisterBodyClickHandler(handler) {}
    /**
     * @param {EventTarget} target
     * @return {number}
     */

  }, {
    key: "getIndexForEventTarget",
    value: function getIndexForEventTarget(target) {}
    /** @param {{index: number}} evtData */

  }, {
    key: "notifySelected",
    value: function notifySelected(evtData) {}
  }, {
    key: "notifyCancel",
    value: function notifyCancel() {}
  }, {
    key: "saveFocus",
    value: function saveFocus() {}
  }, {
    key: "restoreFocus",
    value: function restoreFocus() {}
    /** @return {boolean} */

  }, {
    key: "isFocused",
    value: function isFocused() {}
  }, {
    key: "focus",
    value: function focus() {}
    /** @return {number} */

  }, {
    key: "getFocusedItemIndex",
    value: function getFocusedItemIndex()
    /* number */
    {}
    /** @param {number} index */

  }, {
    key: "focusItemAtIndex",
    value: function focusItemAtIndex(index) {}
    /** @return {boolean} */

  }, {
    key: "isRtl",
    value: function isRtl() {}
    /** @param {string} origin */

  }, {
    key: "setTransformOrigin",
    value: function setTransformOrigin(origin) {}
    /** @param {{
    *   top: (string|undefined),
    *   right: (string|undefined),
    *   bottom: (string|undefined),
    *   left: (string|undefined)
    * }} position */

  }, {
    key: "setPosition",
    value: function setPosition(position) {}
    /** @param {string} height */

  }, {
    key: "setMaxHeight",
    value: function setMaxHeight(height) {}
    /**
     * @param {number} index
     * @param {string} attr
     * @param {string} value
     */

  }, {
    key: "setAttrForOptionAtIndex",
    value: function setAttrForOptionAtIndex(index, attr, value) {}
    /**
     * @param {number} index
     * @param {string} attr
     */

  }, {
    key: "rmAttrForOptionAtIndex",
    value: function rmAttrForOptionAtIndex(index, attr) {}
    /**
     * @param {number} index
     * @param {string} className
     */

  }, {
    key: "addClassForOptionAtIndex",
    value: function addClassForOptionAtIndex(index, className) {}
    /**
     * @param {number} index
     * @param {string} className
     */

  }, {
    key: "rmClassForOptionAtIndex",
    value: function rmClassForOptionAtIndex(index, className) {}
  }]);

  return MDCMenuAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses = {
  ROOT: 'mdc-menu',
  OPEN: 'mdc-menu--open',
  ANIMATING_OPEN: 'mdc-menu--animating-open',
  ANIMATING_CLOSED: 'mdc-menu--animating-closed',
  SELECTED_LIST_ITEM: 'mdc-list-item--selected'
};
/** @enum {string} */

var strings = {
  ITEMS_SELECTOR: '.mdc-menu__items',
  SELECTED_EVENT: 'MDCMenu:selected',
  CANCEL_EVENT: 'MDCMenu:cancel',
  ARIA_DISABLED_ATTR: 'aria-disabled'
};
/** @enum {number} */

var numbers = {
  // Amount of time to wait before triggering a selected event on the menu. Note that this time
  // will most likely be bumped up once interactive lists are supported to allow for the ripple to
  // animate before closing the menu
  SELECTED_TRIGGER_DELAY: 50,
  // Total duration of menu open animation.
  TRANSITION_OPEN_DURATION: 120,
  // Total duration of menu close animation.
  TRANSITION_CLOSE_DURATION: 75,
  // Margin left to the edge of the viewport when menu is at maximum possible height.
  MARGIN_TO_EDGE: 32,
  // Ratio of anchor width to menu width for switching from corner positioning to center positioning.
  ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,
  // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.
  OFFSET_TO_MENU_HEIGHT_RATIO: 0.1
};
/**
 * Enum for bits in the {@see Corner) bitmap.
 * @enum {number}
 */

var CornerBit = {
  BOTTOM: 1,
  CENTER: 2,
  RIGHT: 4,
  FLIP_RTL: 8
};
/**
 * Enum for representing an element corner for positioning the menu.
 *
 * The START constants map to LEFT if element directionality is left
 * to right and RIGHT if the directionality is right to left.
 * Likewise END maps to RIGHT or LEFT depending on the directionality.
 *
 * @enum {number}
 */

var Corner = {
  TOP_LEFT: 0,
  TOP_RIGHT: CornerBit.RIGHT,
  BOTTOM_LEFT: CornerBit.BOTTOM,
  BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
  TOP_START: CornerBit.FLIP_RTL,
  TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
  BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
  BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
};

/**
 * @extends {MDCFoundation<!MDCMenuAdapter>}
 */

var MDCMenuFoundation =
/*#__PURE__*/
function (_MDCFoundation) {
  _inherits(MDCMenuFoundation, _MDCFoundation);

  _createClass(MDCMenuFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get() {
      return cssClasses;
    }
    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get() {
      return strings;
    }
    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get() {
      return numbers;
    }
    /** @return enum{number} */

  }, {
    key: "Corner",
    get: function get() {
      return Corner;
    }
    /**
     * {@see MDCMenuAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCMenuAdapter}
     */

  }, {
    key: "defaultAdapter",
    get: function get() {
      return (
        /** @type {!MDCMenuAdapter} */
        {
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {
            return false;
          },
          hasNecessaryDom: function hasNecessaryDom() {
            return false;
          },
          getAttributeForEventTarget: function getAttributeForEventTarget() {},
          getInnerDimensions: function getInnerDimensions() {
            return {};
          },
          hasAnchor: function hasAnchor() {
            return false;
          },
          getAnchorDimensions: function getAnchorDimensions() {
            return {};
          },
          getWindowDimensions: function getWindowDimensions() {
            return {};
          },
          getNumberOfItems: function getNumberOfItems() {
            return 0;
          },
          registerInteractionHandler: function registerInteractionHandler() {},
          deregisterInteractionHandler: function deregisterInteractionHandler() {},
          registerBodyClickHandler: function registerBodyClickHandler() {},
          deregisterBodyClickHandler: function deregisterBodyClickHandler() {},
          getIndexForEventTarget: function getIndexForEventTarget() {
            return 0;
          },
          notifySelected: function notifySelected() {},
          notifyCancel: function notifyCancel() {},
          saveFocus: function saveFocus() {},
          restoreFocus: function restoreFocus() {},
          isFocused: function isFocused() {
            return false;
          },
          focus: function focus() {},
          getFocusedItemIndex: function getFocusedItemIndex() {
            return -1;
          },
          focusItemAtIndex: function focusItemAtIndex() {},
          isRtl: function isRtl() {
            return false;
          },
          setTransformOrigin: function setTransformOrigin() {},
          setPosition: function setPosition() {},
          setMaxHeight: function setMaxHeight() {},
          setAttrForOptionAtIndex: function setAttrForOptionAtIndex() {},
          rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() {},
          addClassForOptionAtIndex: function addClassForOptionAtIndex() {},
          rmClassForOptionAtIndex: function rmClassForOptionAtIndex() {}
        }
      );
    }
    /** @param {!MDCMenuAdapter} adapter */

  }]);

  function MDCMenuFoundation(adapter) {
    var _this;

    _classCallCheck(this, MDCMenuFoundation);

    _this = _possibleConstructorReturn(this, (MDCMenuFoundation.__proto__ || Object.getPrototypeOf(MDCMenuFoundation)).call(this, Object.assign(MDCMenuFoundation.defaultAdapter, adapter)));
    /** @private {function(!Event)} */

    _this.clickHandler_ = function (evt) {
      return _this.handlePossibleSelected_(evt);
    };
    /** @private {function(!Event)} */


    _this.keydownHandler_ = function (evt) {
      return _this.handleKeyboardDown_(evt);
    };
    /** @private {function(!Event)} */


    _this.keyupHandler_ = function (evt) {
      return _this.handleKeyboardUp_(evt);
    };
    /** @private {function(!Event)} */


    _this.documentClickHandler_ = function (evt) {
      return _this.handleDocumentClick_(evt);
    };
    /** @private {boolean} */


    _this.isOpen_ = false;
    /** @private {number} */

    _this.openAnimationEndTimerId_ = 0;
    /** @private {number} */

    _this.closeAnimationEndTimerId_ = 0;
    /** @private {number} */

    _this.selectedTriggerTimerId_ = 0;
    /** @private {number} */

    _this.animationRequestId_ = 0;
    /** @private {!{ width: number, height: number }} */

    _this.dimensions_;
    /** @private {number} */

    _this.itemHeight_;
    /** @private {Corner} */

    _this.anchorCorner_ = Corner.TOP_START;
    /** @private {AnchorMargin} */

    _this.anchorMargin_ = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
    /** @private {?AutoLayoutMeasurements} */

    _this.measures_ = null;
    /** @private {number} */

    _this.selectedIndex_ = -1;
    /** @private {boolean} */

    _this.rememberSelection_ = false;
    /** @private {boolean} */

    _this.quickOpen_ = false; // A keyup event on the menu needs to have a corresponding keydown
    // event on the menu. If the user opens the menu with a keydown event on a
    // button, the menu will only get the key up event causing buggy behavior with selected elements.

    /** @private {boolean} */

    _this.keyDownWithinMenu_ = false;
    return _this;
  }

  _createClass(MDCMenuFoundation, [{
    key: "init",
    value: function init() {
      var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses,
          ROOT = _MDCMenuFoundation$cs.ROOT,
          OPEN = _MDCMenuFoundation$cs.OPEN;

      if (!this.adapter_.hasClass(ROOT)) {
        throw new Error("".concat(ROOT, " class required in root element."));
      }

      if (!this.adapter_.hasNecessaryDom()) {
        throw new Error("Required DOM nodes missing in ".concat(ROOT, " component."));
      }

      if (this.adapter_.hasClass(OPEN)) {
        this.isOpen_ = true;
      }

      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      clearTimeout(this.selectedTriggerTimerId_);
      clearTimeout(this.openAnimationEndTimerId_);
      clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.

      cancelAnimationFrame(this.animationRequestId_);
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);
    }
    /**
     * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.
     */

  }, {
    key: "setAnchorCorner",
    value: function setAnchorCorner(corner) {
      this.anchorCorner_ = corner;
    }
    /**
     * @param {!AnchorMargin} margin 4-plet of margins from anchor.
     */

  }, {
    key: "setAnchorMargin",
    value: function setAnchorMargin(margin) {
      this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
      this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
      this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
      this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
    }
    /** @param {boolean} rememberSelection */

  }, {
    key: "setRememberSelection",
    value: function setRememberSelection(rememberSelection) {
      this.rememberSelection_ = rememberSelection;
      this.setSelectedIndex(-1);
    }
    /** @param {boolean} quickOpen */

  }, {
    key: "setQuickOpen",
    value: function setQuickOpen(quickOpen) {
      this.quickOpen_ = quickOpen;
    }
    /**
     * @param {?number} focusIndex
     * @private
     */

  }, {
    key: "focusOnOpen_",
    value: function focusOnOpen_(focusIndex) {
      if (focusIndex === null) {
        // If this instance of MDCMenu remembers selections, and the user has
        // made a selection, then focus the last selected item
        if (this.rememberSelection_ && this.selectedIndex_ >= 0) {
          this.adapter_.focusItemAtIndex(this.selectedIndex_);
          return;
        }

        this.adapter_.focus(); // If that doesn't work, focus first item instead.

        if (!this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(0);
        }
      } else {
        this.adapter_.focusItemAtIndex(focusIndex);
      }
    }
    /**
     * Handle clicks and cancel the menu if not a child list-item
     * @param {!Event} evt
     * @private
     */

  }, {
    key: "handleDocumentClick_",
    value: function handleDocumentClick_(evt) {
      var el = evt.target;

      while (el && el !== document.documentElement) {
        if (this.adapter_.getIndexForEventTarget(el) !== -1) {
          return;
        }

        el = el.parentNode;
      }

      this.adapter_.notifyCancel();
      this.close(evt);
    }
  }, {
    key: "handleKeyboardDown_",

    /**
     * Handle keys that we want to repeat on hold (tab and arrows).
     * @param {!Event} evt
     * @return {boolean}
     * @private
     */
    value: function handleKeyboardDown_(evt) {
      // Do nothing if Alt, Ctrl or Meta are pressed.
      if (evt.altKey || evt.ctrlKey || evt.metaKey) {
        return true;
      }

      var keyCode = evt.keyCode,
          key = evt.key,
          shiftKey = evt.shiftKey;
      var isTab = key === 'Tab' || keyCode === 9;
      var isArrowUp = key === 'ArrowUp' || keyCode === 38;
      var isArrowDown = key === 'ArrowDown' || keyCode === 40;
      var isSpace = key === 'Space' || keyCode === 32;
      var isEnter = key === 'Enter' || keyCode === 13; // The menu needs to know if the keydown event was triggered on the menu

      this.keyDownWithinMenu_ = isEnter || isSpace;
      var focusedItemIndex = this.adapter_.getFocusedItemIndex();
      var lastItemIndex = this.adapter_.getNumberOfItems() - 1;

      if (shiftKey && isTab && focusedItemIndex === 0) {
        this.adapter_.focusItemAtIndex(lastItemIndex);
        evt.preventDefault();
        return false;
      }

      if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {
        this.adapter_.focusItemAtIndex(0);
        evt.preventDefault();
        return false;
      } // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling


      if (isArrowUp || isArrowDown || isSpace) {
        evt.preventDefault();
      }

      if (isArrowUp) {
        if (focusedItemIndex === 0 || this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(lastItemIndex);
        } else {
          this.adapter_.focusItemAtIndex(focusedItemIndex - 1);
        }
      } else if (isArrowDown) {
        if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(0);
        } else {
          this.adapter_.focusItemAtIndex(focusedItemIndex + 1);
        }
      }

      return true;
    }
    /**
     * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).
     * @param {!Event} evt
     * @return {boolean}
     * @private
     */

  }, {
    key: "handleKeyboardUp_",
    value: function handleKeyboardUp_(evt) {
      // Do nothing if Alt, Ctrl or Meta are pressed.
      if (evt.altKey || evt.ctrlKey || evt.metaKey) {
        return true;
      }

      var keyCode = evt.keyCode,
          key = evt.key;
      var isEnter = key === 'Enter' || keyCode === 13;
      var isSpace = key === 'Space' || keyCode === 32;
      var isEscape = key === 'Escape' || keyCode === 27;

      if (isEnter || isSpace) {
        // If the keydown event didn't occur on the menu, then it should
        // disregard the possible selected event.
        if (this.keyDownWithinMenu_) {
          this.handlePossibleSelected_(evt);
        }

        this.keyDownWithinMenu_ = false;
      }

      if (isEscape) {
        this.adapter_.notifyCancel();
        this.close();
      }

      return true;
    }
    /**
     * @param {!Event} evt
     * @private
     */

  }, {
    key: "handlePossibleSelected_",
    value: function handlePossibleSelected_(evt) {
      var _this2 = this;

      if (this.adapter_.getAttributeForEventTarget(evt.target, strings.ARIA_DISABLED_ATTR) === 'true') {
        return;
      }

      var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);

      if (targetIndex < 0) {
        return;
      } // Debounce multiple selections


      if (this.selectedTriggerTimerId_) {
        return;
      }

      this.selectedTriggerTimerId_ = setTimeout(function () {
        _this2.selectedTriggerTimerId_ = 0;

        _this2.close();

        if (_this2.rememberSelection_) {
          _this2.setSelectedIndex(targetIndex);
        }

        _this2.adapter_.notifySelected({
          index: targetIndex
        });
      }, numbers.SELECTED_TRIGGER_DELAY);
    }
    /**
     * @return {AutoLayoutMeasurements} Measurements used to position menu popup.
     */

  }, {
    key: "getAutoLayoutMeasurements_",
    value: function getAutoLayoutMeasurements_() {
      var anchorRect = this.adapter_.getAnchorDimensions();
      var viewport = this.adapter_.getWindowDimensions();
      return {
        viewport: viewport,
        viewportDistance: {
          top: anchorRect.top,
          right: viewport.width - anchorRect.right,
          left: anchorRect.left,
          bottom: viewport.height - anchorRect.bottom
        },
        anchorHeight: anchorRect.height,
        anchorWidth: anchorRect.width,
        menuHeight: this.dimensions_.height,
        menuWidth: this.dimensions_.width
      };
    }
    /**
     * Computes the corner of the anchor from which to animate and position the menu.
     * @return {Corner}
     * @private
     */

  }, {
    key: "getOriginCorner_",
    value: function getOriginCorner_() {
      // Defaults: open from the top left.
      var corner = Corner.TOP_LEFT;
      var _measures_ = this.measures_,
          viewportDistance = _measures_.viewportDistance,
          anchorHeight = _measures_.anchorHeight,
          anchorWidth = _measures_.anchorWidth,
          menuHeight = _measures_.menuHeight,
          menuWidth = _measures_.menuWidth;
      var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
      var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
      var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;
      var topOverflow = menuHeight - availableTop;
      var bottomOverflow = menuHeight - availableBottom;

      if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
        corner |= CornerBit.BOTTOM;
      }

      var isRtl = this.adapter_.isRtl();
      var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
      var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
      var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
      var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
      var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;
      var leftOverflow = menuWidth - availableLeft;
      var rightOverflow = menuWidth - availableRight;

      if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
        corner |= CornerBit.RIGHT;
      }

      return corner;
    }
    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.
     * @private
     */

  }, {
    key: "getHorizontalOriginOffset_",
    value: function getHorizontalOriginOffset_(corner) {
      var anchorWidth = this.measures_.anchorWidth;
      var isRightAligned = Boolean(corner & CornerBit.RIGHT);
      var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
      var x = 0;

      if (isRightAligned) {
        var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;
        x = rightOffset;
      } else {
        var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
        x = leftOffset;
      }

      return x;
    }
    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.
     * @private
     */

  }, {
    key: "getVerticalOriginOffset_",
    value: function getVerticalOriginOffset_(corner) {
      var _measures_2 = this.measures_,
          viewport = _measures_2.viewport,
          viewportDistance = _measures_2.viewportDistance,
          anchorHeight = _measures_2.anchorHeight,
          menuHeight = _measures_2.menuHeight;
      var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
      var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;
      var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
      var canOverlapVertically = !avoidVerticalOverlap;
      var y = 0;

      if (isBottomAligned) {
        y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom; // adjust for when menu can overlap anchor, but too tall to be aligned to bottom
        // anchor corner. Bottom margin is ignored in such cases.

        if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {
          y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));
        }
      } else {
        y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top; // adjust for when menu can overlap anchor, but too tall to be aligned to top
        // anchor corners. Top margin is ignored in that case.

        if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {
          y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));
        }
      }

      return y;
    }
    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.
     * @private
     */

  }, {
    key: "getMenuMaxHeight_",
    value: function getMenuMaxHeight_(corner) {
      var maxHeight = 0;
      var viewportDistance = this.measures_.viewportDistance;
      var isBottomAligned = Boolean(corner & CornerBit.BOTTOM); // When maximum height is not specified, it is handled from css.

      if (this.anchorCorner_ & CornerBit.BOTTOM) {
        if (isBottomAligned) {
          maxHeight = viewportDistance.top + this.anchorMargin_.top;
        } else {
          maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;
        }
      }

      return maxHeight;
    }
    /** @private */

  }, {
    key: "autoPosition_",
    value: function autoPosition_() {
      var _position;

      if (!this.adapter_.hasAnchor()) {
        return;
      } // Compute measurements for autoposition methods reuse.


      this.measures_ = this.getAutoLayoutMeasurements_();
      var corner = this.getOriginCorner_();
      var maxMenuHeight = this.getMenuMaxHeight_(corner);
      var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
      var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
      var horizontalOffset = this.getHorizontalOriginOffset_(corner);
      var verticalOffset = this.getVerticalOriginOffset_(corner);
      var position = (_position = {}, _defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), _defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);
      var _measures_3 = this.measures_,
          anchorWidth = _measures_3.anchorWidth,
          menuHeight = _measures_3.menuHeight,
          menuWidth = _measures_3.menuWidth; // Center align when anchor width is comparable or greater than menu, otherwise keep corner.

      if (anchorWidth / menuWidth > numbers.ANCHOR_TO_MENU_WIDTH_RATIO) {
        horizontalAlignment = 'center';
      } // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that
      // scale animation is "anchored" on the anchor.


      if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers.OFFSET_TO_MENU_HEIGHT_RATIO) {
        var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;
        var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;
        verticalAlignment = Math.round(originPercent * 100) / 100 + '%';
      }

      this.adapter_.setTransformOrigin("".concat(horizontalAlignment, " ").concat(verticalAlignment));
      this.adapter_.setPosition(position);
      this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : ''); // Clear measures after positioning is complete.

      this.measures_ = null;
    }
    /**
     * Open the menu.
     * @param {{focusIndex: ?number}=} options
     */

  }, {
    key: "open",
    value: function open() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$focusIndex = _ref.focusIndex,
          focusIndex = _ref$focusIndex === void 0 ? null : _ref$focusIndex;

      this.adapter_.saveFocus();

      if (!this.quickOpen_) {
        this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
      }

      this.animationRequestId_ = requestAnimationFrame(function () {
        _this3.dimensions_ = _this3.adapter_.getInnerDimensions();

        _this3.autoPosition_();

        _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);

        _this3.focusOnOpen_(focusIndex);

        _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);

        if (!_this3.quickOpen_) {
          _this3.openAnimationEndTimerId_ = setTimeout(function () {
            _this3.openAnimationEndTimerId_ = 0;

            _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
          }, numbers.TRANSITION_OPEN_DURATION);
        }
      });
      this.isOpen_ = true;
    }
    /**
     * Closes the menu.
     * @param {Event=} evt
     */

  }, {
    key: "close",
    value: function close() {
      var _this4 = this;

      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings.ARIA_DISABLED_ATTR) === 'true' : false;

      if (targetIsDisabled) {
        return;
      }

      this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);

      if (!this.quickOpen_) {
        this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
      }

      requestAnimationFrame(function () {
        _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);

        if (!_this4.quickOpen_) {
          _this4.closeAnimationEndTimerId_ = setTimeout(function () {
            _this4.closeAnimationEndTimerId_ = 0;

            _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
          }, numbers.TRANSITION_CLOSE_DURATION);
        }
      });
      this.isOpen_ = false;
      this.adapter_.restoreFocus();
    }
    /** @return {boolean} */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return this.isOpen_;
    }
    /** @return {number} */

  }, {
    key: "getSelectedIndex",
    value: function getSelectedIndex() {
      return this.selectedIndex_;
    }
    /**
     * @param {number} index Index of the item to set as selected.
     */

  }, {
    key: "setSelectedIndex",
    value: function setSelectedIndex(index) {
      if (index === this.selectedIndex_) {
        return;
      }

      var prevSelectedIndex = this.selectedIndex_;

      if (prevSelectedIndex >= 0) {
        this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');
        this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses.SELECTED_LIST_ITEM);
      }

      this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;

      if (this.selectedIndex_ >= 0) {
        this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
        this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses.SELECTED_LIST_ITEM);
      }
    }
  }]);

  return MDCMenuFoundation;
}(MDCFoundation);

/**
 * @extends MDCComponent<!MDCMenuFoundation>
 */

var MDCMenu =
/*#__PURE__*/
function (_MDCComponent) {
  _inherits(MDCMenu, _MDCComponent);

  /** @param {...?} args */
  function MDCMenu() {
    var _ref;

    var _this;

    _classCallCheck(this, MDCMenu);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_ref = MDCMenu.__proto__ || Object.getPrototypeOf(MDCMenu)).call.apply(_ref, [this].concat(args)));
    /** @private {!Element} */

    _this.previousFocus_;
    return _this;
  }
  /**
   * @param {!Element} root
   * @return {!MDCMenu}
   */


  _createClass(MDCMenu, [{
    key: "show",

    /** @param {{focusIndex: ?number}=} options */
    value: function show() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$focusIndex = _ref2.focusIndex,
          focusIndex = _ref2$focusIndex === void 0 ? null : _ref2$focusIndex;

      this.foundation_.open({
        focusIndex: focusIndex
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      this.foundation_.close();
    }
    /**
     * @param {Corner} corner Default anchor corner alignment of top-left
     *     menu corner.
     */

  }, {
    key: "setAnchorCorner",
    value: function setAnchorCorner(corner) {
      this.foundation_.setAnchorCorner(corner);
    }
    /**
     * @param {AnchorMargin} margin
     */

  }, {
    key: "setAnchorMargin",
    value: function setAnchorMargin(margin) {
      this.foundation_.setAnchorMargin(margin);
    }
    /**
     * Return the item container element inside the component.
     * @return {?Element}
     */

  }, {
    key: "getOptionByIndex",

    /**
     * Return the item within the menu that is selected.
     * @param {number} index
     * @return {?Element}
     */
    value: function getOptionByIndex(index) {
      var items = this.items;

      if (index < items.length) {
        return this.items[index];
      } else {
        return null;
      }
    }
    /** @param {number} index */

  }, {
    key: "getDefaultFoundation",

    /** @return {!MDCMenuFoundation} */
    value: function getDefaultFoundation() {
      var _this2 = this;

      return new MDCMenuFoundation({
        addClass: function addClass(className) {
          return _this2.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return _this2.root_.classList.remove(className);
        },
        hasClass: function hasClass(className) {
          return _this2.root_.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return Boolean(_this2.itemsContainer_);
        },
        getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
          return target.getAttribute(attributeName);
        },
        getInnerDimensions: function getInnerDimensions() {
          var itemsContainer = _this2.itemsContainer_;
          return {
            width: itemsContainer.offsetWidth,
            height: itemsContainer.offsetHeight
          };
        },
        hasAnchor: function hasAnchor() {
          return _this2.root_.parentElement && _this2.root_.parentElement.classList.contains('mdc-menu-anchor');
        },
        getAnchorDimensions: function getAnchorDimensions() {
          return _this2.root_.parentElement.getBoundingClientRect();
        },
        getWindowDimensions: function getWindowDimensions() {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        },
        getNumberOfItems: function getNumberOfItems() {
          return _this2.items.length;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this2.root_.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this2.root_.removeEventListener(type, handler);
        },
        registerBodyClickHandler: function registerBodyClickHandler(handler) {
          return document.body.addEventListener('click', handler);
        },
        deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
          return document.body.removeEventListener('click', handler);
        },
        getIndexForEventTarget: function getIndexForEventTarget(target) {
          return _this2.items.indexOf(target);
        },
        notifySelected: function notifySelected(evtData) {
          return _this2.emit(MDCMenuFoundation.strings.SELECTED_EVENT, {
            index: evtData.index,
            item: _this2.items[evtData.index]
          });
        },
        notifyCancel: function notifyCancel() {
          return _this2.emit(MDCMenuFoundation.strings.CANCEL_EVENT, {});
        },
        saveFocus: function saveFocus() {
          _this2.previousFocus_ = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          if (_this2.previousFocus_) {
            _this2.previousFocus_.focus();
          }
        },
        isFocused: function isFocused() {
          return document.activeElement === _this2.root_;
        },
        focus: function focus() {
          return _this2.root_.focus();
        },
        getFocusedItemIndex: function getFocusedItemIndex() {
          return _this2.items.indexOf(document.activeElement);
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          return _this2.items[index].focus();
        },
        isRtl: function isRtl() {
          return getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';
        },
        setTransformOrigin: function setTransformOrigin(origin) {
          _this2.root_.style["".concat(getTransformPropertyName(window), "-origin")] = origin;
        },
        setPosition: function setPosition(position) {
          _this2.root_.style.left = 'left' in position ? position.left : null;
          _this2.root_.style.right = 'right' in position ? position.right : null;
          _this2.root_.style.top = 'top' in position ? position.top : null;
          _this2.root_.style.bottom = 'bottom' in position ? position.bottom : null;
        },
        setMaxHeight: function setMaxHeight(height) {
          _this2.root_.style.maxHeight = height;
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
          return _this2.items[index].setAttribute(attr, value);
        },
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
          return _this2.items[index].removeAttribute(attr);
        },
        addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
          return _this2.items[index].classList.add(className);
        },
        rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
          return _this2.items[index].classList.remove(className);
        }
      });
    }
  }, {
    key: "open",

    /** @return {boolean} */
    get: function get() {
      return this.foundation_.isOpen();
    }
    /** @param {boolean} value */
    ,
    set: function set(value) {
      if (value) {
        this.foundation_.open();
      } else {
        this.foundation_.close();
      }
    }
  }, {
    key: "itemsContainer_",
    get: function get() {
      return this.root_.querySelector(MDCMenuFoundation.strings.ITEMS_SELECTOR);
    }
    /**
     * Return the items within the menu. Note that this only contains the set of elements within
     * the items container that are proper list items, and not supplemental / presentational DOM
     * elements.
     * @return {!Array<!Element>}
     */

  }, {
    key: "items",
    get: function get() {
      var itemsContainer = this.itemsContainer_;
      return [].slice.call(itemsContainer.querySelectorAll('.mdc-list-item[role]'));
    }
  }, {
    key: "selectedItemIndex",
    set: function set(index) {
      this.foundation_.setSelectedIndex(index);
    }
    /** @return {number} */
    ,
    get: function get() {
      return this.foundation_.getSelectedIndex();
    }
    /** @param {!boolean} rememberSelection */

  }, {
    key: "rememberSelection",
    set: function set(rememberSelection) {
      this.foundation_.setRememberSelection(rememberSelection);
    }
    /** @param {boolean} quickOpen */

  }, {
    key: "quickOpen",
    set: function set(quickOpen) {
      this.foundation_.setQuickOpen(quickOpen);
    }
  }], [{
    key: "attachTo",
    value: function attachTo(root) {
      return new MDCMenu(root);
    }
  }]);

  return MDCMenu;
}(MDCComponent);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MdcMenuChange = /** @class */ (function () {
    function MdcMenuChange(index, source) {
        this.index = index;
        this.source = source;
    }
    return MdcMenuChange;
}());
var /** @type {?} */ nextUniqueId = 0;
var /** @type {?} */ uniqueIdCounter = 0;
var MdcMenuAnchor = /** @class */ (function () {
    function MdcMenuAnchor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
    MdcMenuAnchor.decorators = [
        { type: Component, args: [{selector: '[mdc-menu-anchor], [mdcMenuAnchor], mdc-menu-anchor',
                    exportAs: 'mdcMenuAnchor',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    /** @nocollapse */
    MdcMenuAnchor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    MdcMenuAnchor.propDecorators = {
        isHostClass: [{ type: HostBinding, args: ['class.mdc-menu-anchor',] }]
    };
    return MdcMenuAnchor;
}());
var MdcMenuDivider = /** @class */ (function () {
    function MdcMenuDivider(elementRef) {
        this.elementRef = elementRef;
    }
    MdcMenuDivider.decorators = [
        { type: Component, args: [{selector: '[mdc-menu-divider], mdc-menu-divider',
                    exportAs: 'mdcMenuDivider',
                    template: '<div class="mdc-list-divider" role="seperator"></div>',
                },] },
    ];
    /** @nocollapse */
    MdcMenuDivider.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return MdcMenuDivider;
}());
var MdcMenuItems = /** @class */ (function () {
    function MdcMenuItems(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
        this.isSelectClass = true;
        this.role = 'menu';
        this.ariaHidden = 'true';
    }
    MdcMenuItems.decorators = [
        { type: Directive, args: [{
                    selector: 'mdc-menu-items',
                    exportAs: 'mdcMenuItems'
                },] },
    ];
    /** @nocollapse */
    MdcMenuItems.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    MdcMenuItems.propDecorators = {
        isHostClass: [{ type: HostBinding, args: ['class.mdc-list',] }],
        isSelectClass: [{ type: HostBinding, args: ['class.mdc-menu__items',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }]
    };
    return MdcMenuItems;
}());
var MdcMenuItem = /** @class */ (function () {
    function MdcMenuItem(_renderer, elementRef) {
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this.id = "mdc-menu-item-" + uniqueIdCounter++;
        this._disabled = false;
        this.isHostClass = true;
        this.role = 'menuitem';
    }
    Object.defineProperty(MdcMenuItem.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () { return this._disabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = toBoolean(value);
            value ? this._renderer.setAttribute(this.elementRef.nativeElement, 'aria-disabled', 'true')
                : this._renderer.removeAttribute(this.elementRef.nativeElement, 'aria-disabled');
        },
        enumerable: true,
        configurable: true
    });
    /** Used to set the `tabindex`. */
    /**
     * Used to set the `tabindex`.
     * @return {?}
     */
    MdcMenuItem.prototype._getTabIndex = /**
     * Used to set the `tabindex`.
     * @return {?}
     */
    function () {
        return this.disabled ? '-1' : '0';
    };
    MdcMenuItem.decorators = [
        { type: Component, args: [{selector: 'mdc-menu-item',
                    exportAs: 'mdcMenuItem',
                    host: {
                        '[id]': 'id',
                        '[attr.tabindex]': '_getTabIndex()',
                    },
                    template: '<ng-content></ng-content>',
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    MdcMenuItem.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    MdcMenuItem.propDecorators = {
        id: [{ type: Input }],
        label: [{ type: Input }],
        disabled: [{ type: Input }],
        isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }]
    };
    return MdcMenuItem;
}());
var MdcMenu = /** @class */ (function () {
    function MdcMenu(_changeDetectorRef, _renderer, elementRef, _registry) {
        var _this = this;
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        this._uniqueId = "mdc-menu-" + ++nextUniqueId;
        this.id = this._uniqueId;
        this._anchorCorner = 'top-start';
        this._rememberSelection = false;
        this._quickOpen = false;
        this.cancel = new EventEmitter();
        this.select = new EventEmitter();
        this.isHostClass = true;
        this.tabindex = -1;
        this._mdcAdapter = {
            addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
            removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
            hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
            hasNecessaryDom: function () { return _this.menuContainer; },
            getAttributeForEventTarget: function (target, attributeName) { return target.getAttribute(attributeName); },
            getInnerDimensions: function () {
                return {
                    width: _this.menuContainer.elementRef.nativeElement.offsetWidth,
                    height: _this.menuContainer.elementRef.nativeElement.offsetHeight
                };
            },
            hasAnchor: function () { return _this.anchor; },
            getAnchorDimensions: function () { return _this.anchor.elementRef.nativeElement.getBoundingClientRect(); },
            getWindowDimensions: function () {
                return {
                    width: isBrowser() ? window.innerWidth : 0,
                    height: isBrowser() ? window.innerHeight : 0
                };
            },
            getNumberOfItems: function () { return _this.options ? _this.options.length : 0; },
            registerInteractionHandler: function (type, handler) { return _this._registry.listen(type, handler, _this._getHostElement()); },
            deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
            registerBodyClickHandler: function (handler) { return _this._registry.listen('click', handler, document.body); },
            deregisterBodyClickHandler: function (handler) { return _this._registry.unlisten('click', handler); },
            getIndexForEventTarget: function (target) { return _this.options.toArray().findIndex(function (_) { return _.elementRef.nativeElement === target; }); },
            notifySelected: function (evtData) {
                return _this.select.emit(new MdcMenuChange(evtData.index, _this.options.toArray()[evtData.index]));
            },
            notifyCancel: function () { return _this.cancel.emit(); },
            saveFocus: function () {
                if (isBrowser()) {
                    _this._previousFocus = document.activeElement;
                }
            },
            restoreFocus: function () {
                if (_this._previousFocus) {
                    _this._previousFocus.focus();
                }
            },
            isFocused: function () { return document.activeElement === _this._getHostElement(); },
            focus: function () { return _this._getHostElement().focus(); },
            getFocusedItemIndex: function () { return _this.options.toArray().map(function (_) { return _.elementRef.nativeElement; }).indexOf(document.activeElement); },
            focusItemAtIndex: function (index) { return _this.options.toArray()[index].elementRef.nativeElement.focus(); },
            isRtl: function () { return getComputedStyle(_this._getHostElement()).getPropertyValue('direction') === 'rtl'; },
            setTransformOrigin: function (origin) {
                if (isBrowser()) {
                    _this._renderer.setStyle(_this._getHostElement(), getTransformPropertyName(window) + "-origin", origin);
                }
            },
            setPosition: function (position) {
                position.left ? _this._setStyle('left', position.left) : _this._setStyle('left');
                position.right ? _this._setStyle('right', position.right) : _this._setStyle('right');
                position.top ? _this._setStyle('top', position.top) : _this._setStyle('top');
                position.bottom ? _this._setStyle('bottom', position.bottom) : _this._setStyle('bottom');
            },
            setMaxHeight: function (height) { return _this._renderer.setStyle(_this._getHostElement(), 'maxHeight', height); },
            setAttrForOptionAtIndex: function (index, attr, value) {
                return _this._renderer.setAttribute(_this.options.toArray()[index].elementRef.nativeElement, attr, value);
            },
            rmAttrForOptionAtIndex: function (index, attr) {
                return _this._renderer.removeAttribute(_this.options.toArray()[index].elementRef.nativeElement, attr);
            },
            addClassForOptionAtIndex: function (index, className) {
                return _this._renderer.addClass(_this.options.toArray()[index].elementRef.nativeElement, className);
            },
            rmClassForOptionAtIndex: function (index, className) {
                return _this._renderer.removeClass(_this.options.toArray()[index].elementRef.nativeElement, className);
            },
        };
        this._foundation = new MDCMenuFoundation(this._mdcAdapter);
    }
    Object.defineProperty(MdcMenu.prototype, "anchorCorner", {
        get: /**
         * @return {?}
         */
        function () { return this._anchorCorner; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setAnchorCorner(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcMenu.prototype, "rememberSelection", {
        get: /**
         * @return {?}
         */
        function () { return this._rememberSelection; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setRememberSelection(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcMenu.prototype, "quickOpen", {
        get: /**
         * @return {?}
         */
        function () { return this._quickOpen; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setQuickOpen(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdcMenu.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this._foundation.init();
    };
    /**
     * @return {?}
     */
    MdcMenu.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._foundation.destroy();
    };
    /**
     * @param {?} rememberSelection
     * @return {?}
     */
    MdcMenu.prototype.setRememberSelection = /**
     * @param {?} rememberSelection
     * @return {?}
     */
    function (rememberSelection) {
        this._rememberSelection = rememberSelection;
        this._foundation.setRememberSelection(rememberSelection);
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @param {?} index
     * @return {?}
     */
    MdcMenu.prototype.setSelectedIndex = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this._foundation.setSelectedIndex(index);
    };
    /**
     * @return {?}
     */
    MdcMenu.prototype.getSelectedIndex = /**
     * @return {?}
     */
    function () {
        return this._foundation.getSelectedIndex();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MdcMenu.prototype.setAnchorCorner = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._anchorCorner = value;
        if (this._foundation) {
            var /** @type {?} */ corner = this._parseAnchorCorner(value);
            this._foundation.setAnchorCorner(corner);
        }
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @param {?} quickOpen
     * @return {?}
     */
    MdcMenu.prototype.setQuickOpen = /**
     * @param {?} quickOpen
     * @return {?}
     */
    function (quickOpen) {
        this._quickOpen = quickOpen;
        this._foundation.setQuickOpen(quickOpen);
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @param {?} height
     * @return {?}
     */
    MdcMenu.prototype.setMaxHeight = /**
     * @param {?} height
     * @return {?}
     */
    function (height) {
        this._mdcAdapter.setMaxHeight(height);
    };
    /**
     * @return {?}
     */
    MdcMenu.prototype.isOpen = /**
     * @return {?}
     */
    function () {
        return this._foundation.isOpen();
    };
    /**
     * @return {?}
     */
    MdcMenu.prototype.open = /**
     * @return {?}
     */
    function () {
        if (!this.isOpen()) {
            this._foundation.open();
        }
    };
    /**
     * @return {?}
     */
    MdcMenu.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.isOpen() ? this.close() : this.open();
    };
    /**
     * @return {?}
     */
    MdcMenu.prototype.close = /**
     * @return {?}
     */
    function () {
        this._foundation.close();
    };
    /**
     * @return {?}
     */
    MdcMenu.prototype.focus = /**
     * @return {?}
     */
    function () {
        this._getHostElement().focus();
    };
    /**
     * @param {?} anchorPoint
     * @param {?=} position
     * @return {?}
     */
    MdcMenu.prototype._setStyle = /**
     * @param {?} anchorPoint
     * @param {?=} position
     * @return {?}
     */
    function (anchorPoint, position) {
        position ? this._renderer.setStyle(this._getHostElement(), anchorPoint, position)
            : this._renderer.removeStyle(this._getHostElement(), anchorPoint);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MdcMenu.prototype._parseAnchorCorner = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        switch (value) {
            case 'top-end': {
                return Corner.TOP_END;
            }
            case 'bottom-start': {
                return Corner.BOTTOM_START;
            }
            case 'bottom-end': {
                return Corner.BOTTOM_END;
            }
            default: {
                return Corner.TOP_START;
            }
        }
    };
    /**
     * Retrieves the DOM element of the component host.
     * @return {?}
     */
    MdcMenu.prototype._getHostElement = /**
     * Retrieves the DOM element of the component host.
     * @return {?}
     */
    function () {
        return this.elementRef.nativeElement;
    };
    MdcMenu.decorators = [
        { type: Component, args: [{selector: 'mdc-menu',
                    host: {
                        '[id]': 'id',
                    },
                    exportAs: 'mdcMenu',
                    template: "\n  <mdc-menu-items>\n    <ng-content></ng-content>\n  </mdc-menu-items>\n  ",
                    providers: [EventRegistry],
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    MdcMenu.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: Renderer2 },
        { type: ElementRef },
        { type: EventRegistry }
    ]; };
    MdcMenu.propDecorators = {
        id: [{ type: Input }],
        anchor: [{ type: Input }],
        anchorCorner: [{ type: Input }],
        rememberSelection: [{ type: Input }],
        quickOpen: [{ type: Input }],
        cancel: [{ type: Output }],
        select: [{ type: Output }],
        isHostClass: [{ type: HostBinding, args: ['class.mdc-menu',] }],
        tabindex: [{ type: HostBinding, args: ['tabindex',] }],
        menuContainer: [{ type: ViewChild, args: [MdcMenuItems,] }],
        options: [{ type: ContentChildren, args: [MdcMenuItem,] }]
    };
    return MdcMenu;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ MENU_DECLARATIONS = [
    MdcMenu,
    MdcMenuAnchor,
    MdcMenuDivider,
    MdcMenuItem,
    MdcMenuItems,
];
var MdcMenuModule = /** @class */ (function () {
    function MdcMenuModule() {
    }
    MdcMenuModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    exports: [MENU_DECLARATIONS],
                    declarations: [MENU_DECLARATIONS],
                },] },
    ];
    return MdcMenuModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcMenuModule, MdcMenuChange, MdcMenuAnchor, MdcMenuDivider, MdcMenuItems, MdcMenuItem, MdcMenu };
