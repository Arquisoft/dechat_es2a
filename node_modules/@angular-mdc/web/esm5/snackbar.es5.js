/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { Subject } from 'rxjs';
import { __assign } from 'tslib';
import { Component, ElementRef, EventEmitter, HostBinding, Output, Renderer2, ViewChild, ViewEncapsulation, Injectable, NgModule } from '@angular/core';
import { isBrowser, EventRegistry, MdcPortalService } from '@angular-mdc/web/common';
import { takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Reference to a snackbar dispatched from the snackbar service.
 * @template T
 */
var  /**
 * Reference to a snackbar dispatched from the snackbar service.
 * @template T
 */
MdcSnackbarRef = /** @class */ (function () {
    function MdcSnackbarRef(component) {
        /**
         * Subject for notifying the user that the snackbar has been dismissed.
         */
        this._afterDismiss = new Subject();
        /**
         * Subject for notifying the user that the snackbar has opened and appeared.
         */
        this._afterOpen = new Subject();
        this.componentInstance = component;
    }
    /** Gets an observable that is notified when the snackbar is finished closing. */
    /**
     * Gets an observable that is notified when the snackbar is finished closing.
     * @return {?}
     */
    MdcSnackbarRef.prototype.afterDismiss = /**
     * Gets an observable that is notified when the snackbar is finished closing.
     * @return {?}
     */
    function () {
        return this._afterDismiss.asObservable();
    };
    /** Gets an observable that is notified when the snackbar has opened and appeared. */
    /**
     * Gets an observable that is notified when the snackbar has opened and appeared.
     * @return {?}
     */
    MdcSnackbarRef.prototype.afterOpen = /**
     * Gets an observable that is notified when the snackbar has opened and appeared.
     * @return {?}
     */
    function () {
        return this._afterOpen.asObservable();
    };
    /**
     * @return {?}
     */
    MdcSnackbarRef.prototype.open = /**
     * @return {?}
     */
    function () {
        this.componentInstance.show();
        this._afterOpen.next();
        this._afterOpen.complete();
    };
    /**
     * @return {?}
     */
    MdcSnackbarRef.prototype.dismiss = /**
     * @return {?}
     */
    function () {
        this._afterDismiss.next();
        this._afterDismiss.complete();
    };
    return MdcSnackbarRef;
}());

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
var MDCFoundation =
/*#__PURE__*/
function () {
  _createClass(MDCFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    }
    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    }
    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    }
    /** @return {!Object} */

  }, {
    key: "defaultAdapter",
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    }
    /**
     * @param {A=} adapter
     */

  }]);

  function MDCFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MDCFoundation);

    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  _createClass(MDCFoundation, [{
    key: "init",
    value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
    }
  }, {
    key: "destroy",
    value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    }
  }]);

  return MDCFoundation;
}();

/**
 * @template F
 */

var MDCComponent =
/*#__PURE__*/
function () {
  _createClass(MDCComponent, null, [{
    key: "attachTo",

    /**
     * @param {!Element} root
     * @return {!MDCComponent}
     */
    value: function attachTo(root) {
      // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
      // returns an instantiated component with its root set to that element. Also note that in the cases of
      // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
      // from getDefaultFoundation().
      return new MDCComponent(root, new MDCFoundation());
    }
    /**
     * @param {!Element} root
     * @param {F=} foundation
     * @param {...?} args
     */

  }]);

  function MDCComponent(root) {
    var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    _classCallCheck(this, MDCComponent);

    /** @protected {!Element} */
    this.root_ = root;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  _createClass(MDCComponent, [{
    key: "initialize",
    value: function initialize()
    /* ...args */
    {} // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.

    /**
     * @return {!F} foundation
     */

  }, {
    key: "getDefaultFoundation",
    value: function getDefaultFoundation() {
      // Subclasses must override this method to return a properly configured foundation class for the
      // component.
      throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
    }
  }, {
    key: "initialSyncWithDOM",
    value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
      // object. An example of this would be a form control wrapper that needs to synchronize its internal state
      // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
      // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // Subclasses may implement this method to release any resources / deregister any listeners they have
      // attached. An example of this might be deregistering a resize event from the window object.
      this.foundation_.destroy();
    }
    /**
     * Wrapper method to add an event listener to the component's root element. This is most useful when
     * listening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "listen",
    value: function listen(evtType, handler) {
      this.root_.addEventListener(evtType, handler);
    }
    /**
     * Wrapper method to remove an event listener to the component's root element. This is most useful when
     * unlistening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "unlisten",
    value: function unlisten(evtType, handler) {
      this.root_.removeEventListener(evtType, handler);
    }
    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type,
     * with the given data.
     * @param {string} evtType
     * @param {!Object} evtData
     * @param {boolean=} shouldBubble
     */

  }, {
    key: "emit",
    value: function emit(evtType, evtData) {
      var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var evt;

      if (typeof CustomEvent === 'function') {
        evt = new CustomEvent(evtType, {
          detail: evtData,
          bubbles: shouldBubble
        });
      } else {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }

      this.root_.dispatchEvent(evt);
    }
  }]);

  return MDCComponent;
}();

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var cssClasses = {
  ROOT: 'mdc-snackbar',
  TEXT: 'mdc-snackbar__text',
  ACTION_WRAPPER: 'mdc-snackbar__action-wrapper',
  ACTION_BUTTON: 'mdc-snackbar__action-button',
  ACTIVE: 'mdc-snackbar--active',
  MULTILINE: 'mdc-snackbar--multiline',
  ACTION_ON_BOTTOM: 'mdc-snackbar--action-on-bottom'
};
var strings = {
  TEXT_SELECTOR: '.mdc-snackbar__text',
  ACTION_WRAPPER_SELECTOR: '.mdc-snackbar__action-wrapper',
  ACTION_BUTTON_SELECTOR: '.mdc-snackbar__action-button',
  SHOW_EVENT: 'MDCSnackbar:show',
  HIDE_EVENT: 'MDCSnackbar:hide'
};
var numbers = {
  MESSAGE_TIMEOUT: 2750
};

var MDCSnackbarFoundation =
/*#__PURE__*/
function (_MDCFoundation) {
  _inherits(MDCSnackbarFoundation, _MDCFoundation);

  _createClass(MDCSnackbarFoundation, [{
    key: "active",
    get: function get() {
      return this.active_;
    }
  }], [{
    key: "cssClasses",
    get: function get() {
      return cssClasses;
    }
  }, {
    key: "strings",
    get: function get() {
      return strings;
    }
  }, {
    key: "defaultAdapter",
    get: function get() {
      return {
        addClass: function addClass()
        /* className: string */
        {},
        removeClass: function removeClass()
        /* className: string */
        {},
        setAriaHidden: function setAriaHidden() {},
        unsetAriaHidden: function unsetAriaHidden() {},
        setActionAriaHidden: function setActionAriaHidden() {},
        unsetActionAriaHidden: function unsetActionAriaHidden() {},
        setActionText: function setActionText()
        /* actionText: string */
        {},
        setMessageText: function setMessageText()
        /* message: string */
        {},
        setFocus: function setFocus() {},
        visibilityIsHidden: function visibilityIsHidden() {
          return (
            /* boolean */
            false
          );
        },
        registerCapturedBlurHandler: function registerCapturedBlurHandler()
        /* handler: EventListener */
        {},
        deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler()
        /* handler: EventListener */
        {},
        registerVisibilityChangeHandler: function registerVisibilityChangeHandler()
        /* handler: EventListener */
        {},
        deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler()
        /* handler: EventListener */
        {},
        registerCapturedInteractionHandler: function registerCapturedInteractionHandler()
        /* evtType: string, handler: EventListener */
        {},
        deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler()
        /* evtType: string, handler: EventListener */
        {},
        registerActionClickHandler: function registerActionClickHandler()
        /* handler: EventListener */
        {},
        deregisterActionClickHandler: function deregisterActionClickHandler()
        /* handler: EventListener */
        {},
        registerTransitionEndHandler: function registerTransitionEndHandler()
        /* handler: EventListener */
        {},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler()
        /* handler: EventListener */
        {},
        notifyShow: function notifyShow() {},
        notifyHide: function notifyHide() {}
      };
    }
  }]);

  function MDCSnackbarFoundation(adapter) {
    var _this;

    _classCallCheck(this, MDCSnackbarFoundation);

    _this = _possibleConstructorReturn(this, (MDCSnackbarFoundation.__proto__ || Object.getPrototypeOf(MDCSnackbarFoundation)).call(this, Object.assign(MDCSnackbarFoundation.defaultAdapter, adapter)));
    _this.active_ = false;
    _this.actionWasClicked_ = false;
    _this.dismissOnAction_ = true;
    _this.firstFocus_ = true;
    _this.pointerDownRecognized_ = false;
    _this.snackbarHasFocus_ = false;
    _this.snackbarData_ = null;
    _this.queue_ = [];

    _this.actionClickHandler_ = function () {
      _this.actionWasClicked_ = true;

      _this.invokeAction_();
    };

    _this.visibilitychangeHandler_ = function () {
      clearTimeout(_this.timeoutId_);
      _this.snackbarHasFocus_ = true;

      if (!_this.adapter_.visibilityIsHidden()) {
        setTimeout(_this.cleanup_.bind(_assertThisInitialized(_this)), _this.snackbarData_.timeout || numbers.MESSAGE_TIMEOUT);
      }
    };

    _this.interactionHandler_ = function (evt) {
      if (evt.type == 'touchstart' || evt.type == 'mousedown') {
        _this.pointerDownRecognized_ = true;
      }

      _this.handlePossibleTabKeyboardFocus_(evt);

      if (evt.type == 'focus') {
        _this.pointerDownRecognized_ = false;
      }
    };

    _this.blurHandler_ = function () {
      clearTimeout(_this.timeoutId_);
      _this.snackbarHasFocus_ = false;
      _this.timeoutId_ = setTimeout(_this.cleanup_.bind(_assertThisInitialized(_this)), _this.snackbarData_.timeout || numbers.MESSAGE_TIMEOUT);
    };

    return _this;
  }

  _createClass(MDCSnackbarFoundation, [{
    key: "init",
    value: function init() {
      this.adapter_.registerActionClickHandler(this.actionClickHandler_);
      this.adapter_.setAriaHidden();
      this.adapter_.setActionAriaHidden();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.adapter_.deregisterActionClickHandler(this.actionClickHandler_);
      this.adapter_.deregisterCapturedBlurHandler(this.blurHandler_);
      this.adapter_.deregisterVisibilityChangeHandler(this.visibilitychangeHandler_);
      ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
        _this2.adapter_.deregisterCapturedInteractionHandler(evtType, _this2.interactionHandler_);
      });
    }
  }, {
    key: "dismissesOnAction",
    value: function dismissesOnAction() {
      return this.dismissOnAction_;
    }
  }, {
    key: "setDismissOnAction",
    value: function setDismissOnAction(dismissOnAction) {
      this.dismissOnAction_ = !!dismissOnAction;
    }
  }, {
    key: "show",
    value: function show(data) {
      var _this3 = this;

      if (!data) {
        throw new Error('Please provide a data object with at least a message to display.');
      }

      if (!data.message) {
        throw new Error('Please provide a message to be displayed.');
      }

      if (data.actionHandler && !data.actionText) {
        throw new Error('Please provide action text with the handler.');
      }

      if (this.active) {
        this.queue_.push(data);
        return;
      }

      clearTimeout(this.timeoutId_);
      this.snackbarData_ = data;
      this.firstFocus_ = true;
      this.adapter_.registerVisibilityChangeHandler(this.visibilitychangeHandler_);
      this.adapter_.registerCapturedBlurHandler(this.blurHandler_);
      ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
        _this3.adapter_.registerCapturedInteractionHandler(evtType, _this3.interactionHandler_);
      });
      var ACTIVE = cssClasses.ACTIVE,
          MULTILINE = cssClasses.MULTILINE,
          ACTION_ON_BOTTOM = cssClasses.ACTION_ON_BOTTOM;
      this.adapter_.setMessageText(this.snackbarData_.message);

      if (this.snackbarData_.multiline) {
        this.adapter_.addClass(MULTILINE);

        if (this.snackbarData_.actionOnBottom) {
          this.adapter_.addClass(ACTION_ON_BOTTOM);
        }
      }

      if (this.snackbarData_.actionHandler) {
        this.adapter_.setActionText(this.snackbarData_.actionText);
        this.actionHandler_ = this.snackbarData_.actionHandler;
        this.setActionHidden_(false);
      } else {
        this.setActionHidden_(true);
        this.actionHandler_ = null;
        this.adapter_.setActionText(null);
      }

      this.active_ = true;
      this.adapter_.addClass(ACTIVE);
      this.adapter_.unsetAriaHidden();
      this.adapter_.notifyShow();
      this.timeoutId_ = setTimeout(this.cleanup_.bind(this), this.snackbarData_.timeout || numbers.MESSAGE_TIMEOUT);
    }
  }, {
    key: "handlePossibleTabKeyboardFocus_",
    value: function handlePossibleTabKeyboardFocus_() {
      var hijackFocus = this.firstFocus_ && !this.pointerDownRecognized_;

      if (hijackFocus) {
        this.setFocusOnAction_();
      }

      this.firstFocus_ = false;
    }
  }, {
    key: "setFocusOnAction_",
    value: function setFocusOnAction_() {
      this.adapter_.setFocus();
      this.snackbarHasFocus_ = true;
      this.firstFocus_ = false;
    }
  }, {
    key: "invokeAction_",
    value: function invokeAction_() {
      try {
        if (!this.actionHandler_) {
          return;
        }

        this.actionHandler_();
      } finally {
        if (this.dismissOnAction_) {
          this.cleanup_();
        }
      }
    }
  }, {
    key: "cleanup_",
    value: function cleanup_() {
      var _this4 = this;

      var allowDismissal = !this.snackbarHasFocus_ || this.actionWasClicked_;

      if (allowDismissal) {
        var ACTIVE = cssClasses.ACTIVE,
            MULTILINE = cssClasses.MULTILINE,
            ACTION_ON_BOTTOM = cssClasses.ACTION_ON_BOTTOM;
        this.adapter_.removeClass(ACTIVE);

        var handler = function handler() {
          clearTimeout(_this4.timeoutId_);

          _this4.adapter_.deregisterTransitionEndHandler(handler);

          _this4.adapter_.removeClass(MULTILINE);

          _this4.adapter_.removeClass(ACTION_ON_BOTTOM);

          _this4.setActionHidden_(true);

          _this4.adapter_.setAriaHidden();

          _this4.active_ = false;
          _this4.snackbarHasFocus_ = false;

          _this4.adapter_.notifyHide();

          _this4.showNext_();
        };

        this.adapter_.registerTransitionEndHandler(handler);
      }
    }
  }, {
    key: "showNext_",
    value: function showNext_() {
      if (!this.queue_.length) {
        return;
      }

      this.show(this.queue_.shift());
    }
  }, {
    key: "setActionHidden_",
    value: function setActionHidden_(isHidden) {
      if (isHidden) {
        this.adapter_.setActionAriaHidden();
      } else {
        this.adapter_.unsetActionAriaHidden();
      }
    }
  }]);

  return MDCSnackbarFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @const {Object<string, !VendorPropertyMapType>} */

var eventTypeMap = {
  'animationstart': {
    noPrefix: 'animationstart',
    webkitPrefix: 'webkitAnimationStart',
    styleProperty: 'animation'
  },
  'animationend': {
    noPrefix: 'animationend',
    webkitPrefix: 'webkitAnimationEnd',
    styleProperty: 'animation'
  },
  'animationiteration': {
    noPrefix: 'animationiteration',
    webkitPrefix: 'webkitAnimationIteration',
    styleProperty: 'animation'
  },
  'transitionend': {
    noPrefix: 'transitionend',
    webkitPrefix: 'webkitTransitionEnd',
    styleProperty: 'transition'
  }
};
/** @const {Object<string, !VendorPropertyMapType>} */

var cssPropertyMap = {
  'animation': {
    noPrefix: 'animation',
    webkitPrefix: '-webkit-animation'
  },
  'transform': {
    noPrefix: 'transform',
    webkitPrefix: '-webkit-transform'
  },
  'transition': {
    noPrefix: 'transition',
    webkitPrefix: '-webkit-transition'
  }
};
/**
 * @param {!Object} windowObj
 * @return {boolean}
 */

function hasProperShape(windowObj) {
  return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
}
/**
 * @param {string} eventType
 * @return {boolean}
 */


function eventFoundInMaps(eventType) {
  return eventType in eventTypeMap || eventType in cssPropertyMap;
}
/**
 * @param {string} eventType
 * @param {!Object<string, !VendorPropertyMapType>} map
 * @param {!Element} el
 * @return {string}
 */


function getJavaScriptEventName(eventType, map, el) {
  return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
}
/**
 * Helper function to determine browser prefix for CSS3 animation events
 * and property names.
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */


function getAnimationName(windowObj, eventType) {
  if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
    return eventType;
  }

  var map =
  /** @type {!Object<string, !VendorPropertyMapType>} */
  eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
  var el = windowObj['document']['createElement']('div');
  var eventName = '';

  if (map === eventTypeMap) {
    eventName = getJavaScriptEventName(eventType, map, el);
  } else {
    eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  return eventName;
} // Public functions to access getAnimationName() for JavaScript events or CSS
/**
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */

function getCorrectEventName(windowObj, eventType) {
  return getAnimationName(windowObj, eventType);
}

var MDCSnackbar =
/*#__PURE__*/
function (_MDCComponent) {
  _inherits(MDCSnackbar, _MDCComponent);

  function MDCSnackbar() {
    _classCallCheck(this, MDCSnackbar);

    return _possibleConstructorReturn(this, (MDCSnackbar.__proto__ || Object.getPrototypeOf(MDCSnackbar)).apply(this, arguments));
  }

  _createClass(MDCSnackbar, [{
    key: "show",
    value: function show(data) {
      this.foundation_.show(data);
    }
  }, {
    key: "getDefaultFoundation",
    value: function getDefaultFoundation() {
      var _this = this;

      var _MDCSnackbarFoundatio = MDCSnackbarFoundation.strings,
          TEXT_SELECTOR = _MDCSnackbarFoundatio.TEXT_SELECTOR,
          ACTION_BUTTON_SELECTOR = _MDCSnackbarFoundatio.ACTION_BUTTON_SELECTOR;

      var getText = function getText() {
        return _this.root_.querySelector(TEXT_SELECTOR);
      };

      var getActionButton = function getActionButton() {
        return _this.root_.querySelector(ACTION_BUTTON_SELECTOR);
      };
      /* eslint brace-style: "off" */


      return new MDCSnackbarFoundation({
        addClass: function addClass(className) {
          return _this.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return _this.root_.classList.remove(className);
        },
        setAriaHidden: function setAriaHidden() {
          return _this.root_.setAttribute('aria-hidden', 'true');
        },
        unsetAriaHidden: function unsetAriaHidden() {
          return _this.root_.removeAttribute('aria-hidden');
        },
        setActionAriaHidden: function setActionAriaHidden() {
          return getActionButton().setAttribute('aria-hidden', 'true');
        },
        unsetActionAriaHidden: function unsetActionAriaHidden() {
          return getActionButton().removeAttribute('aria-hidden');
        },
        setActionText: function setActionText(text) {
          getActionButton().textContent = text;
        },
        setMessageText: function setMessageText(text) {
          getText().textContent = text;
        },
        setFocus: function setFocus() {
          return getActionButton().focus();
        },
        visibilityIsHidden: function visibilityIsHidden() {
          return document.hidden;
        },
        registerCapturedBlurHandler: function registerCapturedBlurHandler(handler) {
          return getActionButton().addEventListener('blur', handler, true);
        },
        deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler(handler) {
          return getActionButton().removeEventListener('blur', handler, true);
        },
        registerVisibilityChangeHandler: function registerVisibilityChangeHandler(handler) {
          return document.addEventListener('visibilitychange', handler);
        },
        deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler(handler) {
          return document.removeEventListener('visibilitychange', handler);
        },
        registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
          return document.body.addEventListener(evt, handler, true);
        },
        deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
          return document.body.removeEventListener(evt, handler, true);
        },
        registerActionClickHandler: function registerActionClickHandler(handler) {
          return getActionButton().addEventListener('click', handler);
        },
        deregisterActionClickHandler: function deregisterActionClickHandler(handler) {
          return getActionButton().removeEventListener('click', handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          return _this.root_.addEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          return _this.root_.removeEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        notifyShow: function notifyShow() {
          return _this.emit(MDCSnackbarFoundation.strings.SHOW_EVENT);
        },
        notifyHide: function notifyHide() {
          return _this.emit(MDCSnackbarFoundation.strings.HIDE_EVENT);
        }
      });
    }
  }, {
    key: "dismissesOnAction",
    get: function get() {
      return this.foundation_.dismissesOnAction();
    },
    set: function set(dismissesOnAction) {
      this.foundation_.setDismissOnAction(dismissesOnAction);
    }
  }], [{
    key: "attachTo",
    value: function attachTo(root) {
      return new MDCSnackbar(root);
    }
  }]);

  return MDCSnackbar;
}(MDCComponent);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MdcSnackbarComponent = /** @class */ (function () {
    function MdcSnackbarComponent(_renderer, elementRef, _registry) {
        var _this = this;
        this._renderer = _renderer;
        this.elementRef = elementRef;
        this._registry = _registry;
        this.isHostClass = true;
        this.ariaLive = 'assertive';
        this.ariaAtomic = 'true';
        this.ariaHidden = 'true';
        /**
         * Event emitted when the snackbar is shown.
         */
        this.shown = new EventEmitter();
        /**
         * Event emitted when the snackbar is dismissed.
         */
        this.dismissed = new EventEmitter();
        this._mdcAdapter = {
            addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
            removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
            setAriaHidden: function () { return _this._renderer.setAttribute(_this._getHostElement(), 'aria-hidden', 'true'); },
            unsetAriaHidden: function () { return _this._renderer.removeAttribute(_this._getHostElement(), 'aria-hidden'); },
            setActionAriaHidden: function () {
                if (_this.actionButton) {
                    _this._renderer.setAttribute(_this.actionButton.nativeElement, 'aria-hidden', 'true');
                }
            },
            unsetActionAriaHidden: function () {
                if (_this.actionButton) {
                    _this._renderer.removeAttribute(_this.actionButton.nativeElement, 'aria-hidden');
                }
            },
            setMessageText: function (message) { return _this.snackText.nativeElement.textContent = message; },
            setActionText: function (actionText) {
                if (_this.actionButton) {
                    _this.actionButton.nativeElement.textContent = actionText;
                }
            },
            setFocus: function () { return _this.actionButton.nativeElement.focus(); },
            visibilityIsHidden: function () { return isBrowser() ? document.hidden : false; },
            registerCapturedBlurHandler: function (handler) {
                if (_this.actionButton) {
                    _this._registry.listen('blur', handler, _this.actionButton.nativeElement, true);
                }
            },
            deregisterCapturedBlurHandler: function (handler) { return _this._registry.unlisten('blur', handler); },
            registerVisibilityChangeHandler: function (handler) {
                if (isBrowser()) {
                    _this._registry.listen('visibilitychange', handler, document);
                }
            },
            deregisterVisibilityChangeHandler: function (handler) { return _this._registry.unlisten('visibilitychange', handler); },
            registerCapturedInteractionHandler: function (evtType, handler) {
                if (isBrowser()) {
                    _this._registry.listen(evtType, handler, document.body, true);
                }
            },
            deregisterCapturedInteractionHandler: function (evtType, handler) {
                return _this._registry.unlisten(evtType, handler);
            },
            registerActionClickHandler: function (handler) {
                if (_this.actionButton) {
                    _this._registry.listen('click', handler, _this.actionButton.nativeElement);
                }
            },
            deregisterActionClickHandler: function (handler) { return _this._registry.unlisten('click', handler); },
            registerTransitionEndHandler: function (handler) {
                if (isBrowser()) {
                    _this._registry.listen(getCorrectEventName(window, 'transitionend'), handler, _this._getHostElement());
                }
            },
            deregisterTransitionEndHandler: function (handler) {
                if (isBrowser()) {
                    _this._registry.unlisten(getCorrectEventName(window, 'transitionend'), handler);
                }
            },
            notifyShow: function () { return _this.shown.emit(); },
            notifyHide: function () { return _this.dismissed.emit(); }
        };
        this._foundation = new MDCSnackbarFoundation(this._mdcAdapter);
    }
    /**
     * @return {?}
     */
    MdcSnackbarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._foundation.init();
    };
    /**
     * @return {?}
     */
    MdcSnackbarComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._foundation.destroy();
    };
    /**
     * @param {?} dismissOnAction
     * @return {?}
     */
    MdcSnackbarComponent.prototype.setDismissOnAction = /**
     * @param {?} dismissOnAction
     * @return {?}
     */
    function (dismissOnAction) {
        this._foundation.setDismissOnAction(dismissOnAction);
    };
    /**
     * @return {?}
     */
    MdcSnackbarComponent.prototype.show = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.setDismissOnAction(this.config.dismissOnAction ? true : false);
        if (this.config.align === 'start') {
            this._mdcAdapter.addClass('mdc-snackbar--align-start');
        }
        if (!this.config.actionHandler && this.data.actionText) {
            this.config.actionHandler = function () { };
        }
        if (!this.data.actionText) {
            this.config.actionHandler = undefined;
        }
        setTimeout(function () {
            _this._foundation.show(__assign({}, _this.data, _this.config));
            if (_this.config.focusAction) {
                _this._mdcAdapter.setFocus();
            }
        }, 40);
    };
    /**
     * Retrieves the DOM element of the component host.
     * @return {?}
     */
    MdcSnackbarComponent.prototype._getHostElement = /**
     * Retrieves the DOM element of the component host.
     * @return {?}
     */
    function () {
        return this.elementRef.nativeElement;
    };
    MdcSnackbarComponent.decorators = [
        { type: Component, args: [{selector: 'mdc-snackbar',
                    template: "\n  <div #text class=\"mdc-snackbar__text\"></div>\n  <div class=\"mdc-snackbar__action-wrapper\">\n    <button #action type=\"submit\" class=\"mdc-snackbar__action-button\"></button>\n  </div>\n  ",
                    encapsulation: ViewEncapsulation.None,
                    providers: [EventRegistry]
                },] },
    ];
    /** @nocollapse */
    MdcSnackbarComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: EventRegistry }
    ]; };
    MdcSnackbarComponent.propDecorators = {
        isHostClass: [{ type: HostBinding, args: ['class.mdc-snackbar',] }],
        ariaLive: [{ type: HostBinding, args: ['attr.aria-live',] }],
        ariaAtomic: [{ type: HostBinding, args: ['attr.aria-atomic',] }],
        ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }],
        snackText: [{ type: ViewChild, args: ['text',] }],
        actionButton: [{ type: ViewChild, args: ['action',] }],
        shown: [{ type: Output }],
        dismissed: [{ type: Output }]
    };
    return MdcSnackbarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MdcSnackbarConfig = /** @class */ (function () {
    function MdcSnackbarConfig() {
        this.timeout = 2750;
        this.multiline = false;
        this.actionOnBottom = false;
        this.align = 'center';
        this.dismissOnAction = true;
        this.focusAction = false;
    }
    return MdcSnackbarConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MdcSnackbar = /** @class */ (function () {
    function MdcSnackbar(_portalService) {
        this._portalService = _portalService;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this._openedSnackbarRef = null;
    }
    /**
     * @return {?}
     */
    MdcSnackbar.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy.next();
        this._destroy.complete();
        this.dismiss();
    };
    /**
       * Shows a snackbar with a message and an optional action.
       * @param message The message to show in the snackbar.
       * @param actionText The label for the snackbar action.
       * @param config Additional configuration options for the snackbar.
       */
    /**
     * Shows a snackbar with a message and an optional action.
     * @param {?} message The message to show in the snackbar.
     * @param {?=} actionText The label for the snackbar action.
     * @param {?=} config Additional configuration options for the snackbar.
     * @return {?}
     */
    MdcSnackbar.prototype.show = /**
     * Shows a snackbar with a message and an optional action.
     * @param {?} message The message to show in the snackbar.
     * @param {?=} actionText The label for the snackbar action.
     * @param {?=} config Additional configuration options for the snackbar.
     * @return {?}
     */
    function (message, actionText, config) {
        var _this = this;
        if (actionText === void 0) { actionText = ''; }
        if (this.isShowing()) {
            this.dismiss();
        }
        this._openedSnackbarRef
            = new MdcSnackbarRef(this._portalService.createComponentRef(MdcSnackbarComponent).instance);
        this._openedSnackbarRef.componentInstance.data = { message: message, actionText: actionText };
        this._openedSnackbarRef.componentInstance.config = _applyConfigDefaults(config);
        this._snackbarSubscription = this._openedSnackbarRef.componentInstance.dismissed
            .pipe(takeUntil(this._destroy))
            .subscribe(function () {
            _this.dismiss();
        });
        this._openedSnackbarRef.open();
        return this._openedSnackbarRef;
    };
    /**
     * @return {?}
     */
    MdcSnackbar.prototype.isShowing = /**
     * @return {?}
     */
    function () {
        return !!this._openedSnackbarRef;
    };
    /**
     * Dismisses the currently-visible snack bar.
     */
    /**
     * Dismisses the currently-visible snack bar.
     * @return {?}
     */
    MdcSnackbar.prototype.dismiss = /**
     * Dismisses the currently-visible snack bar.
     * @return {?}
     */
    function () {
        if (this._openedSnackbarRef) {
            this._openedSnackbarRef.dismiss();
            this._portalService.dispose();
            this._openedSnackbarRef = null;
        }
    };
    MdcSnackbar.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    MdcSnackbar.ctorParameters = function () { return [
        { type: MdcPortalService }
    ]; };
    return MdcSnackbar;
}());
/**
 * Applies default options to the snackbar config.
 * @param {?=} config The configuration to which the defaults will be applied.
 * @return {?} The new configuration object with defaults applied.
 */
function _applyConfigDefaults(config) {
    return __assign({}, new MdcSnackbarConfig(), config);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MdcSnackbarModule = /** @class */ (function () {
    function MdcSnackbarModule() {
    }
    MdcSnackbarModule.decorators = [
        { type: NgModule, args: [{
                    exports: [MdcSnackbarComponent],
                    declarations: [MdcSnackbarComponent],
                    providers: [MdcSnackbar, MdcPortalService],
                    entryComponents: [MdcSnackbarComponent]
                },] },
    ];
    return MdcSnackbarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcSnackbarModule, MdcSnackbarConfig, MdcSnackbarRef, MdcSnackbarComponent, MdcSnackbar };
