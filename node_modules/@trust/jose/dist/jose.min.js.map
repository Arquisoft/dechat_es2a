{"version":3,"sources":["webpack:///jose.min.js","webpack:///webpack/bootstrap 0dd132bda4c7e2da52de","webpack:///./~/@trust/json-document/lib/index.js","webpack:///./~/base64url/index.js","webpack:///./lib/schemas/JWKSchema.js","webpack:///./~/buffer/index.js","webpack:///./lib/jose/JWA.js","webpack:///./~/@trust/json-document/lib/JSONPointer.js","webpack:///./lib/errors/DataError.js","webpack:///./lib/errors/NotSupportedError.js","webpack:///./lib/errors/index.js","webpack:///./lib/jose/JWK.js","webpack:///./lib/jose/JWS.js","webpack:///./lib/schemas/Base64URLSchema.js","webpack:///./lib/schemas/JOSEHeaderSchema.js","webpack:///./lib/schemas/JWKSetSchema.js","webpack:///./lib/schemas/JWTClaimsSetSchema.js","webpack:///./lib/schemas/JWTSchema.js","webpack:///./lib/text-encoder/index.js","webpack:///./~/@trust/json-document/lib/Formats.js","webpack:///./~/@trust/json-document/lib/Initializer.js","webpack:///./~/@trust/json-document/lib/JSONPatch.js","webpack:///./~/@trust/json-document/lib/Validator.js","webpack:///(webpack)/buildin/global.js","webpack:///external \"crypto\"","webpack:///./lib/index.js","webpack:///./lib/algorithms/HMAC.js","webpack:///./lib/algorithms/NONE.js","webpack:///./lib/algorithms/RSASSA-PKCS1-v1_5.js","webpack:///./lib/algorithms/SupportedAlgorithms.js","webpack:///./lib/algorithms/index.js","webpack:///./lib/formats/index.js","webpack:///./lib/jose/JWKSet.js","webpack:///./lib/jose/JWT.js","webpack:///./~/@trust/json-document/lib/JSONDocument.js","webpack:///./~/@trust/json-document/lib/JSONMapping.js","webpack:///./~/@trust/json-document/lib/JSONSchema.js","webpack:///./~/base64-js/index.js","webpack:///./~/base64url/dist/base64url.js","webpack:///./~/base64url/dist/pad-string.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js","webpack:///external \"TextEncoder\""],"names":["JOSE","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Formats","Initializer","JSONDocument","JSONMapping","JSONPatch","JSONPointer","JSONSchema","Validator","default","_require","_require2","JWKSchema","BASE64_REGEXP","type","properties","kty","enum","use","key_ops","items","alg","kid","x5u","x5c","x5t","global","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","that","length","RangeError","Uint8Array","__proto__","arg","encodingOrOffset","this","Error","allocUnsafe","from","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","undefined","checked","string","isEncoding","byteLength","actual","write","slice","fromArrayLike","array","byteOffset","obj","isBuffer","len","copy","buffer","isnan","isArray","data","toString","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","b","bidirectionalIndexOf","val","dir","isNaN","arrayIndexOf","indexOf","lastIndexOf","arr","read","buf","indexSize","readUInt16BE","arrLength","valLength","String","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","push","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","replace","INVALID_BASE64_RE","trim","units","Infinity","leadSurrogate","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","foo","subarray","e","poolSize","_augment","Symbol","species","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","arguments","equals","inspect","match","join","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","Array","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","code","_classCallCheck","instance","Constructor","_createClass","defineProperties","props","descriptor","writable","key","protoProps","staticProps","supportedAlgorithms","NotSupportedError","JWA","normalizedAlgorithm","normalize","Promise","reject","sign","signature","verify","importKey","THROW","expr","mode","tokens","charAt","parseURIFragmentIdentifier","parseJSONString","split","map","unescape","escape","decodeURIComponent","_this","token","encodeURIComponent","source","current","splice","_possibleConstructorReturn","self","ReferenceError","_typeof","_inherits","subClass","superClass","create","constructor","setPrototypeOf","iterator","DataError","_Error","message","getPrototypeOf","JWK","_JSONDocument","jwk","_slicedToArray","sliceIterator","_n","_d","_e","_s","_i","next","done","err","base64url","JWS","payload","JSON","stringify","serialization","header","then","jwt","signatures","_jwt$segments","segments","verified","resolve","Base64URLSchema","format","JOSEHeaderSchema","typ","cty","jku","crit","minItems","enc","zip","JWKSetSchema","keys","JWTClaimsSetSchema","iss","aud","exp","nbf","iat","jti","JWTSchema","protected","unprotected","iv","aad","ciphertext","tag","recipients","encrypted_key","TextEncoder","DATETIME_REGEXP","URI_REGEXP","EMAIL_REGEXP","IPV4_REGEXP","IPV6_REGEXP","HOSTNAME_REGEXP","pattern","RegExp","test","formats","register","initialize","_typeof2","schema","options","assign","root","depth","level","declarations","body","member","item","declaration","index","block","additionalProperties","additionalItems","forEach","subschema","initializer","compile","_index","Function","console","log","stack","OPERATIONS","ops","operation","op","path","add","remove","pointer","indexCount","address","require","validator","required","number","anyOf","allOf","not","oneOf","keywords","validations","filter","keyword","enumerated","conditions","isRequired","segment","validation","pop","patternValidations","additionalValidations","patternProperties","_schema","otherPropertiesCalled","otherProperties","minProperties","maxProperties","dependencies","dependency","_schema2","counter","maxItems","uniqueItems","minLength","maxLength","matcher","_schema3","minimum","exclusiveMinimum","_schema4","maximum","exclusiveMaximum","multipleOf","decimals","toFixed","condition","g","eval","window","crypto","JWKSet","JWT","HMAC","params","algorithm","encode","subtle","toBuffer","bitlength","None","RSASSA_PKCS1_v1_5","usages","cryptoKey","operations","SupportedAlgorithms","argument","registeredAlgorithms","SyntaxError","define","hash","jwks","validate","valid","imported","importing","all","find","isJWE","JWE","encrypt","ExtendedJWT","startsWith","parse","error","decode","alternate","mapping","project","RECOVER","Map","right","left","_defineProperty","writeable","isObject","extender","result","placeHoldersCount","b64","tmp","placeHolders","Arr","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","extraBytes","parts","len2","input","fromBase64","toBase64","pad_string_1","padString","stringLength","diff","position","padLength","paddedStringLength","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","abs","LN2"],"mappings":"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","file":"jose.min.js","sourcesContent":["var JOSE =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 41);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  Formats: __webpack_require__(17),\n  Initializer: __webpack_require__(18),\n  JSONDocument: __webpack_require__(32),\n  JSONMapping: __webpack_require__(33),\n  JSONPatch: __webpack_require__(19),\n  JSONPointer: __webpack_require__(5),\n  JSONSchema: __webpack_require__(34),\n  Validator: __webpack_require__(20)\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(36).default;\nmodule.exports.default = module.exports;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _require = __webpack_require__(0),\n    JSONSchema = _require.JSONSchema;\n\nvar _require2 = __webpack_require__(29\n\n/**\n * JWK Schema\n */\n),\n    BASE64_REGEXP = _require2.BASE64_REGEXP;\n\nvar JWKSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    kty: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['RSA', 'EC', 'oct'] // other values MAY be used\n    },\n\n    use: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['sig', 'enc'] // other values MAY be used\n    },\n\n    key_ops: {\n      type: 'array',\n      //format: 'case-sensitive',\n      items: {\n        enum: ['sign', 'verify', 'encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey', 'deriveBits'] // other values MAY be used\n      }\n    },\n\n    alg: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'PS256', 'PS384', 'PS512', 'none'] // other values MAY be used\n    },\n\n    kid: {\n      type: 'string'\n    },\n\n    x5u: {\n      type: 'string'\n      //format: 'url'\n    },\n\n    x5c: {\n      type: 'array'\n      //format: BASE64_REGEXP\n    },\n\n    x5t: {\n      type: 'string'\n      //format: BASE64_REGEXP\n\n\n      //'x5t#S256': {\n      //  type: 'string',\n      //  //format: BASE64_REGEXP\n      //}\n    } }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSchema;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(35);\nvar ieee754 = __webpack_require__(38);\nvar isArray = __webpack_require__(39);\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\n();exports.kMaxLength = kMaxLength();\n\nfunction typedArraySupport() {\n  try {\n    var arr = new Uint8Array(1);\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {\n        return 42;\n      } };\n    return arr.foo() === 42 && // typed array instances can be augmented\n    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction kMaxLength() {\n  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\n\nfunction createBuffer(that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length');\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that;\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length);\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error('If encoding is specified then the first argument must be a string');\n    }\n    return allocUnsafe(this, arg);\n  }\n  return from(this, arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr;\n};\n\nfunction from(that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset);\n  }\n\n  return fromObject(that, value);\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length);\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    });\n  }\n}\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number');\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative');\n  }\n}\n\nfunction alloc(that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size);\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n  }\n  return createBuffer(that, size);\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding);\n};\n\nfunction allocUnsafe(that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that;\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size);\n};\n\nfunction fromString(that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that;\n}\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that;\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that;\n}\n\nfunction fromObject(that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that;\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that;\n  }\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n      return fromArrayLike(that, obj);\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n  }\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return !!(b != null && b._isBuffer);\n};\n\nBuffer.compare = function compare(a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers');\n  }\n\n  if (a === b) return 0;\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0;\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length;\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n      case 'hex':\n        return len >>> 1;\n      case 'base64':\n        return base64ToBytes(string).length;\n      default:\n        if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length | 0;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>';\n};\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer');\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0;\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1;\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset; // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction latin1Write(buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints // avoid extra slice()\n    );\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf;\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0;\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n\n  return len;\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, ''\n  // Node converts strings with length < 2 to ''\n  );if (str.length < 2) return '';\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str;\n}\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i\n\n    // is surrogate component\n    );if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue;\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n  return i;\n}\n\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\nvar base64url = __webpack_require__(1);\nvar supportedAlgorithms = __webpack_require__(28);\n\nvar _require = __webpack_require__(8\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\n),\n    NotSupportedError = _require.NotSupportedError;\n\nvar JWA = function () {\n  function JWA() {\n    _classCallCheck(this, JWA);\n  }\n\n  _createClass(JWA, null, [{\n    key: 'sign',\n\n    /**\n     * Sign\n     *\n     * @description\n     * Create a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} key\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n    value: function sign(alg, key, data) {\n      // normalize the algorithm\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg\n\n      // validate algorithm is supported\n      );if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // validate type of key\n      // TODO\n      //  - is the key suitable for the algorithm?\n      //  - does that get validated in webcrypto?\n      //if (key instanceof CryptoKey) {\n      //  return Promise.reject(new InvalidKeyError())\n      //}\n\n      // sign the data\n      return normalizedAlgorithm.sign(key, data);\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} privateKey\n     * @param {string|Buffer} signature\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(alg, key, signature, data) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // TODO\n      // validate publicKey\n\n      // verify the signature\n      return normalizedAlgorithm.verify(key, signature, data);\n    }\n\n    /**\n     * Encrypt\n     */\n\n    /**\n     * Decrypt\n     */\n\n    /**\n     * Import\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg);\n      return normalizedAlgorithm.importKey(key);\n    }\n  }]);\n\n  return JWA;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = JWA;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n\n  /**\n   * Escape\n   */\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n\n      return '#/' + value;\n    }\n\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      // iterate through the tokens\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        // set the property on the target location\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          }\n\n          // handle missing target location based on \"mode\"\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          }\n\n          // reference the next object in the path\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      }\n\n      // delete from the target\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n\n/**\n * Exports\n */\n\nmodule.exports = JSONPointer;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * DataError\n */\nvar DataError = function (_Error) {\n  _inherits(DataError, _Error);\n\n  function DataError(message) {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message));\n  }\n\n  return DataError;\n}(Error);\n\n/**\n * Export\n */\n\nmodule.exports = DataError;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * NotSupportedError\n */\nvar NotSupportedError = function (_Error) {\n  _inherits(NotSupportedError, _Error);\n\n  function NotSupportedError(alg) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this.message = alg + \" is not a supported algorithm\";\n    return _this;\n  }\n\n  return NotSupportedError;\n}(Error);\n\n/**\n * Export\n */\n\nmodule.exports = NotSupportedError;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  DataError: __webpack_require__(6),\n  NotSupportedError: __webpack_require__(7)\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _require = __webpack_require__(0),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSchema = __webpack_require__(2);\nvar JWA = __webpack_require__(4\n\n/**\n * JWK Class\n */\n);\nvar JWK = function (_JSONDocument) {\n  _inherits(JWK, _JSONDocument);\n\n  function JWK() {\n    _classCallCheck(this, JWK);\n\n    return _possibleConstructorReturn(this, (JWK.__proto__ || Object.getPrototypeOf(JWK)).apply(this, arguments));\n  }\n\n  _createClass(JWK, null, [{\n    key: 'importKey',\n\n    /**\n     * importKey\n     *\n     * TODO:\n     * - should this be on JWA?\n     */\n    value: function importKey(jwk) {\n      return JWA.importKey(jwk);\n    }\n  }, {\n    key: 'schema',\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return JWKSchema;\n    }\n  }]);\n\n  return JWK;\n}(JSONDocument);\n\n/**\n * Export\n */\n\nmodule.exports = JWK;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;_e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }return _arr;\n  }return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(1);\nvar JWA = __webpack_require__(4);\n\nvar _require = __webpack_require__(8\n\n/**\n * JWS\n */\n),\n    DataError = _require.DataError;\n\nvar JWS = function () {\n  function JWS() {\n    _classCallCheck(this, JWS);\n  }\n\n  _createClass(JWS, null, [{\n    key: 'sign',\n\n    /**\n     * sign\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @param {Object} token\n     * @returns {Promise}\n     */\n    value: function sign(token) {\n      var payload = base64url(JSON.stringify(token.payload\n\n      // compact serialization\n      ));if (token.serialization === 'compact') {\n        var key = token.key,\n            alg = token.header.alg;\n\n        var header = base64url(JSON.stringify(token.header));\n        var data = header + '.' + payload;\n\n        return JWA.sign(alg, key, data).then(function (signature) {\n          return data + '.' + signature;\n        });\n      }\n\n      // JSON serialization\n      if (token.serialization === 'json') {}\n\n      // Flattened serialization\n      if (token.serialization === 'flattened') {}\n\n      return Promise.reject(new DataError('Unsupported serialization'));\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(jwt) {\n      // multiple signatures\n      if (jwt.signatures) {\n        // ...\n      }\n\n      var key = jwt.key,\n          signature = jwt.signature,\n          alg = jwt.header.alg;\n\n      // one signature\n\n      if (jwt.signature) {\n        var _jwt$segments = _slicedToArray(jwt.segments, 2),\n            header = _jwt$segments[0],\n            payload = _jwt$segments[1];\n\n        var data = header + '.' + payload;\n\n        if (alg === 'none') {\n          return Promise.reject(new DataError('Signature provided to verify with alg: none'));\n        }\n\n        return JWA.verify(alg, key, signature, data).then(function (verified) {\n          jwt.verified = verified;\n          return verified;\n        });\n      }\n\n      if (alg === 'none') {\n        if (!key && !signature) {\n          jwt.verified = true;\n\n          return Promise.resolve(true);\n        }\n\n        if (key) {\n          return Promise.reject(new DataError('Key provided to verify signature with alg: none'));\n        }\n      }\n\n      // no signatures to verify\n      return Promise.reject(new DataError('Missing signature(s)'));\n    }\n  }]);\n\n  return JWS;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = JWS;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(0\n\n/**\n * Base64URLSchema\n */\n),\n    JSONSchema = _require.JSONSchema;\n\nvar Base64URLSchema = new JSONSchema({\n  type: 'string',\n  format: 'base64url'\n});\n\n/**\n * Export\n */\nmodule.exports = Base64URLSchema;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar JWKSchema = __webpack_require__(2);\n\nvar _require = __webpack_require__(0\n\n/**\n * JOSEHeaderSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-5\n *\n * 5.  JOSE Header\n *\n *   For a JWT object, the members of the JSON object represented by the\n *   JOSE Header describe the cryptographic operations applied to the JWT\n *   and optionally, additional properties of the JWT.  Depending upon\n *   whether the JWT is a JWS or JWE, the corresponding rules for the JOSE\n *   Header values apply.\n */\n),\n    JSONSchema = _require.JSONSchema;\n\nvar JOSEHeaderSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * typ\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.1\n     *\n     * 5.1.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter defined by [JWS] and [JWE] is used\n     *   by JWT applications to declare the media type [IANA.MediaTypes] of\n     *   this complete JWT.  This is intended for use by the JWT application\n     *   when values that are not JWTs could also be present in an application\n     *   data structure that can contain a JWT object; the application can use\n     *   this value to disambiguate among the different kinds of objects that\n     *   might be present.  It will typically not be used by applications when\n     *   it is already known that the object is a JWT.  This parameter is\n     *   ignored by JWT implementations; any processing of this parameter is\n     *   performed by the JWT application.  If present, it is RECOMMENDED that\n     *   its value be \"JWT\" to indicate that this object is a JWT.  While\n     *   media type names are not case sensitive, it is RECOMMENDED that \"JWT\"\n     *   always be spelled using uppercase characters for compatibility with\n     *   legacy implementations.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.9\n     *\n     * 4.1.9.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter is used by JWS applications to\n     *   declare the media type [IANA.MediaTypes] of this complete JWS.  This\n     *   is intended for use by the application when more than one kind of\n     *   object could be present in an application data structure that can\n     *   contain a JWS; the application can use this value to disambiguate\n     *   among the different kinds of objects that might be present.  It will\n     *   typically not be used by applications when the kind of object is\n     *   already known.  This parameter is ignored by JWS implementations; any\n     *   processing of this parameter is performed by the JWS application.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"typ\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"typ\" value not containing a\n     *   '/'.  For instance, a \"typ\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     *   The \"typ\" value \"JOSE\" can be used by applications to indicate that\n     *   this object is a JWS or JWE using the JWS Compact Serialization or\n     *   the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be\n     *   used by applications to indicate that this object is a JWS or JWE\n     *   using the JWS JSON Serialization or the JWE JSON Serialization.\n     *   Other type values can also be used by applications.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.11\n     *\n     * 4.1.11.  \"typ\" (Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"typ\" Header Parameter defined in Section 4.1.9 of [JWS], except\n     *   that the type is that of this complete JWE.\n     */\n    typ: {\n      type: 'string'\n    },\n\n    /**\n     * cty\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.2\n     *\n     * 5.2.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter defined by [JWS] and [JWE]\n     *   is used by this specification to convey structural information about\n     *   the JWT.\n     *\n     *   In the normal case in which nested signing or encryption operations\n     *   are not employed, the use of this Header Parameter is NOT\n     *   RECOMMENDED.  In the case that nested signing or encryption is\n     *   employed, this Header Parameter MUST be present; in this case, the\n     *   value MUST be \"JWT\", to indicate that a Nested JWT is carried in this\n     *   JWT.  While media type names are not case sensitive, it is\n     *   RECOMMENDED that \"JWT\" always be spelled using uppercase characters\n     *   for compatibility with legacy implementations.  See Appendix A.2 for\n     *   an example of a Nested JWT.\n     *\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.10\n     *\n     * 4.1.10.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter is used by JWS applications\n     *   to declare the media type [IANA.MediaTypes] of the secured content\n     *   (the payload).  This is intended for use by the application when more\n     *   than one kind of object could be present in the JWS Payload; the\n     *   application can use this value to disambiguate among the different\n     *   kinds of objects that might be present.  It will typically not be\n     *   used by applications when the kind of object is already known.  This\n     *   parameter is ignored by JWS implementations; any processing of this\n     *   parameter is performed by the JWS application.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"cty\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"cty\" value not containing a\n     *   '/'.  For instance, a \"cty\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.12\n     *\n     * 4.1.12.  \"cty\" (Content Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"cty\" Header Parameter defined in Section 4.1.10 of [JWS], except\n     *   that the type is that of the secured content (the plaintext).\n     */\n    cty: {\n      type: 'string',\n      enum: ['JWT']\n    },\n\n    /**\n     * alg\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   The \"alg\" (algorithm) Header Parameter identifies the cryptographic\n     *   algorithm used to secure the JWS.  The JWS Signature value is not\n     *   valid if the \"alg\" value does not represent a supported algorithm or\n     *   if there is not a key for use with that algorithm associated with the\n     *   party that digitally signed or MACed the content.  \"alg\" values\n     *   should either be registered in the IANA \"JSON Web Signature and\n     *   Encryption Algorithms\" registry established by [JWA] or be a value\n     *   that contains a Collision-Resistant Name.  The \"alg\" value is a case-\n     *   sensitive ASCII string containing a StringOrURI value.  This Header\n     *   Parameter MUST be present and MUST be understood and processed by\n     *   implementations.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 3.1 of [JWA].\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"alg\" Header Parameter defined in Section 4.1.1 of [JWS], except\n     *   that the Header Parameter identifies the cryptographic algorithm used\n     *   to encrypt or determine the value of the CEK.  The encrypted content\n     *   is not usable if the \"alg\" value does not represent a supported\n     *   algorithm, or if the recipient does not have a key that can be used\n     *   with that algorithm.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 4.1 of [JWA].\n     */\n    alg: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * jku\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.2\n     *\n     * 4.1.2.  \"jku\" (JWK Set URL) Header Parameter (JWS)\n     *\n     *   The \"jku\" (JWK Set URL) Header Parameter is a URI [RFC3986] that\n     *   refers to a resource for a set of JSON-encoded public keys, one of\n     *   which corresponds to the key used to digitally sign the JWS.  The\n     *   keys MUST be encoded as a JWK Set [JWK].  The protocol used to\n     *   acquire the resource MUST provide integrity protection; an HTTP GET\n     *   request to retrieve the JWK Set MUST use Transport Layer Security\n     *   (TLS) [RFC2818] [RFC5246]; and the identity of the server MUST be\n     *   validated, as per Section 6 of RFC 6125 [RFC6125].  Also, see\n     *   Section 8 on TLS requirements.  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.4\n     *\n     * 4.1.4.  \"jku\" (JWK Set URL) Header Parameter (JWE)\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jku\" Header Parameter defined in Section 4.1.2 of [JWS], except\n     *   that the JWK Set resource contains the public key to which the JWE\n     *   was encrypted; this can be used to determine the private key needed\n     *   to decrypt the JWE.\n     */\n    jku: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * jwk\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.3\n     *\n     * 4.1.3.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   The \"jwk\" (JSON Web Key) Header Parameter is the public key that\n     *   corresponds to the key used to digitally sign the JWS.  This key is\n     *   represented as a JSON Web Key [JWK].  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.5\n     *\n     * 4.1.5.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jwk\" Header Parameter defined in Section 4.1.3 of [JWS], except\n     *   that the key is the public key to which the JWE was encrypted; this\n     *   can be used to determine the private key needed to decrypt the JWE.\n     */\n    //jwk: JWKSchema,\n\n    /**\n     * kid\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.4\n     *\n     * 4.1.4.  \"kid\" (Key ID) Header Parameter\n     *\n     *   The \"kid\" (key ID) Header Parameter is a hint indicating which key\n     *   was used to secure the JWS.  This parameter allows originators to\n     *   explicitly signal a change of key to recipients.  The structure of\n     *   the \"kid\" value is unspecified.  Its value MUST be a case-sensitive\n     *   string.  Use of this Header Parameter is OPTIONAL.\n     *\n     *   When used with a JWK, the \"kid\" value is used to match a JWK \"kid\"\n     *   parameter value.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.6\n     *\n     * 4.1.6.  \"kid\" (Key ID) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"kid\" Header Parameter defined in Section 4.1.4 of [JWS], except\n     *   that the key hint references the public key to which the JWE was\n     *   encrypted; this can be used to determine the private key needed to\n     *   decrypt the JWE.  This parameter allows originators to explicitly\n     *   signal a change of key to JWE recipients.\n     */\n    kid: {\n      type: 'string'\n    },\n\n    /**\n     * x5u\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.5\n     *\n     * 4.1.5.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   The \"x5u\" (X.509 URL) Header Parameter is a URI [RFC3986] that refers\n     *   to a resource for the X.509 public key certificate or certificate\n     *   chain [RFC5280] corresponding to the key used to digitally sign the\n     *   JWS.  The identified resource MUST provide a representation of the\n     *   certificate or certificate chain that conforms to RFC 5280 [RFC5280]\n     *   in PEM-encoded form, with each certificate delimited as specified in\n     *   Section 6.1 of RFC 4945 [RFC4945].  The certificate containing the\n     *   public key corresponding to the key used to digitally sign the JWS\n     *   MUST be the first certificate.  This MAY be followed by additional\n     *   certificates, with each subsequent certificate being the one used to\n     *   certify the previous one.  The protocol used to acquire the resource\n     *   MUST provide integrity protection; an HTTP GET request to retrieve\n     *   the certificate MUST use TLS [RFC2818] [RFC5246]; and the identity of\n     *   the server MUST be validated, as per Section 6 of RFC 6125 [RFC6125].\n     *   Also, see Section 8 on TLS requirements.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.7\n     *\n     * 4.1.7.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5u\" Header Parameter defined in Section 4.1.5 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5u: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * x5c\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.6\n     *\n     * 4.1.6.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   The \"x5c\" (X.509 certificate chain) Header Parameter contains the\n     *   X.509 public key certificate or certificate chain [RFC5280]\n     *   corresponding to the key used to digitally sign the JWS.  The\n     *   certificate or certificate chain is represented as a JSON array of\n     *   certificate value strings.  Each string in the array is a\n     *   base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER\n     *   [ITU.X690.2008] PKIX certificate value.  The certificate containing\n     *   the public key corresponding to the key used to digitally sign the\n     *   JWS MUST be the first certificate.  This MAY be followed by\n     *   additional certificates, with each subsequent certificate being the\n     *   one used to certify the previous one.  The recipient MUST validate\n     *   the certificate chain according to RFC 5280 [RFC5280] and consider\n     *   the certificate or certificate chain to be invalid if any validation\n     *   failure occurs.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.8\n     *\n     * 4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5c\" Header Parameter defined in Section 4.1.6 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5c: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'base64'\n      }\n    },\n\n    /**\n     * x5t\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.7\n     *\n     * 4.1.7.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   The \"x5t\" (X.509 certificate SHA-1 thumbprint) Header Parameter is a\n     *   base64url-encoded SHA-1 thumbprint (a.k.a. digest) of the DER\n     *   encoding of the X.509 certificate [RFC5280] corresponding to the key\n     *   used to digitally sign the JWS.  Note that certificate thumbprints\n     *   are also sometimes known as certificate fingerprints.  Use of this\n     *   Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.9\n     *\n     * 4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t\" Header Parameter defined in Section 4.1.7 of [JWS], except\n     *   that the certificate referenced by the thumbprint contains the public\n     *   key to which the JWE was encrypted; this can be used to determine the\n     *   private key needed to decrypt the JWE.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     */\n    x5t: {\n      type: 'string',\n      format: 'base64url'\n    },\n\n    /**\n     * x5t#S256\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.8\n     *\n     * 4.1.8.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *         Parameter\n     *\n     *   The \"x5t#S256\" (X.509 certificate SHA-256 thumbprint) Header\n     *   Parameter is a base64url-encoded SHA-256 thumbprint (a.k.a. digest)\n     *   of the DER encoding of the X.509 certificate [RFC5280] corresponding\n     *   to the key used to digitally sign the JWS.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.10\n     *\n     * 4.1.10.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *          Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t#S256\" Header Parameter defined in Section 4.1.8 of [JWS],\n     *   except that the certificate referenced by the thumbprint contains the\n     *   public key to which the JWE was encrypted; this can be used to\n     *   determine the private key needed to decrypt the JWE.  Note that\n     *   certificate thumbprints are also sometimes known as certificate\n     *   fingerprints.\n     */\n    //'x5t#S256': {\n    //  type: 'string',\n    //  format: 'base64url'\n    //},\n\n    /**\n     * crit\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.11\n     *\n     * 4.1.11.  \"crit\" (Critical) Header Parameter\n     *\n     *   The \"crit\" (critical) Header Parameter indicates that extensions to\n     *   this specification and/or [JWA] are being used that MUST be\n     *   understood and processed.  Its value is an array listing the Header\n     *   Parameter names present in the JOSE Header that use those extensions.\n     *   If any of the listed extension Header Parameters are not understood\n     *   and supported by the recipient, then the JWS is invalid.  Producers\n     *   MUST NOT include Header Parameter names defined by this specification\n     *   or [JWA] for use with JWS, duplicate names, or names that do not\n     *   occur as Header Parameter names within the JOSE Header in the \"crit\"\n     *   list.  Producers MUST NOT use the empty list \"[]\" as the \"crit\"\n     *   value.  Recipients MAY consider the JWS to be invalid if the critical\n     *   list contains any Header Parameter names defined by this\n     *   specification or [JWA] for use with JWS or if any other constraints\n     *   on its use are violated.  When used, this Header Parameter MUST be\n     *   integrity protected; therefore, it MUST occur only within the JWS\n     *   Protected Header.  Use of this Header Parameter is OPTIONAL.  This\n     *   Header Parameter MUST be understood and processed by implementations.\n     *\n     *   An example use, along with a hypothetical \"exp\" (expiration time)\n     *   field is:\n     *\n     *     {\"alg\":\"ES256\",\n     *     \"crit\":[\"exp\"],\n     *     \"exp\":1363284000\n     *     }\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.13\n     *\n     *   4.1.13.  \"crit\" (Critical) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"crit\" Header Parameter defined in Section 4.1.11 of [JWS],\n     *   except that Header Parameters for a JWE are being referred to, rather\n     *   than Header Parameters for a JWS.\n     */\n    crit: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      minItems: 1\n    },\n\n    /**\n     * enc\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.2\n     *\n     * 4.1.2.  \"enc\" (Encryption Algorithm) Header Parameter\n     *\n     *   The \"enc\" (encryption algorithm) Header Parameter identifies the\n     *   content encryption algorithm used to perform authenticated encryption\n     *   on the plaintext to produce the ciphertext and the Authentication\n     *   Tag.  This algorithm MUST be an AEAD algorithm with a specified key\n     *   length.  The encrypted content is not usable if the \"enc\" value does\n     *   not represent a supported algorithm.  \"enc\" values should either be\n     *   registered in the IANA \"JSON Web Signature and Encryption Algorithms\"\n     *   registry established by [JWA] or be a value that contains a\n     *   Collision-Resistant Name.  The \"enc\" value is a case-sensitive ASCII\n     *   string containing a StringOrURI value.  This Header Parameter MUST be\n     *   present and MUST be understood and processed by implementations.\n     *\n     *   A list of defined \"enc\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 5.1 of [JWA].\n     */\n    enc: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * zip\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.3\n     *\n     * 4.1.3.  \"zip\" (Compression Algorithm) Header Parameter\n     *\n     *   The \"zip\" (compression algorithm) applied to the plaintext before\n     *   encryption, if any.  The \"zip\" value defined by this specification\n     *   is:\n     *\n     *   o  \"DEF\" - Compression with the DEFLATE [RFC1951] algorithm\n     *\n     *   Other values MAY be used.  Compression algorithm values can be\n     *   registered in the IANA \"JSON Web Encryption Compression Algorithms\"\n     *   registry established by [JWA].  The \"zip\" value is a case-sensitive\n     *   string.  If no \"zip\" parameter is present, no compression is applied\n     *   to the plaintext before encryption.  When used, this Header Parameter\n     *   MUST be integrity protected; therefore, it MUST occur only within the\n     *   JWE Protected Header.  Use of this Header Parameter is OPTIONAL.\n     *   This Header Parameter MUST be understood and processed by\n     *   implementations.\n     */\n    zip: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JOSEHeaderSchema;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(0),\n    JSONSchema = _require.JSONSchema;\n\nvar JWKSchema = __webpack_require__(2\n\n/**\n * JWKSetSchema\n */\n);var JWKSetSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    keys: {\n      type: 'array',\n      items: JWKSchema\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSetSchema;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(0\n\n/**\n * JWTClaimsSetSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-4\n *\n * 4.  JWT Claims\n *\n *   The JWT Claims Set represents a JSON object whose members are the\n *   claims conveyed by the JWT.  The Claim Names within a JWT Claims Set\n *   MUST be unique; JWT parsers MUST either reject JWTs with duplicate\n *   Claim Names or use a JSON parser that returns only the lexically last\n *   duplicate member name, as specified in Section 15.12 (\"The JSON\n *   Object\") of ECMAScript 5.1 [ECMAScript].\n *\n *   The set of claims that a JWT must contain to be considered valid is\n *   context dependent and is outside the scope of this specification.\n *   Specific applications of JWTs will require implementations to\n *   understand and process some claims in particular ways.  However, in\n *   the absence of such requirements, all claims that are not understood\n *   by implementations MUST be ignored.\n *\n *   There are three classes of JWT Claim Names: Registered Claim Names,\n *   Public Claim Names, and Private Claim Names.\n */\n),\n    JSONSchema = _require.JSONSchema;\n\nvar JWTClaimsSetSchema = new JSONSchema({\n  properties: {\n\n    /**\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1\n     *\n     * 4.1.  Registered Claim Names\n     *\n     *   The following Claim Names are registered in the IANA \"JSON Web Token\n     *   Claims\" registry established by Section 10.1.  None of the claims\n     *   defined below are intended to be mandatory to use or implement in all\n     *   cases, but rather they provide a starting point for a set of useful,\n     *   interoperable claims.  Applications using JWTs should define which\n     *   specific claims they use and when they are required or optional.  All\n     *   the names are short because a core goal of JWTs is for the\n     *   representation to be compact.\n     */\n\n    /**\n     * iss\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.1\n     *\n     * 4.1.1.  \"iss\" (Issuer) Claim\n     *\n     *   The \"iss\" (issuer) claim identifies the principal that issued the\n     *   JWT.  The processing of this claim is generally application specific.\n     *   The \"iss\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    iss: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * sub\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.2\n     *\n     * 4.1.2.  \"sub\" (Subject) Claim\n     *\n     *   The \"sub\" (subject) claim identifies the principal that is the\n     *   subject of the JWT.  The claims in a JWT are normally statements\n     *   about the subject.  The subject value MUST either be scoped to be\n     *   locally unique in the context of the issuer or be globally unique.\n     *   The processing of this claim is generally application specific.  The\n     *   \"sub\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    sub: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * aud\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.3\n     *\n     * 4.1.3.  \"aud\" (Audience) Claim\n     *\n     *   The \"aud\" (audience) claim identifies the recipients that the JWT is\n     *   intended for.  Each principal intended to process the JWT MUST\n     *   identify itself with a value in the audience claim.  If the principal\n     *   processing the claim does not identify itself with a value in the\n     *   \"aud\" claim when this claim is present, then the JWT MUST be\n     *   rejected.  In the general case, the \"aud\" value is an array of case-\n     *   sensitive strings, each containing a StringOrURI value.  In the\n     *   special case when the JWT has one audience, the \"aud\" value MAY be a\n     *   single case-sensitive string containing a StringOrURI value.  The\n     *   interpretation of audience values is generally application specific.\n     *   Use of this claim is OPTIONAL.\n     */\n    aud: {\n      type: ['array', 'string'],\n      format: 'StringOrURI',\n      items: {\n        format: 'StringOrURI'\n      }\n    },\n\n    /**\n     * exp\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.4\n     *\n     * 4.1.4.  \"exp\" (Expiration Time) Claim\n     *\n     *   The \"exp\" (expiration time) claim identifies the expiration time on\n     *   or after which the JWT MUST NOT be accepted for processing.  The\n     *   processing of the \"exp\" claim requires that the current date/time\n     *   MUST be before the expiration date/time listed in the \"exp\" claim.\n     *\n     *   Implementers MAY provide for some small leeway, usually no more than\n     *   a few minutes, to account for clock skew.  Its value MUST be a number\n     *   containing a NumericDate value.  Use of this claim is OPTIONAL.\n     *\n     */\n    exp: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * nbf\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.5\n     *\n     * 4.1.5.  \"nbf\" (Not Before) Claim\n     *\n     *   The \"nbf\" (not before) claim identifies the time before which the JWT\n     *   MUST NOT be accepted for processing.  The processing of the \"nbf\"\n     *   claim requires that the current date/time MUST be after or equal to\n     *   the not-before date/time listed in the \"nbf\" claim.  Implementers MAY\n     *   provide for some small leeway, usually no more than a few minutes, to\n     *   account for clock skew.  Its value MUST be a number containing a\n     *   NumericDate value.  Use of this claim is OPTIONAL.\n     */\n    nbf: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * iat\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.6\n     *\n     * 4.1.6.  \"iat\" (Issued At) Claim\n     *\n     *   The \"iat\" (issued at) claim identifies the time at which the JWT was\n     *   issued.  This claim can be used to determine the age of the JWT.  Its\n     *   value MUST be a number containing a NumericDate value.  Use of this\n     *   claim is OPTIONAL.\n     */\n    iat: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * jti\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.7\n     *\n     * 4.1.7.  \"jti\" (JWT ID) Claim\n     *\n     *   The \"jti\" (JWT ID) claim provides a unique identifier for the JWT.\n     *   The identifier value MUST be assigned in a manner that ensures that\n     *   there is a negligible probability that the same value will be\n     *   accidentally assigned to a different data object; if the application\n     *   uses multiple issuers, collisions MUST be prevented among values\n     *   produced by different issuers as well.  The \"jti\" claim can be used\n     *   to prevent the JWT from being replayed.  The \"jti\" value is a case-\n     *   sensitive string.  Use of this claim is OPTIONAL.\n     */\n    jti: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTClaimsSetSchema;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar Base64URLSchema = __webpack_require__(11);\nvar JWTClaimsSetSchema = __webpack_require__(14);\nvar JOSEHeaderSchema = __webpack_require__(12);\n\nvar _require = __webpack_require__(0\n\n/**\n * JWTSchema\n *\n * @description\n * This schema represents all the things a deserialized JWT can be, i.e.,\n * either a JWS or JWE, and any serialization of them. Validation of well-\n * formedness for a given serialization is accomplished at the time of\n * encoding.\n */\n),\n    JSONSchema = _require.JSONSchema;\n\nvar JWTSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * type\n     */\n    type: {\n      type: 'string',\n      enum: ['JWS', 'JWE']\n    },\n\n    /**\n     * segments\n     */\n    segments: {\n      type: 'array'\n    },\n\n    /**\n     * header\n     */\n    header: JOSEHeaderSchema,\n\n    /**\n     * protected\n     */\n    protected: JOSEHeaderSchema,\n\n    /**\n     * unprotected\n     */\n    unprotected: JOSEHeaderSchema,\n\n    /**\n     * iv\n     */\n    iv: Base64URLSchema,\n\n    /**\n     * aad\n     */\n    aad: Base64URLSchema,\n\n    /**\n     * ciphertext\n     */\n    ciphertext: Base64URLSchema,\n\n    /**\n     * tag\n     */\n    tag: Base64URLSchema,\n\n    /**\n     * recipients\n     */\n    recipients: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          header: JOSEHeaderSchema,\n          encrypted_key: Base64URLSchema\n        }\n      }\n    },\n\n    /**\n     * payload\n     */\n    payload: JWTClaimsSetSchema,\n\n    /**\n     * signatures\n     */\n    signatures: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          protected: JOSEHeaderSchema,\n          header: JOSEHeaderSchema,\n          signature: Base64URLSchema,\n          key: { type: 'object' }\n        }\n      }\n    },\n\n    /**\n     * signature\n     */\n    signature: Base64URLSchema,\n\n    /**\n     * verified\n     */\n    verified: {\n      type: 'boolean',\n      default: false\n    },\n\n    /**\n     * key\n     */\n    key: {\n      type: 'object'\n    },\n\n    /**\n     * serialization\n     */\n    serialization: {\n      type: 'string',\n      enum: ['compact', 'json', 'flattened'],\n      default: 'compact'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTSchema;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar TextEncoder = global.TextEncoder ? global.TextEncoder // browser\n: __webpack_require__(40).TextEncoder; // node shim\nmodule.exports = TextEncoder;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * JSON Schema Formats\n *\n * TODO\n * Is there a good way to express these over multiple lines with comments\n * for easier debugging and auditing?\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\nvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\nvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\nvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\nvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\n/**\n * Formats\n */\n\nvar Formats = function () {\n  function Formats() {\n    _classCallCheck(this, Formats);\n  }\n\n  _createClass(Formats, [{\n    key: 'register',\n\n    /**\n     * Register\n     *\n     * @description\n     * Register a new mapping from named format to RegExp instance\n     *\n     * TODO\n     * We can do some extra validation of the RegExp to\n     * ensure it's the acceptable subset of RegExps allowed\n     * by JSON Schema.\n     *\n     * @param {string} name\n     * @param {RegExp} pattern\n     * @returns {RegExp}\n     */\n    value: function register(name, pattern) {\n      // verify name is a string\n      if (typeof name !== 'string') {\n        throw new Error('Format name must be a string');\n      }\n\n      // cast a string to RegExp\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n      }\n\n      return this[name] = pattern;\n    }\n\n    /**\n     * Resolve\n     *\n     * @description\n     * Given a format name, return the corresponding registered validation. In the\n     * event a format is not registered, throw an error.\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(name) {\n      var format = this[name];\n\n      if (!format) {\n        throw new Error('Unknown JSON Schema format.');\n      }\n\n      return format;\n    }\n\n    /**\n     * Test\n     *\n     * @description\n     * Test that a value conforms to a format.\n     *\n     * @param {string} name\n     * @param {string} value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(name, value) {\n      var format = this.resolve(name);\n      return format.test(value);\n    }\n  }], [{\n    key: 'initialize',\n\n    /**\n     * Initialize\n     *\n     * @description\n     * Create a new Formats instance and register default formats\n     *\n     * @returns {Formats}\n     */\n    value: function initialize() {\n      var formats = new Formats();\n      formats.register('date-time', DATETIME_REGEXP);\n      formats.register('uri', URI_REGEXP);\n      formats.register('email', EMAIL_REGEXP);\n      formats.register('ipv4', IPV4_REGEXP);\n      formats.register('ipv6', IPV6_REGEXP);\n      formats.register('hostname', HOSTNAME_REGEXP);\n      return formats;\n    }\n  }]);\n\n  return Formats;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = Formats.initialize();\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Initializer\n */\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Initializer = function () {\n\n  /**\n   * constructor\n   */\n  function Initializer(schema, options) {\n    _classCallCheck(this, Initializer);\n\n    Object.assign(this, options || {});\n    this.root = this.root || this;\n\n    this.root.depth = this.root.depth || 1;\n\n    if (this.level > this.root.depth) {\n      this.root.depth = this.level;\n    }\n\n    this.level = this.level || 0;\n    this.schema = schema;\n  }\n\n  /**\n   * compile (static)\n   */\n\n  _createClass(Initializer, [{\n    key: 'compile',\n\n    /**\n     * compile\n     */\n    value: function compile() {\n      var root = this.root,\n          depth = this.depth,\n          level = this.level;\n\n      var declarations = '';\n      var body = '';\n\n      // traverse the schema and generate code\n      body += this.default();\n      body += this.properties();\n      //body += this.additionalProperties()\n      body += this.items();\n      //body += this.additionalItems()\n\n\n      // value\n      body += this.member();\n      body += this.item();\n\n      // after traversing the schema\n      // generate the variable declarations\n      if (root === this) {\n        for (var i = 1; i <= this.root.depth; i++) {\n          declarations += this.declaration(i);\n        }\n\n        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n      }\n\n      return body;\n    }\n\n    /**\n     * declaration\n     */\n\n  }, {\n    key: 'declaration',\n    value: function declaration(level) {\n      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n    }\n\n    /**\n     * default\n     */\n\n  }, {\n    key: 'default',\n    value: function _default() {\n      var schema = this.schema,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\n      var block = '';\n\n      if (schema.hasOwnProperty('default')) {\n\n        if (key) {\n          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (index) {\n          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * member\n     */\n\n  }, {\n    key: 'member',\n    value: function member() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      // `key` tells us to treat this subschema as an object member vs an array item\n      // and the absence of the other values here indicates we are dealing with a\n      // primitive value\n      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\n        // first generate the assignment statement\n        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\n        // for nested container objects, add the counter incrementing statement\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        // wrap the foregoing in a check for presence on the source\n        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * item\n     */\n\n  }, {\n    key: 'item',\n    value: function item() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          index = this.index;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\n        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var properties = schema.properties;\n\n      var block = '';\n\n      if (properties) {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\n          block += initializer.compile();\n        });\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n\n          if (index) {\n            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n          }\n\n          if (key) {\n            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n          }\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {}\n\n    /**\n     * items\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var items = schema.items;\n\n      var block = '';\n\n      if (items) {\n\n        if (Array.isArray(items)) {\n          // TODO\n          //\n          //\n          //\n          //\n          //\n          // ...\n\n        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n          var _index = 'i' + (level + 1);\n          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\n          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n        }\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {}\n  }], [{\n    key: 'compile',\n    value: function compile(schema) {\n      var initializer = new Initializer(schema);\n      var block = initializer.compile();\n\n      //console.log(beautify(block))\n      try {\n        return new Function('target', 'source', 'options', block);\n      } catch (e) {\n        console.log(e, e.stack);\n      }\n    }\n  }]);\n\n  return Initializer;\n}();\n\nmodule.exports = Initializer;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JSONPointer = __webpack_require__(5);\n\n/**\n * Modes\n */\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * Operations list\n */\nvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\n/**\n * Patch\n *\n * @class\n * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n * https://tools.ietf.org/html/rfc6902\n */\n\nvar JSONPatch = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Array} ops\n   */\n  function JSONPatch(ops) {\n    _classCallCheck(this, JSONPatch);\n\n    this.ops = ops || [];\n  }\n\n  /**\n   * Apply\n   *\n   * @todo handle errors/roll back\n   * @todo protect properties that are private in the schema\n   * @todo map JSON Pointers real property names\n   *\n   * @param {Object} target\n   */\n\n  _createClass(JSONPatch, [{\n    key: 'apply',\n    value: function apply(target) {\n      var _this = this;\n\n      this.ops.forEach(function (operation) {\n        var op = operation.op;\n\n        if (!op) {\n          throw new Error('Missing \"op\" in JSON Patch operation');\n        }\n\n        if (OPERATIONS.indexOf(op) === -1) {\n          throw new Error('Invalid \"op\" in JSON Patch operation');\n        }\n\n        if (!operation.path) {\n          throw new Error('Missing \"path\" in JSON Patch operation');\n        }\n\n        _this[op](operation, target);\n      });\n    }\n\n    /**\n     * Add\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'add',\n    value: function add(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch add operation');\n      }\n\n      var pointer = new JSONPointer(op.path, SILENT);\n      pointer.add(target, op.value);\n    }\n\n    /**\n     * Remove\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(op, target) {\n      var pointer = new JSONPointer(op.path);\n      pointer.remove(target);\n    }\n\n    /**\n     * Replace\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch replace operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      pointer.replace(target, op.value);\n    }\n\n    /**\n     * Move\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'move',\n    value: function move(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch move operation');\n      }\n\n      if (op.path.match(new RegExp('^' + op.from))) {\n        throw new Error('Invalid \"from\" in JSON Patch move operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      from.remove(target);\n      pointer.add(target, value);\n    }\n\n    /**\n     * Copy\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch copy operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      pointer.add(target, value);\n    }\n\n    /**\n     * Test\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'test',\n    value: function test(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch test operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var value = pointer.get(target);\n\n      switch (_typeof(op.value)) {\n        //case 'string':\n        //case 'number':\n        //case 'boolean':\n        //  if (value !== op.value) {\n        //    throw new Error('Mismatching JSON Patch test value')\n        //  }\n        default:\n          if (value !== op.value) {\n            throw new Error('Mismatching JSON Patch test value');\n          }\n      }\n    }\n  }]);\n\n  return JSONPatch;\n}();\n\n/**\n * Exports\n */\n\nmodule.exports = JSONPatch;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar formats = __webpack_require__(17);\n\n/**\n * For variable iterator counter\n *\n * @type {number}\n */\nvar indexCount = 0;\n\n/**\n * Validator\n *\n * Compile an object describing a JSON Schema into a validation function.\n */\n\nvar Validator = function () {\n  _createClass(Validator, null, [{\n    key: 'compile',\n\n    /**\n     * Compile (static)\n     *\n     * @description\n     * Compile an object describing a JSON Schema into a validation function.\n     *\n     * @param {Object} schema\n     * @returns {Function}\n     */\n    value: function compile(schema) {\n      var validator = new Validator(schema);\n\n      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\n      return new Function('data', body);\n    }\n\n    /**\n     * Return current iterator index counter and increase value\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'counter',\n    get: function get() {\n      return indexCount++;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} schema - object representation of a schema\n     * @param {string} options - compilation options\n     */\n\n  }]);\n\n  function Validator(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Validator);\n\n    // assign schema to this\n    this.schema = schema;\n\n    // assign all options to this\n    Object.assign(this, options);\n\n    // ensure address is defined\n    if (!this.address) {\n      this.address = '';\n    }\n\n    // ensure require is boolean\n    if (this.require !== true) {\n      this.require = false;\n    }\n  }\n\n  /**\n   * Compile\n   *\n   * @description\n   * The instance compile method is \"dumb\". It only sequences invocation of\n   * more specific compilation methods. It generates code to\n   *\n   *  - read a value from input\n   *  - validate type(s) of input\n   *  - validate constraints described by various schema keywords\n   *\n   * Conditional logic related to code generation is pushed downsteam to\n   * type-specific methods.\n   */\n\n  _createClass(Validator, [{\n    key: 'compile',\n    value: function compile() {\n      var block = '';\n\n      if (this.require) {\n        block += this.required();\n      }\n\n      // type validation\n      block += this.type();\n\n      // type specific validation generators\n      // null and boolean are covered by this.type()\n      // integer should be covered by number and this.type()\n      block += this.array();\n      block += this.number();\n      block += this.object();\n      block += this.string();\n\n      // non-type-specific validation generators\n      block += this.enum();\n      block += this.anyOf();\n      block += this.allOf();\n      block += this.not();\n      block += this.oneOf();\n\n      return block;\n    }\n\n    /**\n     * push\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n    }\n\n    /**\n     * pop\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n    }\n\n    /**\n     * type\n     *\n     * @description\n     * > An instance matches successfully if its primitive type is one of the\n     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n     * > JSON Schema Validation Section 5.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'type',\n    value: function type() {\n      var type = this.schema.type,\n          address = this.address;\n\n      var block = '';\n\n      if (type) {\n        var types = Array.isArray(type) ? type : [type];\n        var conditions = types.map(function (type) {\n          // TODO: can we make a mapping object for this to clean it up?\n          if (type === 'array') return '!Array.isArray(value)';\n          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n          if (type === 'integer') return '!Number.isInteger(value)';\n          if (type === 'null') return 'value !== null';\n          if (type === 'number') return 'typeof value !== \\'number\\'';\n          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n          if (type === 'string') return 'typeof value !== \\'string\\'';\n        }).join(' && ');\n\n        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Type-specific validations\n     *\n     * Type checking is optional in JSON Schema, and a schema can allow\n     * multiple types. Generated code needs to apply type-specific validations\n     * only to appropriate values, and ignore everything else. Type validation\n     * itself is handled separately from other validation keywords.\n     *\n     * The methods `array`, `number`, `object`, `string` generate type-specific\n     * validation code blocks, wrapped in a conditional such that they will\n     * only be applied to values of that type.\n     *\n     * For example, the `number` method, given the schema\n     *\n     *     { minimum: 3 }\n     *\n     * will generate\n     *\n     *     if (typeof value === 'number') {\n     *       if (value < 3) {\n     *         valid = false\n     *         errors.push({ message: '...' })\n     *       }\n     *     }\n     *\n     * Integer values are also numbers, and are validated the same as numbers\n     * other than the type validation itself. Therefore no `integer` method is\n     * needed.\n     */\n\n    /**\n     * array\n     *\n     * @description\n     * Invoke methods for array-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to array values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'array',\n    value: function array() {\n      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * number\n     *\n     * @description\n     * Invoke methods for number-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to number values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'number',\n    value: function number() {\n      var keywords = ['minimum', 'maximum', 'multipleOf'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * object\n     *\n     * @description\n     * Invoke methods for object-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to object values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'object',\n    value: function object() {\n      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * string\n     *\n     * @description\n     * Invoke methods for string-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to string values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * validations\n     *\n     * @description\n     * Iterate over an array of keywords and invoke code generator methods\n     * for each. Concatenate the results together and return. Used by \"type\"\n     * methods such as this.array() and this.string()\n     *\n     * @param {Array} keywords\n     * @returns {string}\n     */\n\n  }, {\n    key: 'validations',\n    value: function validations(keywords) {\n      var _this = this;\n\n      var schema = this.schema;\n\n      var block = '';\n\n      var constraints = Object.keys(schema).filter(function (key) {\n        return keywords.indexOf(key) !== -1;\n      });\n\n      constraints.forEach(function (keyword) {\n        block += _this[keyword]();\n      });\n\n      return block;\n    }\n\n    /**\n     * enum\n     *\n     * @description\n     * > An instance validates successfully against this keyword if its value\n     * > is equal to one of the elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.5.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'enum',\n    value: function _enum() {\n      var enumerated = this.schema.enum,\n          address = this.address;\n\n      var conditions = ['value !== undefined'];\n      var block = '';\n\n      if (enumerated) {\n        enumerated.forEach(function (value) {\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'number':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'string':\n              conditions.push('value !== \"' + value + '\"');\n              break;\n\n            case 'object':\n              if (value === null) {\n                conditions.push('value !== null');\n              } else {\n                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n              }\n              break;\n\n            default:\n              throw new Error('Things are not well in the land of enum');\n\n          }\n        });\n\n        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * anyOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against at least one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.4\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'anyOf',\n    value: function anyOf() {\n      var anyOf = this.schema.anyOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(anyOf)) {\n        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\n        anyOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n        });\n\n        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * allOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against all schemas defined by this keyword's\n     * > value.\n     * > JSON Schema Validation Section 5.5.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'allOf',\n    value: function allOf() {\n      var allOf = this.schema.allOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(allOf)) {\n        allOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        ' + validator.compile() + '\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * oneOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against exactly one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.5\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      var oneOf = this.schema.oneOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(oneOf)) {\n        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\n        oneOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n        });\n\n        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * not\n     *\n     * @description\n     * > An instance is valid against this keyword if it fails to validate\n     * > successfully against the schema defined by this keyword.\n     * > JSON Schema Validation Section 5.5.6\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'not',\n    value: function not() {\n      var not = this.schema.not,\n          address = this.address;\n\n      var block = '';\n\n      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n        var subschema = not;\n        var validator = new Validator(subschema, { address: address });\n\n        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     *\n     * @description\n     * Iterate over the `properties` schema property if it is an object. For each\n     * key, initialize a new Validator for the subschema represented by the property\n     * value and invoke compile. Append the result of compiling each subschema to\n     * the block of code being generated.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          address = this.address;\n      var properties = schema.properties,\n          required = schema.required;\n\n      var block = this.push();\n\n      // ensure the value of \"required\" schema property is an array\n      required = Array.isArray(required) ? required : [];\n\n      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var isRequired = required.indexOf(key) !== -1;\n          // TODO\n          // how should we be calculating these things? should be json pointer?\n          // needs a separate function\n          var pointer = [address, key].filter(function (segment) {\n            return !!segment;\n          }).join('.');\n          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\n          // read the value\n          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\n          block += validation.compile();\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Other Properties\n     *\n     * @description\n     * This method is not for a keyword. It wraps validations for\n     * patternProperties and additionalProperties in a single iteration over\n     * an object-type value's properties.\n     *\n     * It should only be invoked once for a given subschema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'otherProperties',\n    value: function otherProperties() {\n      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n    }\n\n    /**\n     * Pattern Validations\n     *\n     * @description\n     * Generate validation code from a subschema for properties matching a\n     * regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternValidations',\n    value: function patternValidations() {\n      var patternProperties = this.schema.patternProperties;\n\n      var block = '';\n\n      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n        Object.keys(patternProperties).forEach(function (pattern) {\n          var subschema = patternProperties[pattern];\n          var validator = new Validator(subschema);\n          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * Additional Validations\n     *\n     * @description\n     * Generate validation code, either from a subschema for properties not\n     * defined in the schema, or to disallow properties not defined in the\n     * schema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalValidations',\n    value: function additionalValidations() {\n      var _schema = this.schema,\n          properties = _schema.properties,\n          additionalProperties = _schema.additionalProperties,\n          address = this.address;\n\n      var validations = '';\n      var block = '';\n\n      // catch additional unmatched properties\n      var conditions = ['matched !== true'];\n\n      // ignore defined properties\n      Object.keys(properties || {}).forEach(function (key) {\n        conditions.push('key !== \\'' + key + '\\'');\n      });\n\n      // validate additional properties\n      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n        var subschema = additionalProperties;\n        var validator = new Validator(subschema, { address: address + '[APKey]' });\n        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n      }\n\n      // error for additional properties\n      if (additionalProperties === false) {\n        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * patternProperties\n     *\n     * @description\n     * Generate validation code for properties matching a pattern\n     * defined by the property name (key), which must be a string\n     * representing a valid regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternProperties',\n    value: function patternProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * additionalProperties\n     *\n     * @description\n     * Generate validation code for additional properties not defined\n     * in the schema, or disallow additional properties if the value of\n     * `additionalProperties` in the schema is `false`.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * minProperties\n     *\n     * @description\n     * > An object instance is valid against \"minProperties\" if its number of\n     * > properties is greater than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minProperties',\n    value: function minProperties() {\n      var minProperties = this.schema.minProperties,\n          address = this.address;\n\n      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxProperties\n     *\n     * @description\n     * > An object instance is valid against \"maxProperties\" if its number of\n     * > properties is less than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxProperties',\n    value: function maxProperties() {\n      var maxProperties = this.schema.maxProperties,\n          address = this.address;\n\n      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Dependencies\n     *\n     * @description\n     * > For all (name, schema) pair of schema dependencies, if the instance has\n     * > a property by this name, then it must also validate successfully against\n     * > the schema.\n     * >\n     * > Note that this is the instance itself which must validate successfully,\n     * > not the value associated with the property name.\n     * >\n     * > For each (name, propertyset) pair of property dependencies, if the\n     * > instance has a property by this name, then it must also have properties\n     * > with the same names as propertyset.\n     * > JSON Schema Validation Section 5.4.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'dependencies',\n    value: function dependencies() {\n      var dependencies = this.schema.dependencies,\n          address = this.address;\n\n      var block = this.push();\n\n      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n        Object.keys(dependencies).forEach(function (key) {\n          var dependency = dependencies[key];\n          var conditions = [];\n\n          if (Array.isArray(dependency)) {\n            dependency.forEach(function (item) {\n              conditions.push('container[\\'' + item + '\\'] === undefined');\n            });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n            var subschema = dependency;\n            var validator = new Validator(subschema, { address: address });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n          }\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Required\n     *\n     * @description\n     * > An object instance is valid against this keyword if its property set\n     * > contains all elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.4.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'required',\n    value: function required() {\n      var properties = this.schema.properties,\n          address = this.address;\n\n      var block = '';\n\n      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\n      return block;\n    }\n\n    /**\n     * additionalItems\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {\n      var _schema2 = this.schema,\n          items = _schema2.items,\n          additionalItems = _schema2.additionalItems,\n          address = this.address;\n\n      var block = '';\n\n      if (additionalItems === false && Array.isArray(items)) {\n        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n      }\n\n      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n        var subschema = additionalItems;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Items\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * Code to generate\n     *\n     *     // this outer conditional is generated by this.array()\n     *     if (Array.isArray(value) {\n     *       let parent = value\n     *       for (let i = 0; i < parent.length; i++) {\n     *         value = parent[i]\n     *         // other validation code depending on value here\n     *       }\n     *       value = parent\n     *     }\n     *\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var items = this.schema.items,\n          address = this.address;\n\n      var block = '';\n\n      // if items is an array\n      if (Array.isArray(items)) {\n        block += this.push();\n\n        items.forEach(function (item, index) {\n          var subschema = item;\n          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\n          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n        });\n\n        block += this.pop();\n\n        // if items is an object\n      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n        var subschema = items;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minItems\n     *\n     * @description\n     * > An array instance is valid against \"minItems\" if its size is greater\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minItems',\n    value: function minItems() {\n      var minItems = this.schema.minItems,\n          address = this.address;\n\n      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxItems\n     *\n     * @description\n     * > An array instance is valid against \"maxItems\" if its size is less\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxItems',\n    value: function maxItems() {\n      var maxItems = this.schema.maxItems,\n          address = this.address;\n\n      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * uniqueItems\n     *\n     * @description\n     * > If this keyword has boolean value false, the instance validates\n     * > successfully. If it has boolean value true, the instance validates\n     * > successfully if all of its elements are unique.\n     * > JSON Schema Validation Section 5.3.4\n     *\n     * TODO\n     * optimize\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'uniqueItems',\n    value: function uniqueItems() {\n      var uniqueItems = this.schema.uniqueItems,\n          address = this.address;\n\n      var block = '';\n\n      if (uniqueItems === true) {\n        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is\n     * > greater than, or equal to, the value of this keyword. The length of\n     * > a string instance is defined as the number of its characters as\n     * > defined by RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength() {\n      var minLength = this.schema.minLength,\n          address = this.address;\n\n      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is less\n     * > than, or equal to, the value of this keyword. The length of a string\n     * > instance is defined as the number of its characters as defined by\n     * > RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxLength',\n    value: function maxLength() {\n      var maxLength = this.schema.maxLength,\n          address = this.address;\n\n      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Pattern\n     *\n     * @description\n     * > A string instance is considered valid if the regular expression\n     * > matches the instance successfully.\n     * > JSON Schema Validation Section 5.2.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      var pattern = this.schema.pattern,\n          address = this.address;\n\n      if (pattern) {\n        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n      }\n    }\n\n    /**\n     * Format\n     *\n     * @description\n     * > Structural validation alone may be insufficient to validate that\n     * > an instance meets all the requirements of an application. The\n     * > \"format\" keyword is defined to allow interoperable semantic\n     * > validation for a fixed subset of values which are accurately\n     * > described by authoritative resources, be they RFCs or other\n     * > external specifications.\n     * > JSON Schema Validation Section 7.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'format',\n    value: function format() {\n      var format = this.schema.format,\n          address = this.address;\n\n      var matcher = formats.resolve(format);\n\n      if (matcher) {\n        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n      }\n    }\n\n    /**\n     * Minimum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is greater\n     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n     * > present and has boolean value true, the instance is valid if it is\n     * > strictly greater than the value of \"minimum\".\n     * > JSON Schema Validation Section 5.1.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      var _schema3 = this.schema,\n          minimum = _schema3.minimum,\n          exclusiveMinimum = _schema3.exclusiveMinimum,\n          address = this.address;\n\n      var operator = exclusiveMinimum === true ? '<=' : '<';\n\n      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Maximum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is lower than,\n     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n     * > boolean value true, the instance is valid if it is strictly lower\n     * > than the value of \"maximum\".\n     * > JSON Schema Validation Section 5.1.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      var _schema4 = this.schema,\n          maximum = _schema4.maximum,\n          exclusiveMaximum = _schema4.exclusiveMaximum,\n          address = this.address;\n\n      var operator = exclusiveMaximum === true ? '>=' : '>';\n\n      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * multipleOf\n     *\n     * @description\n     * > A numeric instance is valid against \"multipleOf\" if the result of\n     * > the division of the instance by this keyword's value is an integer.\n     * > JSON Schema Validation Section 5.1.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'multipleOf',\n    value: function multipleOf() {\n      var multipleOf = this.schema.multipleOf;\n\n      var block = '';\n\n      if (typeof multipleOf === 'number') {\n        var length = multipleOf.toString().length;\n        var decimals = length - multipleOf.toFixed(0).length - 1;\n        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n        var condition = void 0;\n\n        if (decimals > 0) {\n          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n        } else {\n          condition = 'value % ' + multipleOf + ' !== 0';\n        }\n\n        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n  }]);\n\n  return Validator;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = Validator;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nmodule.exports = crypto;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\n\nvar JWA = __webpack_require__(4);\nvar JWK = __webpack_require__(9);\nvar JWKSet = __webpack_require__(30);\nvar JWT = __webpack_require__(31);\nvar JWS = __webpack_require__(10);\nvar Base64URLSchema = __webpack_require__(11);\nvar JOSEHeaderSchema = __webpack_require__(12);\nvar JWKSchema = __webpack_require__(2);\nvar JWKSetSchema = __webpack_require__(13);\nvar JWTClaimsSetSchema = __webpack_require__(14);\nvar JWTSchema = __webpack_require__(15\n\n/**\n * Export\n */\n);module.exports = {\n  JWA: JWA,\n  JWK: JWK,\n  JWKSet: JWKSet,\n  JWT: JWT,\n  JWS: JWS,\n  Base64URLSchema: Base64URLSchema,\n  JOSEHeaderSchema: JOSEHeaderSchema,\n  JWKSchema: JWKSchema,\n  JWKSetSchema: JWKSetSchema,\n  JWTClaimsSetSchema: JWTClaimsSetSchema,\n  JWTSchema: JWTSchema\n};\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar base64url = __webpack_require__(1);\nvar crypto = __webpack_require__(22);\nvar TextEncoder = __webpack_require__(16\n\n/**\n * HMAC with SHA-2 Functions\n */\n);\nvar HMAC = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  function HMAC(params) {\n    _classCallCheck(this, HMAC);\n\n    this.params = params;\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO: validate key length\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {string} signature\n     * @param {string} data\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * Assert Sufficient Key Length\n     *\n     * @description Assert that the key length is sufficient\n     * @param {string} key\n     */\n\n  }, {\n    key: 'assertSufficientKeyLength',\n    value: function assertSufficientKeyLength(key) {\n      if (key.length < this.bitlength) {\n        throw new Error('The key is too short.');\n      }\n    }\n  }]);\n\n  return HMAC;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = HMAC;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * None\n */\nvar None = function () {\n  function None() {\n    _classCallCheck(this, None);\n  }\n\n  _createClass(None, [{\n    key: 'sign',\n\n    /**\n     * sign\n     */\n    value: function sign() {\n      return Promise.resolve('');\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      // this will never get called. but you looked.\n    }\n  }]);\n\n  return None;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = None;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar base64url = __webpack_require__(1);\nvar crypto = __webpack_require__(22);\nvar TextEncoder = __webpack_require__(16\n\n/**\n * RSASSA-PKCS1-v1_5\n */\n);\nvar RSASSA_PKCS1_v1_5 = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function RSASSA_PKCS1_v1_5(params) {\n    _classCallCheck(this, RSASSA_PKCS1_v1_5);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n  _createClass(RSASSA_PKCS1_v1_5, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO\n      //if (!this.sufficientKeySize()) {\n      //  return Promise.reject(\n      //    new Error(\n      //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n      //    )\n      //  )\n      //}\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return RSASSA_PKCS1_v1_5;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = RSASSA_PKCS1_v1_5;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Dependencies\n */\nvar NotSupportedError = __webpack_require__(7\n\n/**\n * Operations\n */\n);var operations = ['sign', 'verify', 'encrypt', 'decrypt', 'importKey'];\n\n/**\n * SupportedAlgorithms\n */\n\nvar SupportedAlgorithms = function () {\n\n  /**\n   * constructor\n   */\n  function SupportedAlgorithms() {\n    var _this = this;\n\n    _classCallCheck(this, SupportedAlgorithms);\n\n    operations.forEach(function (op) {\n      _this[op] = {};\n    });\n  }\n\n  /**\n   * Supported Operations\n   */\n\n  _createClass(SupportedAlgorithms, [{\n    key: 'define',\n\n    /**\n     * define\n     *\n     * @description\n     * Register Web Crypto API algorithm parameter for an algorithm\n     * and operation.\n     *\n     * @param {string} alg\n     * @param {string} op\n     * @param {Object} argument\n     */\n    value: function define(alg, op, argument) {\n      var registeredAlgorithms = this[op];\n      registeredAlgorithms[alg] = argument;\n    }\n\n    /**\n     * normalize\n     *\n     * @description\n     * Map JWA alg name to Web Crypto API algorithm parameter\n     *\n     * @param {string} op\n     * @param {Object} alg\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(op, alg) {\n      var registeredAlgorithms = this[op];\n\n      if (!registeredAlgorithms) {\n        return new SyntaxError(); // what kind of error should this be?\n      }\n\n      var argument = registeredAlgorithms[alg];\n\n      if (!argument) {\n        return new NotSupportedError(alg);\n      }\n\n      return argument;\n    }\n  }], [{\n    key: 'operations',\n    get: function get() {\n      return operations;\n    }\n  }]);\n\n  return SupportedAlgorithms;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = SupportedAlgorithms;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Local dependencies\n */\n\nvar None = __webpack_require__(25);\nvar HMAC = __webpack_require__(24);\nvar RSASSA_PKCS1_v1_5 = __webpack_require__(26);\nvar SupportedAlgorithms = __webpack_require__(27\n\n/**\n * Register Supported Algorithms\n */\n);var supportedAlgorithms = new SupportedAlgorithms();\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n})\n//supportedAlgorithms.define('ES256', 'sign', {})\n//supportedAlgorithms.define('ES384', 'sign', {})\n//supportedAlgorithms.define('ES512', 'sign', {})\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\n\n);supportedAlgorithms.define('none', 'sign', new None({\n  // nothing goes here\n})\n\n/**\n * Verify\n */\n);supportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n})\n//supportedAlgorithms.define('ES256', 'verify', {})\n//supportedAlgorithms.define('ES384', 'verify', {})\n//supportedAlgorithms.define('ES512', 'verify', {})\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\n\n);supportedAlgorithms.define('none', 'verify', new None({\n  // nothing goes here\n}));\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n})\n\n/**\n * Export\n */\n);module.exports = supportedAlgorithms;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Package dependencies\n */\n\nvar _require = __webpack_require__(0\n\n/**\n * Format extensions\n */\n),\n    Formats = _require.Formats;\n\nFormats.register('StringOrURI', new RegExp());\nFormats.register('NumericDate', new RegExp());\nFormats.register('URI', new RegExp());\nFormats.register('url', new RegExp());\nFormats.register('base64', new RegExp());\nFormats.register('base64url', new RegExp());\nFormats.register('MediaType', new RegExp());\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _require = __webpack_require__(0),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSetSchema = __webpack_require__(13);\nvar JWK = __webpack_require__(9\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\n);\nvar JWKSet = function (_JSONDocument) {\n  _inherits(JWKSet, _JSONDocument);\n\n  function JWKSet() {\n    _classCallCheck(this, JWKSet);\n\n    return _possibleConstructorReturn(this, (JWKSet.__proto__ || Object.getPrototypeOf(JWKSet)).apply(this, arguments));\n  }\n\n  _createClass(JWKSet, null, [{\n    key: 'importKeys',\n\n    /**\n     * importKeys\n     */\n    value: function importKeys(jwks) {\n      var validation = this.schema.validate(jwks);\n\n      if (!validation.valid) {\n        return Promise.reject(new Error('Invalid JWKSet: ' + JSON.stringify(validation, null, 2)));\n      }\n\n      if (!jwks.keys) {\n        return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'));\n      }\n\n      var imported = void 0,\n          importing = void 0;\n\n      try {\n        imported = new JWKSet(jwks);\n        importing = jwks.keys.map(function (key) {\n          return JWK.importKey(key);\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n\n      return Promise.all(importing).then(function (keys) {\n        imported.keys = keys;\n        return imported;\n      });\n    }\n  }, {\n    key: 'schema',\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWKSetSchema;\n    }\n  }]);\n\n  return JWKSet;\n}(JSONDocument);\n\n/**\n * Export\n */\n\nmodule.exports = JWKSet;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof2(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof2(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(1);\n\nvar _require = __webpack_require__(0),\n    JSONDocument = _require.JSONDocument;\n\nvar JWTSchema = __webpack_require__(15);\nvar JWS = __webpack_require__(10);\nvar DataError = __webpack_require__(6\n\n/**\n * JWT\n */\n);\nvar JWT = function (_JSONDocument) {\n  _inherits(JWT, _JSONDocument);\n\n  function JWT() {\n    _classCallCheck(this, JWT);\n\n    return _possibleConstructorReturn(this, (JWT.__proto__ || Object.getPrototypeOf(JWT)).apply(this, arguments));\n  }\n\n  _createClass(JWT, [{\n    key: 'isJWE',\n\n    /**\n     * isJWE\n     */\n    value: function isJWE() {\n      return !!this.header.enc;\n    }\n\n    /**\n     * resolveKeys\n     */\n\n  }, {\n    key: 'resolveKeys',\n    value: function resolveKeys(jwks) {\n      var kid = this.header.kid;\n      var keys = void 0,\n          match = void 0;\n\n      // treat an array as the \"keys\" property of a JWK Set\n      if (Array.isArray(jwks)) {\n        keys = jwks;\n      }\n\n      // presence of keys indicates object is a JWK Set\n      if (jwks.keys) {\n        keys = jwks.keys;\n      }\n\n      // wrap a plain object they is not a JWK Set in Array\n      if (!jwks.keys && (typeof jwks === 'undefined' ? 'undefined' : _typeof(jwks)) === 'object') {\n        keys = [jwks];\n      }\n\n      // ensure there are keys to search\n      if (!keys) {\n        throw new DataError('Invalid JWK argument');\n      }\n\n      // match by \"kid\" or \"use\" header\n      if (kid) {\n        match = keys.find(function (jwk) {\n          return jwk.kid === kid;\n        });\n      } else {\n        match = keys.find(function (jwk) {\n          return jwk.use === 'sig';\n        });\n      }\n\n      // assign matching key to JWT and return a boolean\n      if (match) {\n        this.key = match.cryptoKey;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      // validate\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      var token = this;\n\n      if (this.isJWE()) {\n        return JWE.encrypt(token);\n      } else {\n        return JWS.sign(token);\n      }\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a decoded JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      return JWS.verify(this);\n    }\n  }], [{\n    key: 'decode',\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Token\n     *\n     * @param {string} data\n     * @returns {JWT}\n     */\n    value: function decode(data) {\n      var ExtendedJWT = this;\n      var jwt = void 0;\n\n      if (typeof data !== 'string') {\n        throw new DataError('JWT must be a string');\n      }\n\n      // JSON of Flattened JSON Serialization\n      if (data.startsWith('{')) {\n        try {\n          data = JSON.parse(data, function () {});\n        } catch (error) {\n          throw new DataError('Invalid JWT serialization');\n        }\n\n        if (data.signatures || data.recipients) {\n          data.serialization = 'json';\n        } else {\n          data.serialization = 'flattened';\n        }\n\n        jwt = new ExtendedJWT(data, { filter: false });\n\n        // Compact Serialization\n      } else {\n        try {\n          var serialization = 'compact';\n          var segments = data.split('.');\n          var length = segments.length;\n\n          if (length !== 3 && length !== 5) {\n            throw new Error('Malformed JWT');\n          }\n\n          var header = JSON.parse(base64url.decode(segments[0]\n\n          // JSON Web Signature\n          ));if (length === 3) {\n            var type = 'JWS';\n            var payload = JSON.parse(base64url.decode(segments[1]));\n            var signature = segments[2];\n\n            jwt = new ExtendedJWT({ type: type, segments: segments, header: header, payload: payload, signature: signature, serialization: serialization }, { filter: false });\n          }\n\n          // JSON Web Encryption\n          if (length === 5) {\n            //let type = 'JWE'\n            //let [protected, encryption_key, iv, ciphertext, tag] = segments\n\n            //jwt = new ExtendedJWT({\n            //  type,\n            //  protected: base64url.decode(JSON.parse(protected)),\n            //  encryption_key,\n            //  iv,\n            //  ciphertext,\n            //  tag,\n            //  serialization\n            //})\n          }\n        } catch (error) {\n          throw new DataError('Invalid JWT compact serialization');\n        }\n      }\n\n      return jwt;\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token\n     *\n     * @param {Object} header\n     * @param {Object} payload\n     * @param {CryptoKey} key\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode(header, payload, key) {\n      var jwt = new JWT(header, payload);\n      return jwt.encode(key);\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     *\n     * @param {CryptoKey} key\n     * @param {string} token\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, token) {\n      var jwt = JWT.decode(token);\n      jwt.key = key;\n      return jwt.verify().then(function (verified) {\n        return jwt;\n      });\n    }\n  }, {\n    key: 'schema',\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWTSchema;\n    }\n  }]);\n\n  return JWT;\n}(JSONDocument);\n\n/**\n * Export\n */\n\nmodule.exports = JWT;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JSONPatch = __webpack_require__(19);\n\n/**\n * JSONDocument\n *\n * @class\n * JSONDocument is a high level interface that binds together all other features of\n * this package and provides the principle method of data modeling.\n */\n\nvar JSONDocument = function () {\n  _createClass(JSONDocument, null, [{\n    key: 'schema',\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      throw new Error('Schema must be defined by classes extending JSONDocument');\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} data\n     * @param {Object} options\n     */\n\n  }]);\n\n  function JSONDocument() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSONDocument);\n\n    this.initialize(data, options);\n  }\n\n  /**\n   * Initialize\n   *\n   * @param {Object} data\n   * @param {Object} options\n   */\n\n  _createClass(JSONDocument, [{\n    key: 'initialize',\n    value: function initialize() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = this.constructor.schema;\n\n      schema.initialize(this, data, options);\n    }\n\n    /**\n     * Validate\n     *\n     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(alternate) {\n      var schema = this.constructor.schema;\n\n      return (alternate || schema).validate(this);\n    }\n\n    /**\n     * Patch\n     *\n     * @param {Array} ops\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(ops) {\n      var patch = new JSONPatch(ops);\n      patch.apply(this);\n    }\n\n    /**\n     * Select\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {}\n\n    /**\n     * Project\n     *\n     * @description\n     * Given a mapping, return an object projected from the current instance.\n     *\n     * @example\n     * let schema = new JSONSchema({\n     *   properties: {\n     *     foo: { type: 'Array' }\n     *   }\n     * })\n     *\n     * let mapping = new JSONMapping({\n     *   '/foo/0': '/bar/baz'\n     * })\n     *\n     * class FooTracker extends JSONDocument {\n     *   static get schema () { return schema }\n     * }\n     *\n     * let instance = new FooTracker({ foo: ['qux'] })\n     * instance.project(mapping)\n     * // => { bar: { baz: 'qux' } }\n     *\n     * @param {JSONMapping} mapping\n     * @return {Object}\n     */\n\n  }, {\n    key: 'project',\n    value: function project(mapping) {\n      return mapping.project(this);\n    }\n\n    /**\n     * Serialize\n     *\n     * @param {Object} object\n     * @returns {string}\n     */\n\n  }], [{\n    key: 'serialize',\n    value: function serialize(object) {\n      return JSON.stringify(object);\n    }\n\n    /**\n     * Deserialize\n     *\n     * @param {string} data\n     * @return {*}\n     */\n\n  }, {\n    key: 'deserialize',\n    value: function deserialize(data) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        throw new Error('Failed to parse JSON');\n      }\n    }\n  }]);\n\n  return JSONDocument;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = JSONDocument;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JSONPointer = __webpack_require__(5);\n\n/**\n * JSONPointer mode\n */\nvar RECOVER = 1;\n\n/**\n * JSONMapping\n *\n * @class\n * Defines a means to declaratively translate between object\n * representations using JSON Pointer syntax.\n */\n\nvar JSONMapping = function () {\n\n  /**\n   * Constructor\n   *\n   * @description Translate pointers from JSON Strings into Pointer objects\n   * @param {Object} mapping\n   */\n  function JSONMapping(mapping) {\n    var _this = this;\n\n    _classCallCheck(this, JSONMapping);\n\n    Object.defineProperty(this, 'mapping', {\n      enumerable: false,\n      value: new Map()\n    });\n\n    Object.keys(mapping).forEach(function (key) {\n      var value = mapping[key];\n      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n    });\n  }\n\n  /**\n   * Map\n   *\n   * @description Assign values from source to target by reading the mapping\n   * from right to left.\n   * @param {Object} target\n   * @param {Object} source\n   */\n\n  _createClass(JSONMapping, [{\n    key: 'map',\n    value: function map(target, source) {\n      this.mapping.forEach(function (right, left) {\n        left.add(target, right.get(source));\n      });\n    }\n\n    /**\n     * Project\n     *\n     * @description Assign values from source to target by reading the mapping\n     * from left to right.\n     * @param {Object} source\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'project',\n    value: function project(source, target) {\n      this.mapping.forEach(function (right, left) {\n        right.add(target, left.get(source));\n      });\n    }\n  }]);\n\n  return JSONMapping;\n}();\n\n/**\n * Exports\n */\n\nmodule.exports = JSONMapping;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  }return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Initializer = __webpack_require__(18);\nvar Validator = __webpack_require__(20);\n\n/**\n * JSONSchema\n *\n * @class\n * Compiles JSON Schema documents to an object with object initialization\n * and validation methods.\n */\n\nvar JSONSchema = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Object} schema\n   */\n  function JSONSchema(schema) {\n    _classCallCheck(this, JSONSchema);\n\n    // TODO: optionally parse JSON string?\n    Object.assign(this, schema);\n\n    // add schema-derived initialize and validate methods\n    Object.defineProperties(this, {\n      initialize: {\n        enumerable: false,\n        writeable: false,\n        value: Initializer.compile(schema)\n      },\n      validate: {\n        enumerable: false,\n        writeable: false,\n        value: Validator.compile(schema)\n      }\n    });\n  }\n\n  /**\n   * Extend\n   *\n   * @description\n   * ...\n   * Dear future,\n   *\n   * This function was meticulously plagiarized from some curious amalgam of\n   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n   *\n   * Goodnight.\n   *\n   * @param {Object} schema\n   * @returns {JSONSchema}\n   */\n\n  _createClass(JSONSchema, [{\n    key: 'extend',\n    value: function extend(schema) {\n      function isObject(data) {\n        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n      }\n\n      function extender(target, source) {\n        var result = Object.assign({}, target);\n        if (isObject(target) && isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(result, _defineProperty({}, key, source[key]));\n              } else {\n                result[key] = extender(target[key], source[key]);\n              }\n            } else {\n              Object.assign(result, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n        return result;\n      }\n\n      var descriptor = extender(this, schema);\n      return new JSONSchema(descriptor);\n    }\n  }]);\n\n  return JSONSchema;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = JSONSchema;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction placeHoldersCount(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n}\n\nfunction byteLength(b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64);\n}\n\nfunction toByteArray(b64) {\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n  placeHolders = placeHoldersCount(b64);\n\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = tmp >> 16 & 0xFF;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[tmp << 4 & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    output += lookup[tmp >> 10];\n    output += lookup[tmp >> 4 & 0x3F];\n    output += lookup[tmp << 2 & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('');\n}\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nvar pad_string_1 = __webpack_require__(37);\nfunction encode(input, encoding) {\n    if (encoding === void 0) {\n        encoding = \"utf8\";\n    }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(new Buffer(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) {\n        encoding = \"utf8\";\n    }\n    return new Buffer(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url).replace(/\\-/g, \"+\").replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return new Buffer(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = base64url;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = new Buffer(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = padString;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\nmodule.exports = TextEncoder;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(23);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// jose.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 41);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0dd132bda4c7e2da52de","'use strict';\n\nmodule.exports = {\n  Formats: require('./Formats'),\n  Initializer: require('./Initializer'),\n  JSONDocument: require('./JSONDocument'),\n  JSONMapping: require('./JSONMapping'),\n  JSONPatch: require('./JSONPatch'),\n  JSONPointer: require('./JSONPointer'),\n  JSONSchema: require('./JSONSchema'),\n  Validator: require('./Validator')\n};\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/index.js","module.exports = require('./dist/base64url').default;\nmodule.exports.default = module.exports;\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64url/index.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _require = require('@trust/json-document'),\n    JSONSchema = _require.JSONSchema;\n\nvar _require2 = require('../formats'\n\n/**\n * JWK Schema\n */\n),\n    BASE64_REGEXP = _require2.BASE64_REGEXP;\n\nvar JWKSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    kty: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['RSA', 'EC', 'oct'] // other values MAY be used\n    },\n\n    use: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['sig', 'enc'] // other values MAY be used\n    },\n\n    key_ops: {\n      type: 'array',\n      //format: 'case-sensitive',\n      items: {\n        enum: ['sign', 'verify', 'encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey', 'deriveBits'] // other values MAY be used\n      }\n    },\n\n    alg: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'PS256', 'PS384', 'PS512', 'none'] // other values MAY be used\n    },\n\n    kid: {\n      type: 'string'\n    },\n\n    x5u: {\n      type: 'string'\n      //format: 'url'\n    },\n\n    x5c: {\n      type: 'array'\n      //format: BASE64_REGEXP\n    },\n\n    x5t: {\n      type: 'string'\n      //format: BASE64_REGEXP\n    }\n\n    //'x5t#S256': {\n    //  type: 'string',\n    //  //format: BASE64_REGEXP\n    //}\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JWKSchema.js","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/buffer/index.js","'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\nvar base64url = require('base64url');\nvar supportedAlgorithms = require('../algorithms');\n\nvar _require = require('../errors'\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\n),\n    NotSupportedError = _require.NotSupportedError;\n\nvar JWA = function () {\n  function JWA() {\n    _classCallCheck(this, JWA);\n  }\n\n  _createClass(JWA, null, [{\n    key: 'sign',\n\n\n    /**\n     * Sign\n     *\n     * @description\n     * Create a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} key\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n    value: function sign(alg, key, data) {\n      // normalize the algorithm\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg\n\n      // validate algorithm is supported\n      );if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // validate type of key\n      // TODO\n      //  - is the key suitable for the algorithm?\n      //  - does that get validated in webcrypto?\n      //if (key instanceof CryptoKey) {\n      //  return Promise.reject(new InvalidKeyError())\n      //}\n\n      // sign the data\n      return normalizedAlgorithm.sign(key, data);\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} privateKey\n     * @param {string|Buffer} signature\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(alg, key, signature, data) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // TODO\n      // validate publicKey\n\n      // verify the signature\n      return normalizedAlgorithm.verify(key, signature, data);\n    }\n\n    /**\n     * Encrypt\n     */\n\n    /**\n     * Decrypt\n     */\n\n    /**\n     * Import\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg);\n      return normalizedAlgorithm.importKey(key);\n    }\n  }]);\n\n  return JWA;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWA;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWA.js","'use strict';\n\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n\n  /**\n   * Escape\n   */\n\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n\n      return '#/' + value;\n    }\n\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      // iterate through the tokens\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        // set the property on the target location\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          }\n\n          // handle missing target location based on \"mode\"\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          }\n\n          // reference the next object in the path\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      }\n\n      // delete from the target\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPointer;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONPointer.js","\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * DataError\n */\nvar DataError = function (_Error) {\n  _inherits(DataError, _Error);\n\n  function DataError(message) {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message));\n  }\n\n  return DataError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = DataError;\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/DataError.js","\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * NotSupportedError\n */\nvar NotSupportedError = function (_Error) {\n  _inherits(NotSupportedError, _Error);\n\n  function NotSupportedError(alg) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this.message = alg + \" is not a supported algorithm\";\n    return _this;\n  }\n\n  return NotSupportedError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = NotSupportedError;\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/NotSupportedError.js","'use strict';\n\nmodule.exports = {\n  DataError: require('./DataError'),\n  NotSupportedError: require('./NotSupportedError')\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/index.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = require('@trust/json-document'),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSchema = require('../schemas/JWKSchema');\nvar JWA = require('./JWA'\n\n/**\n * JWK Class\n */\n);\nvar JWK = function (_JSONDocument) {\n  _inherits(JWK, _JSONDocument);\n\n  function JWK() {\n    _classCallCheck(this, JWK);\n\n    return _possibleConstructorReturn(this, (JWK.__proto__ || Object.getPrototypeOf(JWK)).apply(this, arguments));\n  }\n\n  _createClass(JWK, null, [{\n    key: 'importKey',\n\n\n    /**\n     * importKey\n     *\n     * TODO:\n     * - should this be on JWA?\n     */\n    value: function importKey(jwk) {\n      return JWA.importKey(jwk);\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return JWKSchema;\n    }\n  }]);\n\n  return JWK;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWK;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWK.js","'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar base64url = require('base64url');\nvar JWA = require('./JWA');\n\nvar _require = require('../errors'\n\n/**\n * JWS\n */\n),\n    DataError = _require.DataError;\n\nvar JWS = function () {\n  function JWS() {\n    _classCallCheck(this, JWS);\n  }\n\n  _createClass(JWS, null, [{\n    key: 'sign',\n\n\n    /**\n     * sign\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @param {Object} token\n     * @returns {Promise}\n     */\n    value: function sign(token) {\n      var payload = base64url(JSON.stringify(token.payload)\n\n      // compact serialization\n      );if (token.serialization === 'compact') {\n        var key = token.key,\n            alg = token.header.alg;\n\n        var header = base64url(JSON.stringify(token.header));\n        var data = header + '.' + payload;\n\n        return JWA.sign(alg, key, data).then(function (signature) {\n          return data + '.' + signature;\n        });\n      }\n\n      // JSON serialization\n      if (token.serialization === 'json') {}\n\n      // Flattened serialization\n      if (token.serialization === 'flattened') {}\n\n      return Promise.reject(new DataError('Unsupported serialization'));\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(jwt) {\n      // multiple signatures\n      if (jwt.signatures) {\n        // ...\n      }\n\n      var key = jwt.key,\n          signature = jwt.signature,\n          alg = jwt.header.alg;\n\n      // one signature\n\n      if (jwt.signature) {\n        var _jwt$segments = _slicedToArray(jwt.segments, 2),\n            header = _jwt$segments[0],\n            payload = _jwt$segments[1];\n\n        var data = header + '.' + payload;\n\n        if (alg === 'none') {\n          return Promise.reject(new DataError('Signature provided to verify with alg: none'));\n        }\n\n        return JWA.verify(alg, key, signature, data).then(function (verified) {\n          jwt.verified = verified;\n          return verified;\n        });\n      }\n\n      if (alg === 'none') {\n        if (!key && !signature) {\n          jwt.verified = true;\n\n          return Promise.resolve(true);\n        }\n\n        if (key) {\n          return Promise.reject(new DataError('Key provided to verify signature with alg: none'));\n        }\n      }\n\n      // no signatures to verify\n      return Promise.reject(new DataError('Missing signature(s)'));\n    }\n  }]);\n\n  return JWS;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWS;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWS.js","'use strict';\n\n/**\n * Dependencies\n */\nvar _require = require('@trust/json-document'\n\n/**\n * Base64URLSchema\n */\n),\n    JSONSchema = _require.JSONSchema;\n\nvar Base64URLSchema = new JSONSchema({\n  type: 'string',\n  format: 'base64url'\n});\n\n/**\n * Export\n */\nmodule.exports = Base64URLSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/Base64URLSchema.js","'use strict';\n\n/**\n * Dependencies\n */\nvar JWKSchema = require('./JWKSchema');\n\nvar _require = require('@trust/json-document'\n\n/**\n * JOSEHeaderSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-5\n *\n * 5.  JOSE Header\n *\n *   For a JWT object, the members of the JSON object represented by the\n *   JOSE Header describe the cryptographic operations applied to the JWT\n *   and optionally, additional properties of the JWT.  Depending upon\n *   whether the JWT is a JWS or JWE, the corresponding rules for the JOSE\n *   Header values apply.\n */\n),\n    JSONSchema = _require.JSONSchema;\n\nvar JOSEHeaderSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * typ\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.1\n     *\n     * 5.1.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter defined by [JWS] and [JWE] is used\n     *   by JWT applications to declare the media type [IANA.MediaTypes] of\n     *   this complete JWT.  This is intended for use by the JWT application\n     *   when values that are not JWTs could also be present in an application\n     *   data structure that can contain a JWT object; the application can use\n     *   this value to disambiguate among the different kinds of objects that\n     *   might be present.  It will typically not be used by applications when\n     *   it is already known that the object is a JWT.  This parameter is\n     *   ignored by JWT implementations; any processing of this parameter is\n     *   performed by the JWT application.  If present, it is RECOMMENDED that\n     *   its value be \"JWT\" to indicate that this object is a JWT.  While\n     *   media type names are not case sensitive, it is RECOMMENDED that \"JWT\"\n     *   always be spelled using uppercase characters for compatibility with\n     *   legacy implementations.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.9\n     *\n     * 4.1.9.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter is used by JWS applications to\n     *   declare the media type [IANA.MediaTypes] of this complete JWS.  This\n     *   is intended for use by the application when more than one kind of\n     *   object could be present in an application data structure that can\n     *   contain a JWS; the application can use this value to disambiguate\n     *   among the different kinds of objects that might be present.  It will\n     *   typically not be used by applications when the kind of object is\n     *   already known.  This parameter is ignored by JWS implementations; any\n     *   processing of this parameter is performed by the JWS application.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"typ\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"typ\" value not containing a\n     *   '/'.  For instance, a \"typ\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     *   The \"typ\" value \"JOSE\" can be used by applications to indicate that\n     *   this object is a JWS or JWE using the JWS Compact Serialization or\n     *   the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be\n     *   used by applications to indicate that this object is a JWS or JWE\n     *   using the JWS JSON Serialization or the JWE JSON Serialization.\n     *   Other type values can also be used by applications.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.11\n     *\n     * 4.1.11.  \"typ\" (Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"typ\" Header Parameter defined in Section 4.1.9 of [JWS], except\n     *   that the type is that of this complete JWE.\n     */\n    typ: {\n      type: 'string'\n    },\n\n    /**\n     * cty\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.2\n     *\n     * 5.2.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter defined by [JWS] and [JWE]\n     *   is used by this specification to convey structural information about\n     *   the JWT.\n     *\n     *   In the normal case in which nested signing or encryption operations\n     *   are not employed, the use of this Header Parameter is NOT\n     *   RECOMMENDED.  In the case that nested signing or encryption is\n     *   employed, this Header Parameter MUST be present; in this case, the\n     *   value MUST be \"JWT\", to indicate that a Nested JWT is carried in this\n     *   JWT.  While media type names are not case sensitive, it is\n     *   RECOMMENDED that \"JWT\" always be spelled using uppercase characters\n     *   for compatibility with legacy implementations.  See Appendix A.2 for\n     *   an example of a Nested JWT.\n     *\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.10\n     *\n     * 4.1.10.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter is used by JWS applications\n     *   to declare the media type [IANA.MediaTypes] of the secured content\n     *   (the payload).  This is intended for use by the application when more\n     *   than one kind of object could be present in the JWS Payload; the\n     *   application can use this value to disambiguate among the different\n     *   kinds of objects that might be present.  It will typically not be\n     *   used by applications when the kind of object is already known.  This\n     *   parameter is ignored by JWS implementations; any processing of this\n     *   parameter is performed by the JWS application.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"cty\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"cty\" value not containing a\n     *   '/'.  For instance, a \"cty\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.12\n     *\n     * 4.1.12.  \"cty\" (Content Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"cty\" Header Parameter defined in Section 4.1.10 of [JWS], except\n     *   that the type is that of the secured content (the plaintext).\n     */\n    cty: {\n      type: 'string',\n      enum: ['JWT']\n    },\n\n    /**\n     * alg\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   The \"alg\" (algorithm) Header Parameter identifies the cryptographic\n     *   algorithm used to secure the JWS.  The JWS Signature value is not\n     *   valid if the \"alg\" value does not represent a supported algorithm or\n     *   if there is not a key for use with that algorithm associated with the\n     *   party that digitally signed or MACed the content.  \"alg\" values\n     *   should either be registered in the IANA \"JSON Web Signature and\n     *   Encryption Algorithms\" registry established by [JWA] or be a value\n     *   that contains a Collision-Resistant Name.  The \"alg\" value is a case-\n     *   sensitive ASCII string containing a StringOrURI value.  This Header\n     *   Parameter MUST be present and MUST be understood and processed by\n     *   implementations.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 3.1 of [JWA].\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"alg\" Header Parameter defined in Section 4.1.1 of [JWS], except\n     *   that the Header Parameter identifies the cryptographic algorithm used\n     *   to encrypt or determine the value of the CEK.  The encrypted content\n     *   is not usable if the \"alg\" value does not represent a supported\n     *   algorithm, or if the recipient does not have a key that can be used\n     *   with that algorithm.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 4.1 of [JWA].\n     */\n    alg: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * jku\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.2\n     *\n     * 4.1.2.  \"jku\" (JWK Set URL) Header Parameter (JWS)\n     *\n     *   The \"jku\" (JWK Set URL) Header Parameter is a URI [RFC3986] that\n     *   refers to a resource for a set of JSON-encoded public keys, one of\n     *   which corresponds to the key used to digitally sign the JWS.  The\n     *   keys MUST be encoded as a JWK Set [JWK].  The protocol used to\n     *   acquire the resource MUST provide integrity protection; an HTTP GET\n     *   request to retrieve the JWK Set MUST use Transport Layer Security\n     *   (TLS) [RFC2818] [RFC5246]; and the identity of the server MUST be\n     *   validated, as per Section 6 of RFC 6125 [RFC6125].  Also, see\n     *   Section 8 on TLS requirements.  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.4\n     *\n     * 4.1.4.  \"jku\" (JWK Set URL) Header Parameter (JWE)\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jku\" Header Parameter defined in Section 4.1.2 of [JWS], except\n     *   that the JWK Set resource contains the public key to which the JWE\n     *   was encrypted; this can be used to determine the private key needed\n     *   to decrypt the JWE.\n     */\n    jku: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * jwk\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.3\n     *\n     * 4.1.3.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   The \"jwk\" (JSON Web Key) Header Parameter is the public key that\n     *   corresponds to the key used to digitally sign the JWS.  This key is\n     *   represented as a JSON Web Key [JWK].  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.5\n     *\n     * 4.1.5.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jwk\" Header Parameter defined in Section 4.1.3 of [JWS], except\n     *   that the key is the public key to which the JWE was encrypted; this\n     *   can be used to determine the private key needed to decrypt the JWE.\n     */\n    //jwk: JWKSchema,\n\n    /**\n     * kid\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.4\n     *\n     * 4.1.4.  \"kid\" (Key ID) Header Parameter\n     *\n     *   The \"kid\" (key ID) Header Parameter is a hint indicating which key\n     *   was used to secure the JWS.  This parameter allows originators to\n     *   explicitly signal a change of key to recipients.  The structure of\n     *   the \"kid\" value is unspecified.  Its value MUST be a case-sensitive\n     *   string.  Use of this Header Parameter is OPTIONAL.\n     *\n     *   When used with a JWK, the \"kid\" value is used to match a JWK \"kid\"\n     *   parameter value.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.6\n     *\n     * 4.1.6.  \"kid\" (Key ID) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"kid\" Header Parameter defined in Section 4.1.4 of [JWS], except\n     *   that the key hint references the public key to which the JWE was\n     *   encrypted; this can be used to determine the private key needed to\n     *   decrypt the JWE.  This parameter allows originators to explicitly\n     *   signal a change of key to JWE recipients.\n     */\n    kid: {\n      type: 'string'\n    },\n\n    /**\n     * x5u\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.5\n     *\n     * 4.1.5.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   The \"x5u\" (X.509 URL) Header Parameter is a URI [RFC3986] that refers\n     *   to a resource for the X.509 public key certificate or certificate\n     *   chain [RFC5280] corresponding to the key used to digitally sign the\n     *   JWS.  The identified resource MUST provide a representation of the\n     *   certificate or certificate chain that conforms to RFC 5280 [RFC5280]\n     *   in PEM-encoded form, with each certificate delimited as specified in\n     *   Section 6.1 of RFC 4945 [RFC4945].  The certificate containing the\n     *   public key corresponding to the key used to digitally sign the JWS\n     *   MUST be the first certificate.  This MAY be followed by additional\n     *   certificates, with each subsequent certificate being the one used to\n     *   certify the previous one.  The protocol used to acquire the resource\n     *   MUST provide integrity protection; an HTTP GET request to retrieve\n     *   the certificate MUST use TLS [RFC2818] [RFC5246]; and the identity of\n     *   the server MUST be validated, as per Section 6 of RFC 6125 [RFC6125].\n     *   Also, see Section 8 on TLS requirements.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.7\n     *\n     * 4.1.7.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5u\" Header Parameter defined in Section 4.1.5 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5u: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * x5c\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.6\n     *\n     * 4.1.6.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   The \"x5c\" (X.509 certificate chain) Header Parameter contains the\n     *   X.509 public key certificate or certificate chain [RFC5280]\n     *   corresponding to the key used to digitally sign the JWS.  The\n     *   certificate or certificate chain is represented as a JSON array of\n     *   certificate value strings.  Each string in the array is a\n     *   base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER\n     *   [ITU.X690.2008] PKIX certificate value.  The certificate containing\n     *   the public key corresponding to the key used to digitally sign the\n     *   JWS MUST be the first certificate.  This MAY be followed by\n     *   additional certificates, with each subsequent certificate being the\n     *   one used to certify the previous one.  The recipient MUST validate\n     *   the certificate chain according to RFC 5280 [RFC5280] and consider\n     *   the certificate or certificate chain to be invalid if any validation\n     *   failure occurs.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.8\n     *\n     * 4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5c\" Header Parameter defined in Section 4.1.6 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5c: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'base64'\n      }\n    },\n\n    /**\n     * x5t\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.7\n     *\n     * 4.1.7.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   The \"x5t\" (X.509 certificate SHA-1 thumbprint) Header Parameter is a\n     *   base64url-encoded SHA-1 thumbprint (a.k.a. digest) of the DER\n     *   encoding of the X.509 certificate [RFC5280] corresponding to the key\n     *   used to digitally sign the JWS.  Note that certificate thumbprints\n     *   are also sometimes known as certificate fingerprints.  Use of this\n     *   Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.9\n     *\n     * 4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t\" Header Parameter defined in Section 4.1.7 of [JWS], except\n     *   that the certificate referenced by the thumbprint contains the public\n     *   key to which the JWE was encrypted; this can be used to determine the\n     *   private key needed to decrypt the JWE.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     */\n    x5t: {\n      type: 'string',\n      format: 'base64url'\n    },\n\n    /**\n     * x5t#S256\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.8\n     *\n     * 4.1.8.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *         Parameter\n     *\n     *   The \"x5t#S256\" (X.509 certificate SHA-256 thumbprint) Header\n     *   Parameter is a base64url-encoded SHA-256 thumbprint (a.k.a. digest)\n     *   of the DER encoding of the X.509 certificate [RFC5280] corresponding\n     *   to the key used to digitally sign the JWS.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.10\n     *\n     * 4.1.10.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *          Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t#S256\" Header Parameter defined in Section 4.1.8 of [JWS],\n     *   except that the certificate referenced by the thumbprint contains the\n     *   public key to which the JWE was encrypted; this can be used to\n     *   determine the private key needed to decrypt the JWE.  Note that\n     *   certificate thumbprints are also sometimes known as certificate\n     *   fingerprints.\n     */\n    //'x5t#S256': {\n    //  type: 'string',\n    //  format: 'base64url'\n    //},\n\n    /**\n     * crit\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.11\n     *\n     * 4.1.11.  \"crit\" (Critical) Header Parameter\n     *\n     *   The \"crit\" (critical) Header Parameter indicates that extensions to\n     *   this specification and/or [JWA] are being used that MUST be\n     *   understood and processed.  Its value is an array listing the Header\n     *   Parameter names present in the JOSE Header that use those extensions.\n     *   If any of the listed extension Header Parameters are not understood\n     *   and supported by the recipient, then the JWS is invalid.  Producers\n     *   MUST NOT include Header Parameter names defined by this specification\n     *   or [JWA] for use with JWS, duplicate names, or names that do not\n     *   occur as Header Parameter names within the JOSE Header in the \"crit\"\n     *   list.  Producers MUST NOT use the empty list \"[]\" as the \"crit\"\n     *   value.  Recipients MAY consider the JWS to be invalid if the critical\n     *   list contains any Header Parameter names defined by this\n     *   specification or [JWA] for use with JWS or if any other constraints\n     *   on its use are violated.  When used, this Header Parameter MUST be\n     *   integrity protected; therefore, it MUST occur only within the JWS\n     *   Protected Header.  Use of this Header Parameter is OPTIONAL.  This\n     *   Header Parameter MUST be understood and processed by implementations.\n     *\n     *   An example use, along with a hypothetical \"exp\" (expiration time)\n     *   field is:\n     *\n     *     {\"alg\":\"ES256\",\n     *     \"crit\":[\"exp\"],\n     *     \"exp\":1363284000\n     *     }\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.13\n     *\n     *   4.1.13.  \"crit\" (Critical) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"crit\" Header Parameter defined in Section 4.1.11 of [JWS],\n     *   except that Header Parameters for a JWE are being referred to, rather\n     *   than Header Parameters for a JWS.\n     */\n    crit: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      minItems: 1\n    },\n\n    /**\n     * enc\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.2\n     *\n     * 4.1.2.  \"enc\" (Encryption Algorithm) Header Parameter\n     *\n     *   The \"enc\" (encryption algorithm) Header Parameter identifies the\n     *   content encryption algorithm used to perform authenticated encryption\n     *   on the plaintext to produce the ciphertext and the Authentication\n     *   Tag.  This algorithm MUST be an AEAD algorithm with a specified key\n     *   length.  The encrypted content is not usable if the \"enc\" value does\n     *   not represent a supported algorithm.  \"enc\" values should either be\n     *   registered in the IANA \"JSON Web Signature and Encryption Algorithms\"\n     *   registry established by [JWA] or be a value that contains a\n     *   Collision-Resistant Name.  The \"enc\" value is a case-sensitive ASCII\n     *   string containing a StringOrURI value.  This Header Parameter MUST be\n     *   present and MUST be understood and processed by implementations.\n     *\n     *   A list of defined \"enc\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 5.1 of [JWA].\n     */\n    enc: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * zip\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.3\n     *\n     * 4.1.3.  \"zip\" (Compression Algorithm) Header Parameter\n     *\n     *   The \"zip\" (compression algorithm) applied to the plaintext before\n     *   encryption, if any.  The \"zip\" value defined by this specification\n     *   is:\n     *\n     *   o  \"DEF\" - Compression with the DEFLATE [RFC1951] algorithm\n     *\n     *   Other values MAY be used.  Compression algorithm values can be\n     *   registered in the IANA \"JSON Web Encryption Compression Algorithms\"\n     *   registry established by [JWA].  The \"zip\" value is a case-sensitive\n     *   string.  If no \"zip\" parameter is present, no compression is applied\n     *   to the plaintext before encryption.  When used, this Header Parameter\n     *   MUST be integrity protected; therefore, it MUST occur only within the\n     *   JWE Protected Header.  Use of this Header Parameter is OPTIONAL.\n     *   This Header Parameter MUST be understood and processed by\n     *   implementations.\n     */\n    zip: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JOSEHeaderSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JOSEHeaderSchema.js","'use strict';\n\n/**\n * Dependencies\n */\n\nvar _require = require('@trust/json-document'),\n    JSONSchema = _require.JSONSchema;\n\nvar JWKSchema = require('./JWKSchema'\n\n/**\n * JWKSetSchema\n */\n);var JWKSetSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    keys: {\n      type: 'array',\n      items: JWKSchema\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSetSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JWKSetSchema.js","'use strict';\n\n/**\n * Dependencies\n */\nvar _require = require('@trust/json-document'\n\n/**\n * JWTClaimsSetSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-4\n *\n * 4.  JWT Claims\n *\n *   The JWT Claims Set represents a JSON object whose members are the\n *   claims conveyed by the JWT.  The Claim Names within a JWT Claims Set\n *   MUST be unique; JWT parsers MUST either reject JWTs with duplicate\n *   Claim Names or use a JSON parser that returns only the lexically last\n *   duplicate member name, as specified in Section 15.12 (\"The JSON\n *   Object\") of ECMAScript 5.1 [ECMAScript].\n *\n *   The set of claims that a JWT must contain to be considered valid is\n *   context dependent and is outside the scope of this specification.\n *   Specific applications of JWTs will require implementations to\n *   understand and process some claims in particular ways.  However, in\n *   the absence of such requirements, all claims that are not understood\n *   by implementations MUST be ignored.\n *\n *   There are three classes of JWT Claim Names: Registered Claim Names,\n *   Public Claim Names, and Private Claim Names.\n */\n),\n    JSONSchema = _require.JSONSchema;\n\nvar JWTClaimsSetSchema = new JSONSchema({\n  properties: {\n\n    /**\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1\n     *\n     * 4.1.  Registered Claim Names\n     *\n     *   The following Claim Names are registered in the IANA \"JSON Web Token\n     *   Claims\" registry established by Section 10.1.  None of the claims\n     *   defined below are intended to be mandatory to use or implement in all\n     *   cases, but rather they provide a starting point for a set of useful,\n     *   interoperable claims.  Applications using JWTs should define which\n     *   specific claims they use and when they are required or optional.  All\n     *   the names are short because a core goal of JWTs is for the\n     *   representation to be compact.\n     */\n\n    /**\n     * iss\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.1\n     *\n     * 4.1.1.  \"iss\" (Issuer) Claim\n     *\n     *   The \"iss\" (issuer) claim identifies the principal that issued the\n     *   JWT.  The processing of this claim is generally application specific.\n     *   The \"iss\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    iss: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * sub\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.2\n     *\n     * 4.1.2.  \"sub\" (Subject) Claim\n     *\n     *   The \"sub\" (subject) claim identifies the principal that is the\n     *   subject of the JWT.  The claims in a JWT are normally statements\n     *   about the subject.  The subject value MUST either be scoped to be\n     *   locally unique in the context of the issuer or be globally unique.\n     *   The processing of this claim is generally application specific.  The\n     *   \"sub\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    sub: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * aud\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.3\n     *\n     * 4.1.3.  \"aud\" (Audience) Claim\n     *\n     *   The \"aud\" (audience) claim identifies the recipients that the JWT is\n     *   intended for.  Each principal intended to process the JWT MUST\n     *   identify itself with a value in the audience claim.  If the principal\n     *   processing the claim does not identify itself with a value in the\n     *   \"aud\" claim when this claim is present, then the JWT MUST be\n     *   rejected.  In the general case, the \"aud\" value is an array of case-\n     *   sensitive strings, each containing a StringOrURI value.  In the\n     *   special case when the JWT has one audience, the \"aud\" value MAY be a\n     *   single case-sensitive string containing a StringOrURI value.  The\n     *   interpretation of audience values is generally application specific.\n     *   Use of this claim is OPTIONAL.\n     */\n    aud: {\n      type: ['array', 'string'],\n      format: 'StringOrURI',\n      items: {\n        format: 'StringOrURI'\n      }\n    },\n\n    /**\n     * exp\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.4\n     *\n     * 4.1.4.  \"exp\" (Expiration Time) Claim\n     *\n     *   The \"exp\" (expiration time) claim identifies the expiration time on\n     *   or after which the JWT MUST NOT be accepted for processing.  The\n     *   processing of the \"exp\" claim requires that the current date/time\n     *   MUST be before the expiration date/time listed in the \"exp\" claim.\n     *\n     *   Implementers MAY provide for some small leeway, usually no more than\n     *   a few minutes, to account for clock skew.  Its value MUST be a number\n     *   containing a NumericDate value.  Use of this claim is OPTIONAL.\n     *\n     */\n    exp: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * nbf\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.5\n     *\n     * 4.1.5.  \"nbf\" (Not Before) Claim\n     *\n     *   The \"nbf\" (not before) claim identifies the time before which the JWT\n     *   MUST NOT be accepted for processing.  The processing of the \"nbf\"\n     *   claim requires that the current date/time MUST be after or equal to\n     *   the not-before date/time listed in the \"nbf\" claim.  Implementers MAY\n     *   provide for some small leeway, usually no more than a few minutes, to\n     *   account for clock skew.  Its value MUST be a number containing a\n     *   NumericDate value.  Use of this claim is OPTIONAL.\n     */\n    nbf: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * iat\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.6\n     *\n     * 4.1.6.  \"iat\" (Issued At) Claim\n     *\n     *   The \"iat\" (issued at) claim identifies the time at which the JWT was\n     *   issued.  This claim can be used to determine the age of the JWT.  Its\n     *   value MUST be a number containing a NumericDate value.  Use of this\n     *   claim is OPTIONAL.\n     */\n    iat: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * jti\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.7\n     *\n     * 4.1.7.  \"jti\" (JWT ID) Claim\n     *\n     *   The \"jti\" (JWT ID) claim provides a unique identifier for the JWT.\n     *   The identifier value MUST be assigned in a manner that ensures that\n     *   there is a negligible probability that the same value will be\n     *   accidentally assigned to a different data object; if the application\n     *   uses multiple issuers, collisions MUST be prevented among values\n     *   produced by different issuers as well.  The \"jti\" claim can be used\n     *   to prevent the JWT from being replayed.  The \"jti\" value is a case-\n     *   sensitive string.  Use of this claim is OPTIONAL.\n     */\n    jti: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTClaimsSetSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JWTClaimsSetSchema.js","'use strict';\n\n/**\n * Dependencies\n */\nvar Base64URLSchema = require('./Base64URLSchema');\nvar JWTClaimsSetSchema = require('./JWTClaimsSetSchema');\nvar JOSEHeaderSchema = require('./JOSEHeaderSchema');\n\nvar _require = require('@trust/json-document'\n\n/**\n * JWTSchema\n *\n * @description\n * This schema represents all the things a deserialized JWT can be, i.e.,\n * either a JWS or JWE, and any serialization of them. Validation of well-\n * formedness for a given serialization is accomplished at the time of\n * encoding.\n */\n),\n    JSONSchema = _require.JSONSchema;\n\nvar JWTSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * type\n     */\n    type: {\n      type: 'string',\n      enum: ['JWS', 'JWE']\n    },\n\n    /**\n     * segments\n     */\n    segments: {\n      type: 'array'\n    },\n\n    /**\n     * header\n     */\n    header: JOSEHeaderSchema,\n\n    /**\n     * protected\n     */\n    protected: JOSEHeaderSchema,\n\n    /**\n     * unprotected\n     */\n    unprotected: JOSEHeaderSchema,\n\n    /**\n     * iv\n     */\n    iv: Base64URLSchema,\n\n    /**\n     * aad\n     */\n    aad: Base64URLSchema,\n\n    /**\n     * ciphertext\n     */\n    ciphertext: Base64URLSchema,\n\n    /**\n     * tag\n     */\n    tag: Base64URLSchema,\n\n    /**\n     * recipients\n     */\n    recipients: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          header: JOSEHeaderSchema,\n          encrypted_key: Base64URLSchema\n        }\n      }\n    },\n\n    /**\n     * payload\n     */\n    payload: JWTClaimsSetSchema,\n\n    /**\n     * signatures\n     */\n    signatures: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          protected: JOSEHeaderSchema,\n          header: JOSEHeaderSchema,\n          signature: Base64URLSchema,\n          key: { type: 'object' }\n        }\n      }\n    },\n\n    /**\n     * signature\n     */\n    signature: Base64URLSchema,\n\n    /**\n     * verified\n     */\n    verified: {\n      type: 'boolean',\n      default: false\n    },\n\n    /**\n     * key\n     */\n    key: {\n      type: 'object'\n    },\n\n    /**\n     * serialization\n     */\n    serialization: {\n      type: 'string',\n      enum: ['compact', 'json', 'flattened'],\n      default: 'compact'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JWTSchema.js","'use strict';\n\nvar TextEncoder = global.TextEncoder ? global.TextEncoder // browser\n: require('text-encoding').TextEncoder; // node shim\nmodule.exports = TextEncoder;\n\n\n// WEBPACK FOOTER //\n// ./lib/text-encoder/index.js","'use strict';\n\n/**\n * JSON Schema Formats\n *\n * TODO\n * Is there a good way to express these over multiple lines with comments\n * for easier debugging and auditing?\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\nvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\nvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\nvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\nvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\n/**\n * Formats\n */\n\nvar Formats = function () {\n  function Formats() {\n    _classCallCheck(this, Formats);\n  }\n\n  _createClass(Formats, [{\n    key: 'register',\n\n\n    /**\n     * Register\n     *\n     * @description\n     * Register a new mapping from named format to RegExp instance\n     *\n     * TODO\n     * We can do some extra validation of the RegExp to\n     * ensure it's the acceptable subset of RegExps allowed\n     * by JSON Schema.\n     *\n     * @param {string} name\n     * @param {RegExp} pattern\n     * @returns {RegExp}\n     */\n    value: function register(name, pattern) {\n      // verify name is a string\n      if (typeof name !== 'string') {\n        throw new Error('Format name must be a string');\n      }\n\n      // cast a string to RegExp\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n      }\n\n      return this[name] = pattern;\n    }\n\n    /**\n     * Resolve\n     *\n     * @description\n     * Given a format name, return the corresponding registered validation. In the\n     * event a format is not registered, throw an error.\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(name) {\n      var format = this[name];\n\n      if (!format) {\n        throw new Error('Unknown JSON Schema format.');\n      }\n\n      return format;\n    }\n\n    /**\n     * Test\n     *\n     * @description\n     * Test that a value conforms to a format.\n     *\n     * @param {string} name\n     * @param {string} value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(name, value) {\n      var format = this.resolve(name);\n      return format.test(value);\n    }\n  }], [{\n    key: 'initialize',\n\n\n    /**\n     * Initialize\n     *\n     * @description\n     * Create a new Formats instance and register default formats\n     *\n     * @returns {Formats}\n     */\n    value: function initialize() {\n      var formats = new Formats();\n      formats.register('date-time', DATETIME_REGEXP);\n      formats.register('uri', URI_REGEXP);\n      formats.register('email', EMAIL_REGEXP);\n      formats.register('ipv4', IPV4_REGEXP);\n      formats.register('ipv6', IPV6_REGEXP);\n      formats.register('hostname', HOSTNAME_REGEXP);\n      return formats;\n    }\n  }]);\n\n  return Formats;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Formats.initialize();\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/Formats.js","'use strict';\n\n/**\n * Initializer\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = function () {\n\n  /**\n   * constructor\n   */\n  function Initializer(schema, options) {\n    _classCallCheck(this, Initializer);\n\n    Object.assign(this, options || {});\n    this.root = this.root || this;\n\n    this.root.depth = this.root.depth || 1;\n\n    if (this.level > this.root.depth) {\n      this.root.depth = this.level;\n    }\n\n    this.level = this.level || 0;\n    this.schema = schema;\n  }\n\n  /**\n   * compile (static)\n   */\n\n\n  _createClass(Initializer, [{\n    key: 'compile',\n\n\n    /**\n     * compile\n     */\n    value: function compile() {\n      var root = this.root,\n          depth = this.depth,\n          level = this.level;\n\n      var declarations = '';\n      var body = '';\n\n      // traverse the schema and generate code\n      body += this.default();\n      body += this.properties();\n      //body += this.additionalProperties()\n      body += this.items();\n      //body += this.additionalItems()\n\n\n      // value\n      body += this.member();\n      body += this.item();\n\n      // after traversing the schema\n      // generate the variable declarations\n      if (root === this) {\n        for (var i = 1; i <= this.root.depth; i++) {\n          declarations += this.declaration(i);\n        }\n\n        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n      }\n\n      return body;\n    }\n\n    /**\n     * declaration\n     */\n\n  }, {\n    key: 'declaration',\n    value: function declaration(level) {\n      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n    }\n\n    /**\n     * default\n     */\n\n  }, {\n    key: 'default',\n    value: function _default() {\n      var schema = this.schema,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\n      var block = '';\n\n      if (schema.hasOwnProperty('default')) {\n\n        if (key) {\n          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (index) {\n          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * member\n     */\n\n  }, {\n    key: 'member',\n    value: function member() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      // `key` tells us to treat this subschema as an object member vs an array item\n      // and the absence of the other values here indicates we are dealing with a\n      // primitive value\n      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\n        // first generate the assignment statement\n        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\n        // for nested container objects, add the counter incrementing statement\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        // wrap the foregoing in a check for presence on the source\n        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * item\n     */\n\n  }, {\n    key: 'item',\n    value: function item() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          index = this.index;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\n        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var properties = schema.properties;\n\n      var block = '';\n\n      if (properties) {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\n          block += initializer.compile();\n        });\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n\n          if (index) {\n            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n          }\n\n          if (key) {\n            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n          }\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {}\n\n    /**\n     * items\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var items = schema.items;\n\n      var block = '';\n\n      if (items) {\n\n        if (Array.isArray(items)) {\n          // TODO\n          //\n          //\n          //\n          //\n          //\n          // ...\n\n        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n          var _index = 'i' + (level + 1);\n          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\n          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n        }\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {}\n  }], [{\n    key: 'compile',\n    value: function compile(schema) {\n      var initializer = new Initializer(schema);\n      var block = initializer.compile();\n\n      //console.log(beautify(block))\n      try {\n        return new Function('target', 'source', 'options', block);\n      } catch (e) {\n        console.log(e, e.stack);\n      }\n    }\n  }]);\n\n  return Initializer;\n}();\n\nmodule.exports = Initializer;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/Initializer.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = require('./JSONPointer');\n\n/**\n * Modes\n */\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * Operations list\n */\nvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\n/**\n * Patch\n *\n * @class\n * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n * https://tools.ietf.org/html/rfc6902\n */\n\nvar JSONPatch = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Array} ops\n   */\n  function JSONPatch(ops) {\n    _classCallCheck(this, JSONPatch);\n\n    this.ops = ops || [];\n  }\n\n  /**\n   * Apply\n   *\n   * @todo handle errors/roll back\n   * @todo protect properties that are private in the schema\n   * @todo map JSON Pointers real property names\n   *\n   * @param {Object} target\n   */\n\n\n  _createClass(JSONPatch, [{\n    key: 'apply',\n    value: function apply(target) {\n      var _this = this;\n\n      this.ops.forEach(function (operation) {\n        var op = operation.op;\n\n        if (!op) {\n          throw new Error('Missing \"op\" in JSON Patch operation');\n        }\n\n        if (OPERATIONS.indexOf(op) === -1) {\n          throw new Error('Invalid \"op\" in JSON Patch operation');\n        }\n\n        if (!operation.path) {\n          throw new Error('Missing \"path\" in JSON Patch operation');\n        }\n\n        _this[op](operation, target);\n      });\n    }\n\n    /**\n     * Add\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'add',\n    value: function add(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch add operation');\n      }\n\n      var pointer = new JSONPointer(op.path, SILENT);\n      pointer.add(target, op.value);\n    }\n\n    /**\n     * Remove\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(op, target) {\n      var pointer = new JSONPointer(op.path);\n      pointer.remove(target);\n    }\n\n    /**\n     * Replace\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch replace operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      pointer.replace(target, op.value);\n    }\n\n    /**\n     * Move\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'move',\n    value: function move(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch move operation');\n      }\n\n      if (op.path.match(new RegExp('^' + op.from))) {\n        throw new Error('Invalid \"from\" in JSON Patch move operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      from.remove(target);\n      pointer.add(target, value);\n    }\n\n    /**\n     * Copy\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch copy operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      pointer.add(target, value);\n    }\n\n    /**\n     * Test\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'test',\n    value: function test(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch test operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var value = pointer.get(target);\n\n      switch (_typeof(op.value)) {\n        //case 'string':\n        //case 'number':\n        //case 'boolean':\n        //  if (value !== op.value) {\n        //    throw new Error('Mismatching JSON Patch test value')\n        //  }\n        default:\n          if (value !== op.value) {\n            throw new Error('Mismatching JSON Patch test value');\n          }\n      }\n    }\n  }]);\n\n  return JSONPatch;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPatch;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONPatch.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar formats = require('./Formats');\n\n/**\n * For variable iterator counter\n *\n * @type {number}\n */\nvar indexCount = 0;\n\n/**\n * Validator\n *\n * Compile an object describing a JSON Schema into a validation function.\n */\n\nvar Validator = function () {\n  _createClass(Validator, null, [{\n    key: 'compile',\n\n\n    /**\n     * Compile (static)\n     *\n     * @description\n     * Compile an object describing a JSON Schema into a validation function.\n     *\n     * @param {Object} schema\n     * @returns {Function}\n     */\n    value: function compile(schema) {\n      var validator = new Validator(schema);\n\n      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\n      return new Function('data', body);\n    }\n\n    /**\n     * Return current iterator index counter and increase value\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'counter',\n    get: function get() {\n      return indexCount++;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} schema - object representation of a schema\n     * @param {string} options - compilation options\n     */\n\n  }]);\n\n  function Validator(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Validator);\n\n    // assign schema to this\n    this.schema = schema;\n\n    // assign all options to this\n    Object.assign(this, options);\n\n    // ensure address is defined\n    if (!this.address) {\n      this.address = '';\n    }\n\n    // ensure require is boolean\n    if (this.require !== true) {\n      this.require = false;\n    }\n  }\n\n  /**\n   * Compile\n   *\n   * @description\n   * The instance compile method is \"dumb\". It only sequences invocation of\n   * more specific compilation methods. It generates code to\n   *\n   *  - read a value from input\n   *  - validate type(s) of input\n   *  - validate constraints described by various schema keywords\n   *\n   * Conditional logic related to code generation is pushed downsteam to\n   * type-specific methods.\n   */\n\n\n  _createClass(Validator, [{\n    key: 'compile',\n    value: function compile() {\n      var block = '';\n\n      if (this.require) {\n        block += this.required();\n      }\n\n      // type validation\n      block += this.type();\n\n      // type specific validation generators\n      // null and boolean are covered by this.type()\n      // integer should be covered by number and this.type()\n      block += this.array();\n      block += this.number();\n      block += this.object();\n      block += this.string();\n\n      // non-type-specific validation generators\n      block += this.enum();\n      block += this.anyOf();\n      block += this.allOf();\n      block += this.not();\n      block += this.oneOf();\n\n      return block;\n    }\n\n    /**\n     * push\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n    }\n\n    /**\n     * pop\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n    }\n\n    /**\n     * type\n     *\n     * @description\n     * > An instance matches successfully if its primitive type is one of the\n     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n     * > JSON Schema Validation Section 5.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'type',\n    value: function type() {\n      var type = this.schema.type,\n          address = this.address;\n\n      var block = '';\n\n      if (type) {\n        var types = Array.isArray(type) ? type : [type];\n        var conditions = types.map(function (type) {\n          // TODO: can we make a mapping object for this to clean it up?\n          if (type === 'array') return '!Array.isArray(value)';\n          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n          if (type === 'integer') return '!Number.isInteger(value)';\n          if (type === 'null') return 'value !== null';\n          if (type === 'number') return 'typeof value !== \\'number\\'';\n          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n          if (type === 'string') return 'typeof value !== \\'string\\'';\n        }).join(' && ');\n\n        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Type-specific validations\n     *\n     * Type checking is optional in JSON Schema, and a schema can allow\n     * multiple types. Generated code needs to apply type-specific validations\n     * only to appropriate values, and ignore everything else. Type validation\n     * itself is handled separately from other validation keywords.\n     *\n     * The methods `array`, `number`, `object`, `string` generate type-specific\n     * validation code blocks, wrapped in a conditional such that they will\n     * only be applied to values of that type.\n     *\n     * For example, the `number` method, given the schema\n     *\n     *     { minimum: 3 }\n     *\n     * will generate\n     *\n     *     if (typeof value === 'number') {\n     *       if (value < 3) {\n     *         valid = false\n     *         errors.push({ message: '...' })\n     *       }\n     *     }\n     *\n     * Integer values are also numbers, and are validated the same as numbers\n     * other than the type validation itself. Therefore no `integer` method is\n     * needed.\n     */\n\n    /**\n     * array\n     *\n     * @description\n     * Invoke methods for array-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to array values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'array',\n    value: function array() {\n      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * number\n     *\n     * @description\n     * Invoke methods for number-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to number values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'number',\n    value: function number() {\n      var keywords = ['minimum', 'maximum', 'multipleOf'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * object\n     *\n     * @description\n     * Invoke methods for object-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to object values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'object',\n    value: function object() {\n      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * string\n     *\n     * @description\n     * Invoke methods for string-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to string values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * validations\n     *\n     * @description\n     * Iterate over an array of keywords and invoke code generator methods\n     * for each. Concatenate the results together and return. Used by \"type\"\n     * methods such as this.array() and this.string()\n     *\n     * @param {Array} keywords\n     * @returns {string}\n     */\n\n  }, {\n    key: 'validations',\n    value: function validations(keywords) {\n      var _this = this;\n\n      var schema = this.schema;\n\n      var block = '';\n\n      var constraints = Object.keys(schema).filter(function (key) {\n        return keywords.indexOf(key) !== -1;\n      });\n\n      constraints.forEach(function (keyword) {\n        block += _this[keyword]();\n      });\n\n      return block;\n    }\n\n    /**\n     * enum\n     *\n     * @description\n     * > An instance validates successfully against this keyword if its value\n     * > is equal to one of the elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.5.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'enum',\n    value: function _enum() {\n      var enumerated = this.schema.enum,\n          address = this.address;\n\n      var conditions = ['value !== undefined'];\n      var block = '';\n\n      if (enumerated) {\n        enumerated.forEach(function (value) {\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'number':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'string':\n              conditions.push('value !== \"' + value + '\"');\n              break;\n\n            case 'object':\n              if (value === null) {\n                conditions.push('value !== null');\n              } else {\n                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n              }\n              break;\n\n            default:\n              throw new Error('Things are not well in the land of enum');\n\n          }\n        });\n\n        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * anyOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against at least one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.4\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'anyOf',\n    value: function anyOf() {\n      var anyOf = this.schema.anyOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(anyOf)) {\n        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\n        anyOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n        });\n\n        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * allOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against all schemas defined by this keyword's\n     * > value.\n     * > JSON Schema Validation Section 5.5.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'allOf',\n    value: function allOf() {\n      var allOf = this.schema.allOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(allOf)) {\n        allOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        ' + validator.compile() + '\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * oneOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against exactly one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.5\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      var oneOf = this.schema.oneOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(oneOf)) {\n        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\n        oneOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n        });\n\n        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * not\n     *\n     * @description\n     * > An instance is valid against this keyword if it fails to validate\n     * > successfully against the schema defined by this keyword.\n     * > JSON Schema Validation Section 5.5.6\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'not',\n    value: function not() {\n      var not = this.schema.not,\n          address = this.address;\n\n      var block = '';\n\n      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n        var subschema = not;\n        var validator = new Validator(subschema, { address: address });\n\n        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     *\n     * @description\n     * Iterate over the `properties` schema property if it is an object. For each\n     * key, initialize a new Validator for the subschema represented by the property\n     * value and invoke compile. Append the result of compiling each subschema to\n     * the block of code being generated.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          address = this.address;\n      var properties = schema.properties,\n          required = schema.required;\n\n      var block = this.push();\n\n      // ensure the value of \"required\" schema property is an array\n      required = Array.isArray(required) ? required : [];\n\n      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var isRequired = required.indexOf(key) !== -1;\n          // TODO\n          // how should we be calculating these things? should be json pointer?\n          // needs a separate function\n          var pointer = [address, key].filter(function (segment) {\n            return !!segment;\n          }).join('.');\n          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\n          // read the value\n          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\n          block += validation.compile();\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Other Properties\n     *\n     * @description\n     * This method is not for a keyword. It wraps validations for\n     * patternProperties and additionalProperties in a single iteration over\n     * an object-type value's properties.\n     *\n     * It should only be invoked once for a given subschema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'otherProperties',\n    value: function otherProperties() {\n      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n    }\n\n    /**\n     * Pattern Validations\n     *\n     * @description\n     * Generate validation code from a subschema for properties matching a\n     * regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternValidations',\n    value: function patternValidations() {\n      var patternProperties = this.schema.patternProperties;\n\n      var block = '';\n\n      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n        Object.keys(patternProperties).forEach(function (pattern) {\n          var subschema = patternProperties[pattern];\n          var validator = new Validator(subschema);\n          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * Additional Validations\n     *\n     * @description\n     * Generate validation code, either from a subschema for properties not\n     * defined in the schema, or to disallow properties not defined in the\n     * schema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalValidations',\n    value: function additionalValidations() {\n      var _schema = this.schema,\n          properties = _schema.properties,\n          additionalProperties = _schema.additionalProperties,\n          address = this.address;\n\n      var validations = '';\n      var block = '';\n\n      // catch additional unmatched properties\n      var conditions = ['matched !== true'];\n\n      // ignore defined properties\n      Object.keys(properties || {}).forEach(function (key) {\n        conditions.push('key !== \\'' + key + '\\'');\n      });\n\n      // validate additional properties\n      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n        var subschema = additionalProperties;\n        var validator = new Validator(subschema, { address: address + '[APKey]' });\n        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n      }\n\n      // error for additional properties\n      if (additionalProperties === false) {\n        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * patternProperties\n     *\n     * @description\n     * Generate validation code for properties matching a pattern\n     * defined by the property name (key), which must be a string\n     * representing a valid regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternProperties',\n    value: function patternProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * additionalProperties\n     *\n     * @description\n     * Generate validation code for additional properties not defined\n     * in the schema, or disallow additional properties if the value of\n     * `additionalProperties` in the schema is `false`.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * minProperties\n     *\n     * @description\n     * > An object instance is valid against \"minProperties\" if its number of\n     * > properties is greater than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minProperties',\n    value: function minProperties() {\n      var minProperties = this.schema.minProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxProperties\n     *\n     * @description\n     * > An object instance is valid against \"maxProperties\" if its number of\n     * > properties is less than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxProperties',\n    value: function maxProperties() {\n      var maxProperties = this.schema.maxProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Dependencies\n     *\n     * @description\n     * > For all (name, schema) pair of schema dependencies, if the instance has\n     * > a property by this name, then it must also validate successfully against\n     * > the schema.\n     * >\n     * > Note that this is the instance itself which must validate successfully,\n     * > not the value associated with the property name.\n     * >\n     * > For each (name, propertyset) pair of property dependencies, if the\n     * > instance has a property by this name, then it must also have properties\n     * > with the same names as propertyset.\n     * > JSON Schema Validation Section 5.4.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'dependencies',\n    value: function dependencies() {\n      var dependencies = this.schema.dependencies,\n          address = this.address;\n\n\n      var block = this.push();\n\n      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n        Object.keys(dependencies).forEach(function (key) {\n          var dependency = dependencies[key];\n          var conditions = [];\n\n          if (Array.isArray(dependency)) {\n            dependency.forEach(function (item) {\n              conditions.push('container[\\'' + item + '\\'] === undefined');\n            });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n            var subschema = dependency;\n            var validator = new Validator(subschema, { address: address });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n          }\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Required\n     *\n     * @description\n     * > An object instance is valid against this keyword if its property set\n     * > contains all elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.4.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'required',\n    value: function required() {\n      var properties = this.schema.properties,\n          address = this.address;\n\n      var block = '';\n\n      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\n      return block;\n    }\n\n    /**\n     * additionalItems\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {\n      var _schema2 = this.schema,\n          items = _schema2.items,\n          additionalItems = _schema2.additionalItems,\n          address = this.address;\n\n      var block = '';\n\n      if (additionalItems === false && Array.isArray(items)) {\n        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n      }\n\n      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n        var subschema = additionalItems;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Items\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * Code to generate\n     *\n     *     // this outer conditional is generated by this.array()\n     *     if (Array.isArray(value) {\n     *       let parent = value\n     *       for (let i = 0; i < parent.length; i++) {\n     *         value = parent[i]\n     *         // other validation code depending on value here\n     *       }\n     *       value = parent\n     *     }\n     *\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var items = this.schema.items,\n          address = this.address;\n\n      var block = '';\n\n      // if items is an array\n      if (Array.isArray(items)) {\n        block += this.push();\n\n        items.forEach(function (item, index) {\n          var subschema = item;\n          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\n          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n        });\n\n        block += this.pop();\n\n        // if items is an object\n      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n        var subschema = items;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minItems\n     *\n     * @description\n     * > An array instance is valid against \"minItems\" if its size is greater\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minItems',\n    value: function minItems() {\n      var minItems = this.schema.minItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxItems\n     *\n     * @description\n     * > An array instance is valid against \"maxItems\" if its size is less\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxItems',\n    value: function maxItems() {\n      var maxItems = this.schema.maxItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * uniqueItems\n     *\n     * @description\n     * > If this keyword has boolean value false, the instance validates\n     * > successfully. If it has boolean value true, the instance validates\n     * > successfully if all of its elements are unique.\n     * > JSON Schema Validation Section 5.3.4\n     *\n     * TODO\n     * optimize\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'uniqueItems',\n    value: function uniqueItems() {\n      var uniqueItems = this.schema.uniqueItems,\n          address = this.address;\n\n      var block = '';\n\n      if (uniqueItems === true) {\n        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is\n     * > greater than, or equal to, the value of this keyword. The length of\n     * > a string instance is defined as the number of its characters as\n     * > defined by RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength() {\n      var minLength = this.schema.minLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is less\n     * > than, or equal to, the value of this keyword. The length of a string\n     * > instance is defined as the number of its characters as defined by\n     * > RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxLength',\n    value: function maxLength() {\n      var maxLength = this.schema.maxLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Pattern\n     *\n     * @description\n     * > A string instance is considered valid if the regular expression\n     * > matches the instance successfully.\n     * > JSON Schema Validation Section 5.2.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      var pattern = this.schema.pattern,\n          address = this.address;\n\n\n      if (pattern) {\n        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n      }\n    }\n\n    /**\n     * Format\n     *\n     * @description\n     * > Structural validation alone may be insufficient to validate that\n     * > an instance meets all the requirements of an application. The\n     * > \"format\" keyword is defined to allow interoperable semantic\n     * > validation for a fixed subset of values which are accurately\n     * > described by authoritative resources, be they RFCs or other\n     * > external specifications.\n     * > JSON Schema Validation Section 7.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'format',\n    value: function format() {\n      var format = this.schema.format,\n          address = this.address;\n\n      var matcher = formats.resolve(format);\n\n      if (matcher) {\n        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n      }\n    }\n\n    /**\n     * Minimum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is greater\n     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n     * > present and has boolean value true, the instance is valid if it is\n     * > strictly greater than the value of \"minimum\".\n     * > JSON Schema Validation Section 5.1.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      var _schema3 = this.schema,\n          minimum = _schema3.minimum,\n          exclusiveMinimum = _schema3.exclusiveMinimum,\n          address = this.address;\n\n      var operator = exclusiveMinimum === true ? '<=' : '<';\n\n      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Maximum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is lower than,\n     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n     * > boolean value true, the instance is valid if it is strictly lower\n     * > than the value of \"maximum\".\n     * > JSON Schema Validation Section 5.1.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      var _schema4 = this.schema,\n          maximum = _schema4.maximum,\n          exclusiveMaximum = _schema4.exclusiveMaximum,\n          address = this.address;\n\n      var operator = exclusiveMaximum === true ? '>=' : '>';\n\n      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * multipleOf\n     *\n     * @description\n     * > A numeric instance is valid against \"multipleOf\" if the result of\n     * > the division of the instance by this keyword's value is an integer.\n     * > JSON Schema Validation Section 5.1.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'multipleOf',\n    value: function multipleOf() {\n      var multipleOf = this.schema.multipleOf;\n\n      var block = '';\n\n      if (typeof multipleOf === 'number') {\n        var length = multipleOf.toString().length;\n        var decimals = length - multipleOf.toFixed(0).length - 1;\n        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n        var condition = void 0;\n\n        if (decimals > 0) {\n          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n        } else {\n          condition = 'value % ' + multipleOf + ' !== 0';\n        }\n\n        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n  }]);\n\n  return Validator;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Validator;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/Validator.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","module.exports = crypto;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 22\n// module chunks = 0","'use strict';\n\n/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\nvar JWA = require('./jose/JWA');\nvar JWK = require('./jose/JWK');\nvar JWKSet = require('./jose/JWKSet');\nvar JWT = require('./jose/JWT');\nvar JWS = require('./jose/JWS');\nvar Base64URLSchema = require('./schemas/Base64URLSchema');\nvar JOSEHeaderSchema = require('./schemas/JOSEHeaderSchema');\nvar JWKSchema = require('./schemas/JWKSchema');\nvar JWKSetSchema = require('./schemas/JWKSetSchema');\nvar JWTClaimsSetSchema = require('./schemas/JWTClaimsSetSchema');\nvar JWTSchema = require('./schemas/JWTSchema'\n\n/**\n * Export\n */\n);module.exports = {\n  JWA: JWA,\n  JWK: JWK,\n  JWKSet: JWKSet,\n  JWT: JWT,\n  JWS: JWS,\n  Base64URLSchema: Base64URLSchema,\n  JOSEHeaderSchema: JOSEHeaderSchema,\n  JWKSchema: JWKSchema,\n  JWKSetSchema: JWKSetSchema,\n  JWTClaimsSetSchema: JWTClaimsSetSchema,\n  JWTSchema: JWTSchema\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = require('base64url');\nvar crypto = require('@trust/webcrypto');\nvar TextEncoder = require('../text-encoder'\n\n/**\n * HMAC with SHA-2 Functions\n */\n);\nvar HMAC = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  function HMAC(params) {\n    _classCallCheck(this, HMAC);\n\n    this.params = params;\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO: validate key length\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {string} signature\n     * @param {string} data\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * Assert Sufficient Key Length\n     *\n     * @description Assert that the key length is sufficient\n     * @param {string} key\n     */\n\n  }, {\n    key: 'assertSufficientKeyLength',\n    value: function assertSufficientKeyLength(key) {\n      if (key.length < this.bitlength) {\n        throw new Error('The key is too short.');\n      }\n    }\n  }]);\n\n  return HMAC;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = HMAC;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/HMAC.js","'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * None\n */\nvar None = function () {\n  function None() {\n    _classCallCheck(this, None);\n  }\n\n  _createClass(None, [{\n    key: 'sign',\n\n    /**\n     * sign\n     */\n    value: function sign() {\n      return Promise.resolve('');\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      // this will never get called. but you looked.\n    }\n  }]);\n\n  return None;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = None;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/NONE.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = require('base64url');\nvar crypto = require('@trust/webcrypto');\nvar TextEncoder = require('../text-encoder'\n\n/**\n * RSASSA-PKCS1-v1_5\n */\n);\nvar RSASSA_PKCS1_v1_5 = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function RSASSA_PKCS1_v1_5(params) {\n    _classCallCheck(this, RSASSA_PKCS1_v1_5);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(RSASSA_PKCS1_v1_5, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO\n      //if (!this.sufficientKeySize()) {\n      //  return Promise.reject(\n      //    new Error(\n      //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n      //    )\n      //  )\n      //}\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return RSASSA_PKCS1_v1_5;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = RSASSA_PKCS1_v1_5;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/RSASSA-PKCS1-v1_5.js","'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar NotSupportedError = require('../errors/NotSupportedError'\n\n/**\n * Operations\n */\n);var operations = ['sign', 'verify', 'encrypt', 'decrypt', 'importKey'];\n\n/**\n * SupportedAlgorithms\n */\n\nvar SupportedAlgorithms = function () {\n\n  /**\n   * constructor\n   */\n  function SupportedAlgorithms() {\n    var _this = this;\n\n    _classCallCheck(this, SupportedAlgorithms);\n\n    operations.forEach(function (op) {\n      _this[op] = {};\n    });\n  }\n\n  /**\n   * Supported Operations\n   */\n\n\n  _createClass(SupportedAlgorithms, [{\n    key: 'define',\n\n\n    /**\n     * define\n     *\n     * @description\n     * Register Web Crypto API algorithm parameter for an algorithm\n     * and operation.\n     *\n     * @param {string} alg\n     * @param {string} op\n     * @param {Object} argument\n     */\n    value: function define(alg, op, argument) {\n      var registeredAlgorithms = this[op];\n      registeredAlgorithms[alg] = argument;\n    }\n\n    /**\n     * normalize\n     *\n     * @description\n     * Map JWA alg name to Web Crypto API algorithm parameter\n     *\n     * @param {string} op\n     * @param {Object} alg\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(op, alg) {\n      var registeredAlgorithms = this[op];\n\n      if (!registeredAlgorithms) {\n        return new SyntaxError(); // what kind of error should this be?\n      }\n\n      var argument = registeredAlgorithms[alg];\n\n      if (!argument) {\n        return new NotSupportedError(alg);\n      }\n\n      return argument;\n    }\n  }], [{\n    key: 'operations',\n    get: function get() {\n      return operations;\n    }\n  }]);\n\n  return SupportedAlgorithms;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = SupportedAlgorithms;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/SupportedAlgorithms.js","'use strict';\n\n/**\n * Local dependencies\n */\nvar None = require('./NONE');\nvar HMAC = require('./HMAC');\nvar RSASSA_PKCS1_v1_5 = require('./RSASSA-PKCS1-v1_5');\nvar SupportedAlgorithms = require('./SupportedAlgorithms'\n\n/**\n * Register Supported Algorithms\n */\n);var supportedAlgorithms = new SupportedAlgorithms();\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n})\n//supportedAlgorithms.define('ES256', 'sign', {})\n//supportedAlgorithms.define('ES384', 'sign', {})\n//supportedAlgorithms.define('ES512', 'sign', {})\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\n\n);supportedAlgorithms.define('none', 'sign', new None({\n  // nothing goes here\n})\n\n/**\n * Verify\n */\n);supportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n})\n//supportedAlgorithms.define('ES256', 'verify', {})\n//supportedAlgorithms.define('ES384', 'verify', {})\n//supportedAlgorithms.define('ES512', 'verify', {})\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\n\n);supportedAlgorithms.define('none', 'verify', new None({\n  // nothing goes here\n}));\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n})\n\n/**\n * Export\n */\n);module.exports = supportedAlgorithms;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/index.js","'use strict';\n\n/**\n * Package dependencies\n */\nvar _require = require('@trust/json-document'\n\n/**\n * Format extensions\n */\n),\n    Formats = _require.Formats;\n\nFormats.register('StringOrURI', new RegExp());\nFormats.register('NumericDate', new RegExp());\nFormats.register('URI', new RegExp());\nFormats.register('url', new RegExp());\nFormats.register('base64', new RegExp());\nFormats.register('base64url', new RegExp());\nFormats.register('MediaType', new RegExp());\n\n\n// WEBPACK FOOTER //\n// ./lib/formats/index.js","'use strict';\n\n/**\n * Dependencies\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = require('@trust/json-document'),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSetSchema = require('../schemas/JWKSetSchema');\nvar JWK = require('./JWK'\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\n);\nvar JWKSet = function (_JSONDocument) {\n  _inherits(JWKSet, _JSONDocument);\n\n  function JWKSet() {\n    _classCallCheck(this, JWKSet);\n\n    return _possibleConstructorReturn(this, (JWKSet.__proto__ || Object.getPrototypeOf(JWKSet)).apply(this, arguments));\n  }\n\n  _createClass(JWKSet, null, [{\n    key: 'importKeys',\n\n\n    /**\n     * importKeys\n     */\n    value: function importKeys(jwks) {\n      var validation = this.schema.validate(jwks);\n\n      if (!validation.valid) {\n        return Promise.reject(new Error('Invalid JWKSet: ' + JSON.stringify(validation, null, 2)));\n      }\n\n      if (!jwks.keys) {\n        return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'));\n      }\n\n      var imported = void 0,\n          importing = void 0;\n\n      try {\n        imported = new JWKSet(jwks);\n        importing = jwks.keys.map(function (key) {\n          return JWK.importKey(key);\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n\n      return Promise.all(importing).then(function (keys) {\n        imported.keys = keys;\n        return imported;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWKSetSchema;\n    }\n  }]);\n\n  return JWKSet;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWKSet;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWKSet.js","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Dependencies\n */\nvar base64url = require('base64url');\n\nvar _require = require('@trust/json-document'),\n    JSONDocument = _require.JSONDocument;\n\nvar JWTSchema = require('../schemas/JWTSchema');\nvar JWS = require('./JWS');\nvar DataError = require('../errors/DataError'\n\n/**\n * JWT\n */\n);\nvar JWT = function (_JSONDocument) {\n  _inherits(JWT, _JSONDocument);\n\n  function JWT() {\n    _classCallCheck(this, JWT);\n\n    return _possibleConstructorReturn(this, (JWT.__proto__ || Object.getPrototypeOf(JWT)).apply(this, arguments));\n  }\n\n  _createClass(JWT, [{\n    key: 'isJWE',\n\n\n    /**\n     * isJWE\n     */\n    value: function isJWE() {\n      return !!this.header.enc;\n    }\n\n    /**\n     * resolveKeys\n     */\n\n  }, {\n    key: 'resolveKeys',\n    value: function resolveKeys(jwks) {\n      var kid = this.header.kid;\n      var keys = void 0,\n          match = void 0;\n\n      // treat an array as the \"keys\" property of a JWK Set\n      if (Array.isArray(jwks)) {\n        keys = jwks;\n      }\n\n      // presence of keys indicates object is a JWK Set\n      if (jwks.keys) {\n        keys = jwks.keys;\n      }\n\n      // wrap a plain object they is not a JWK Set in Array\n      if (!jwks.keys && (typeof jwks === 'undefined' ? 'undefined' : _typeof(jwks)) === 'object') {\n        keys = [jwks];\n      }\n\n      // ensure there are keys to search\n      if (!keys) {\n        throw new DataError('Invalid JWK argument');\n      }\n\n      // match by \"kid\" or \"use\" header\n      if (kid) {\n        match = keys.find(function (jwk) {\n          return jwk.kid === kid;\n        });\n      } else {\n        match = keys.find(function (jwk) {\n          return jwk.use === 'sig';\n        });\n      }\n\n      // assign matching key to JWT and return a boolean\n      if (match) {\n        this.key = match.cryptoKey;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      // validate\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      var token = this;\n\n      if (this.isJWE()) {\n        return JWE.encrypt(token);\n      } else {\n        return JWS.sign(token);\n      }\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a decoded JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      return JWS.verify(this);\n    }\n  }], [{\n    key: 'decode',\n\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Token\n     *\n     * @param {string} data\n     * @returns {JWT}\n     */\n    value: function decode(data) {\n      var ExtendedJWT = this;\n      var jwt = void 0;\n\n      if (typeof data !== 'string') {\n        throw new DataError('JWT must be a string');\n      }\n\n      // JSON of Flattened JSON Serialization\n      if (data.startsWith('{')) {\n        try {\n          data = JSON.parse(data, function () {});\n        } catch (error) {\n          throw new DataError('Invalid JWT serialization');\n        }\n\n        if (data.signatures || data.recipients) {\n          data.serialization = 'json';\n        } else {\n          data.serialization = 'flattened';\n        }\n\n        jwt = new ExtendedJWT(data, { filter: false });\n\n        // Compact Serialization\n      } else {\n        try {\n          var serialization = 'compact';\n          var segments = data.split('.');\n          var length = segments.length;\n\n          if (length !== 3 && length !== 5) {\n            throw new Error('Malformed JWT');\n          }\n\n          var header = JSON.parse(base64url.decode(segments[0])\n\n          // JSON Web Signature\n          );if (length === 3) {\n            var type = 'JWS';\n            var payload = JSON.parse(base64url.decode(segments[1]));\n            var signature = segments[2];\n\n            jwt = new ExtendedJWT({ type: type, segments: segments, header: header, payload: payload, signature: signature, serialization: serialization }, { filter: false });\n          }\n\n          // JSON Web Encryption\n          if (length === 5) {\n            //let type = 'JWE'\n            //let [protected, encryption_key, iv, ciphertext, tag] = segments\n\n            //jwt = new ExtendedJWT({\n            //  type,\n            //  protected: base64url.decode(JSON.parse(protected)),\n            //  encryption_key,\n            //  iv,\n            //  ciphertext,\n            //  tag,\n            //  serialization\n            //})\n          }\n        } catch (error) {\n          throw new DataError('Invalid JWT compact serialization');\n        }\n      }\n\n      return jwt;\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token\n     *\n     * @param {Object} header\n     * @param {Object} payload\n     * @param {CryptoKey} key\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode(header, payload, key) {\n      var jwt = new JWT(header, payload);\n      return jwt.encode(key);\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     *\n     * @param {CryptoKey} key\n     * @param {string} token\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, token) {\n      var jwt = JWT.decode(token);\n      jwt.key = key;\n      return jwt.verify().then(function (verified) {\n        return jwt;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWTSchema;\n    }\n  }]);\n\n  return JWT;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWT;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWT.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPatch = require('./JSONPatch');\n\n/**\n * JSONDocument\n *\n * @class\n * JSONDocument is a high level interface that binds together all other features of\n * this package and provides the principle method of data modeling.\n */\n\nvar JSONDocument = function () {\n  _createClass(JSONDocument, null, [{\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      throw new Error('Schema must be defined by classes extending JSONDocument');\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} data\n     * @param {Object} options\n     */\n\n  }]);\n\n  function JSONDocument() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSONDocument);\n\n    this.initialize(data, options);\n  }\n\n  /**\n   * Initialize\n   *\n   * @param {Object} data\n   * @param {Object} options\n   */\n\n\n  _createClass(JSONDocument, [{\n    key: 'initialize',\n    value: function initialize() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = this.constructor.schema;\n\n      schema.initialize(this, data, options);\n    }\n\n    /**\n     * Validate\n     *\n     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(alternate) {\n      var schema = this.constructor.schema;\n\n      return (alternate || schema).validate(this);\n    }\n\n    /**\n     * Patch\n     *\n     * @param {Array} ops\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(ops) {\n      var patch = new JSONPatch(ops);\n      patch.apply(this);\n    }\n\n    /**\n     * Select\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {}\n\n    /**\n     * Project\n     *\n     * @description\n     * Given a mapping, return an object projected from the current instance.\n     *\n     * @example\n     * let schema = new JSONSchema({\n     *   properties: {\n     *     foo: { type: 'Array' }\n     *   }\n     * })\n     *\n     * let mapping = new JSONMapping({\n     *   '/foo/0': '/bar/baz'\n     * })\n     *\n     * class FooTracker extends JSONDocument {\n     *   static get schema () { return schema }\n     * }\n     *\n     * let instance = new FooTracker({ foo: ['qux'] })\n     * instance.project(mapping)\n     * // => { bar: { baz: 'qux' } }\n     *\n     * @param {JSONMapping} mapping\n     * @return {Object}\n     */\n\n  }, {\n    key: 'project',\n    value: function project(mapping) {\n      return mapping.project(this);\n    }\n\n    /**\n     * Serialize\n     *\n     * @param {Object} object\n     * @returns {string}\n     */\n\n  }], [{\n    key: 'serialize',\n    value: function serialize(object) {\n      return JSON.stringify(object);\n    }\n\n    /**\n     * Deserialize\n     *\n     * @param {string} data\n     * @return {*}\n     */\n\n  }, {\n    key: 'deserialize',\n    value: function deserialize(data) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        throw new Error('Failed to parse JSON');\n      }\n    }\n  }]);\n\n  return JSONDocument;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONDocument;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONDocument.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = require('./JSONPointer');\n\n/**\n * JSONPointer mode\n */\nvar RECOVER = 1;\n\n/**\n * JSONMapping\n *\n * @class\n * Defines a means to declaratively translate between object\n * representations using JSON Pointer syntax.\n */\n\nvar JSONMapping = function () {\n\n  /**\n   * Constructor\n   *\n   * @description Translate pointers from JSON Strings into Pointer objects\n   * @param {Object} mapping\n   */\n  function JSONMapping(mapping) {\n    var _this = this;\n\n    _classCallCheck(this, JSONMapping);\n\n    Object.defineProperty(this, 'mapping', {\n      enumerable: false,\n      value: new Map()\n    });\n\n    Object.keys(mapping).forEach(function (key) {\n      var value = mapping[key];\n      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n    });\n  }\n\n  /**\n   * Map\n   *\n   * @description Assign values from source to target by reading the mapping\n   * from right to left.\n   * @param {Object} target\n   * @param {Object} source\n   */\n\n\n  _createClass(JSONMapping, [{\n    key: 'map',\n    value: function map(target, source) {\n      this.mapping.forEach(function (right, left) {\n        left.add(target, right.get(source));\n      });\n    }\n\n    /**\n     * Project\n     *\n     * @description Assign values from source to target by reading the mapping\n     * from left to right.\n     * @param {Object} source\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'project',\n    value: function project(source, target) {\n      this.mapping.forEach(function (right, left) {\n        right.add(target, left.get(source));\n      });\n    }\n  }]);\n\n  return JSONMapping;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONMapping;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONMapping.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = require('./Initializer');\nvar Validator = require('./Validator');\n\n/**\n * JSONSchema\n *\n * @class\n * Compiles JSON Schema documents to an object with object initialization\n * and validation methods.\n */\n\nvar JSONSchema = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Object} schema\n   */\n  function JSONSchema(schema) {\n    _classCallCheck(this, JSONSchema);\n\n    // TODO: optionally parse JSON string?\n    Object.assign(this, schema);\n\n    // add schema-derived initialize and validate methods\n    Object.defineProperties(this, {\n      initialize: {\n        enumerable: false,\n        writeable: false,\n        value: Initializer.compile(schema)\n      },\n      validate: {\n        enumerable: false,\n        writeable: false,\n        value: Validator.compile(schema)\n      }\n    });\n  }\n\n  /**\n   * Extend\n   *\n   * @description\n   * ...\n   * Dear future,\n   *\n   * This function was meticulously plagiarized from some curious amalgam of\n   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n   *\n   * Goodnight.\n   *\n   * @param {Object} schema\n   * @returns {JSONSchema}\n   */\n\n\n  _createClass(JSONSchema, [{\n    key: 'extend',\n    value: function extend(schema) {\n      function isObject(data) {\n        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n      }\n\n      function extender(target, source) {\n        var result = Object.assign({}, target);\n        if (isObject(target) && isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(result, _defineProperty({}, key, source[key]));\n              } else {\n                result[key] = extender(target[key], source[key]);\n              }\n            } else {\n              Object.assign(result, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n        return result;\n      }\n\n      var descriptor = extender(this, schema);\n      return new JSONSchema(descriptor);\n    }\n  }]);\n\n  return JSONSchema;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONSchema;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONSchema.js","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64-js/index.js","\"use strict\";\nvar pad_string_1 = require(\"./pad-string\");\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(new Buffer(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return new Buffer(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return new Buffer(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = base64url;\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64url/dist/base64url.js","\"use strict\";\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = new Buffer(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = padString;\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64url/dist/pad-string.js","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/ieee754/index.js","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/isarray/index.js","module.exports = TextEncoder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"TextEncoder\"\n// module id = 40\n// module chunks = 0"],"sourceRoot":""}